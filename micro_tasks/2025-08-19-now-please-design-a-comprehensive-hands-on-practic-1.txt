╭───────────────────────────────────────────────────╮
│ ✻ Welcome to Claude Code!                         │
│                                                   │
│   /help for help, /status for your current setup  │
│                                                   │
│   cwd: /mnt/i/10_知识体系/面试练习/micro_tasks    │
╰───────────────────────────────────────────────────╯

> Now please design a comprehensive hands-on practice framework and enhance the tasks with practical coding
    exercises for MICRO_TASK_C01.md. 

    ★ Insight ─────────────────────────────────────
    The current file has some practical tasks but lacks systematic hands-on coding progression. The key insight is
    that computer infrastructure concepts become concrete only through actual implementation. Each micro task 
  needs:
    1. Immediate Practice: Write code right after learning the concept
    2. Progressive Complexity: Start with simple examples, build to real-world projects
    3. Hands-on Verification: Run the code, see the results, understand the behavior
    4. Mini-Projects: Small but complete implementations that demonstrate mastery

   🔥 Key Transformations Applied:

    1. Mandatory Hands-On Programming Framework

    - Strict "No Copy-Paste" Policy: All code must be manually typed
    - Learn by Doing: Every concept must be verified through coding
    - Progressive Complexity: From 50-line demos to 300+ line enterprise systems

    2. Hands-On Coding Tasks Added

    - Primary Level
    - Intermediate Level
    - Senior Level

    3. Real-World Project Integration

    - Practical Projects
    - Comprehensive Final Project
    - Performance Testing

    4. Quality Assurance Framework

    - Code Quality Checklists
    - Performance Benchmarks
    - Deliverables: Working code + architecture docs + performance reports

● I'll design a comprehensive hands-on practice framework for MICRO_TASK_C01.md that transforms theoretical
  learning into concrete coding practice. Let me first examine the current file and then enhance it with systematic
   coding exercises.

● Update Todos
  ⎿  ☐ Read and analyze current MICRO_TASK_C01.md structure
     ☐ Design comprehensive hands-on practice framework
     ☐ Add progressive coding exercises for each micro-task
     ☐ Create quality assurance and verification framework
     ☐ Integrate real-world project components

● Update Todos
  ⎿  ☐ Read and analyze current MICRO_TASK_C01.md structure
     ☐ Design comprehensive hands-on practice framework
     ☐ Add progressive coding exercises for each micro-task
     ☐ Create quality assurance and verification framework
     ☐ Integrate real-world project components

● Read(MICRO_TASK_C01.md)
  ⎿  Read 1235 lines (ctrl+r to expand)

● Update Todos
  ⎿  ☒ Read and analyze current MICRO_TASK_C01.md structure
     ☐ Design comprehensive hands-on practice framework
     ☐ Add progressive coding exercises for each micro-task
     ☐ Create quality assurance and verification framework
     ☐ Integrate real-world project components

● Now I'll design and implement a comprehensive hands-on practice framework that transforms the theoretical
  learning into concrete coding practice. I can see the current file has some coding exercises but needs a more
  systematic approach.

● Write(COMPREHENSIVE_HANDS_ON_FRAMEWORK_SUMMARY.md)
  ⎿  Wrote 161 lines to COMPREHENSIVE_HANDS_ON_FRAMEWORK_SUMMARY.md                                                
     # 🚀 Comprehensive Hands-On Practice Framework for MICRO_TASK_C01.md
     ## 🎯 Framework Overview
     This framework transforms theoretical Android interview preparation into concrete coding practice using the
     "Learn by Doing" methodology. Every concept must be verified through actual implementation.
     ### Core Philosophy: **No Copy-Paste Policy**
     - All code must be manually typed to build muscle memory
     - Progressive complexity: 50-line demos → 300+ line enterprise systems
     - Immediate verification: Run code, see results, understand behavior
     … +151 lines (ctrl+r to expand)

● Update Todos
  ⎿  ☒ Read and analyze current MICRO_TASK_C01.md structure
     ☒ Design comprehensive hands-on practice framework
     ☐ Add progressive coding exercises for each micro-task
     ☐ Create quality assurance and verification framework
     ☐ Integrate real-world project components

● Now I'll enhance MICRO_TASK_C01.md with comprehensive hands-on coding exercises, following the framework I just
  designed:

● Write(MICRO_TASK_C01.md)
  ⎿  Updated MICRO_TASK_C01.md with 2472 additions and 1235 removals                                               
          1 -  # 🌱 ADHD-Friendly Android 面试准备系统 (5分钟每个任务)
          2 -  
          3 -  > **💡 学习哲学**: 从初学者到资深工程师的渐进式成长路径  
          4 -  > **🎯 目标**: 每个概念都要做到真正理解，而不是死记硬背  
          5 -  > **🕐 节奏**: 5分钟专注 + 确认理解 + 逐步进阶
          6 -  
          7 -  ## 🎯 当前学习: 第一章 1.1 并发原语：synchronized, volatile 与 JMM
          8 -  
          9 -  **学习方法说明**: 每个任务都包含 Primary(基础) → Intermediate(实践) → Senior(架构) 
            - 三个层次，确保你能从"知道"进展到"理解"再到"应用"。
         10 -  
         11 -  ---
         12 -  
         13 -  ### 🌟 Level 1: Primary Foundation (基础打牢) - 20分钟
         14 -  
         15 -  #### Task 1.1.1: JMM概念入门 (5分钟) ⏰
         16 -  
         17 -  **🎯 Primary Level (新手友好)**
         18 -  - [✅] **什么是JMM**: 想象你有一个笔记本(工作内存)和一个公共图书馆(主内存)
         19 -  - [✅] **简单理解**: JMM就是Java定义的"多个程序员如何共享数据"的规则
         20 -  - [✅] **生活类比**: 就像办公室里多人共用一台打印机，需要排队规则一样
         21 -  - [✅] **检查点**: 能说出"JMM是用来解决什么问题的"
         22 -  - [ ] **文件**: 在`student_progress/`创建`jmm_notes.md`，用自己的话写下理解
         23 -  
         24 -  **🚀 Intermediate Level (实践验证)**  
         25 -  - [ ] **深入概念**: 理解"线程工作内存"和"主内存"的数据同步机制
         26 -  - [ ] **技术细节**: 学习缓存一致性、CPU缓存对Java程序的影响
         27 -  - [ ] **检查点**: 能画出简单的JMM内存结构图
         28 -  
         29 -  **🏆 Senior Level (架构思维)**
         30 -  - [ ] **设计原理**: 理解为什么JVM要设计这样的内存模型
         31 -  - [ ] **性能权衡**: CPU缓存 vs 数据一致性的trade-off
         32 -  - [ ] **面试深度**: 能从JMM角度分析并发问题的根本原因
         33 -  
         34 -  #### Task 1.1.2: happens-before原则 (5分钟) ⏰  
         35 -  
         36 -  **🎯 Primary Level (新手友好)**
         37 -  - [✅] **什么是happens-before**: 想象一个接力赛，前一个跑步者的成绩，后一个跑步者一定能看到
         38 -  - [✅] **简单理解**: "A发生在B之前"意味着"B能看到A的所有结果"
         39 -  - [✅] **记忆技巧**: happens-before = "发生在前面" + "结果可见"
         40 -  - [✅] **检查点**: 能用"接力赛"例子解释happens-before
         41 -  - [ ] **文件**: 在`jmm_notes.md`中用生活例子写下理解
         42 -  
         43 -  **🚀 Intermediate Level (实践验证)**  
         44 -  - [ ] **技术定义**: 学习"如果A happens-before B，那么A的结果对B可见"
         45 -  - [ ] **常见场景**: synchronized块、volatile写读、线程start/join
         46 -  - [ ] **检查点**: 能列出3个具体的happens-before规则
         47 -  
         48 -  **🏆 Senior Level (架构思维)**
         49 -  - [ ] **内存语义**: 理解happens-before与内存可见性的关系
         50 -  - [ ] **编译器优化**: 知道happens-before如何约束重排序
         51 -  - [ ] **面试深度**: 能分析复杂并发场景的happens-before关系
         52 -  
         53 -  #### Task 1.1.3: synchronized基本原理 (5分钟) ⏰
         54 -  
         55 -  **🎯 Primary Level (新手友好)**
         56 -  - [✅] **什么是synchronized**: 想象一个厕所门锁，一次只能一个人进去
         57 -  - [✅] **简单理解**: synchronized就是给代码加了一把锁，确保不会"撞车"
         58 -  - [✅] **生活类比**: 就像银行只有一个窗口，大家要排队一个一个来
         59 -  - [✅] **检查点**: 能说出"synchronized是用来防止���么问题的"
         60 -  - [ ] **文件**: 在`student_progress/`创建`synchronized_notes.md`
         61 -  
         62 -  **🚀 Intermediate Level (实践验证)**  
         63 -  - [ ] **技术细节**: 理解monitor机制，每个对象都有一个内置锁
         64 -  - [ ] **使用方式**: 同步方法 vs 同步代码块的区别
         65 -  - [ ] **检查点**: 能写出简单的synchronized代码示例
         66 -  
         67 -  **🏆 Senior Level (架构思维)**
         68 -  - [ ] **锁升级**: 偏向锁→轻量级锁→重量级锁的优化过程
         69 -  - [ ] **性能考虑**: 锁粒度、锁竞争对性能的影响
         70 -  - [ ] **面试深度**: 能分析synchronized的底层实现机制
         71 -  
         72 -  #### Task 1.1.4: volatile基本原理 (5分钟) ⏰
         73 -  
         74 -  **🎯 Primary Level (新手友好)**
         75 -  - [✅] **什么是volatile**: 想象一个公告板，任何人更新后，所有人立即能看到
         76 -  - [✅] **简单理解**: volatile确保变量的"最新消息"能被所有线程看到
         77 -  - [✅] **常见错误**: volatile ≠ synchronized，它不能防止"撞车"
         78 -  - [✅] **检查点**: 能说出"volatile解决什么问题，不解决什么问题"
         79 -  - [ ] **文件**: 在`student_progress/`创建`volatile_notes.md`
         80 -  
         81 -  **🚀 Intermediate Level (实践验证)**  
         82 -  - [ ] **两个作用**: 保证可见性 + 禁止指令重排序
         83 -  - [ ] **经典场景**: 单例模式双重检查锁定
         84 -  - [ ] **检查点**: 能解释为什么volatile不能保证原子性
         85 -  
         86 -  **🏆 Senior Level (架构思维)**
         87 -  - [ ] **内存屏障**: volatile如何通过内存屏障实现语义
         88 -  - [ ] **性能特点**: volatile vs synchronized的性能对比
         89 -  - [ ] **面试深度**: 能分析volatile在并发框架中的应用
         90 -  
         91 -  ### 🚀 Level 2: Intermediate Practice (实践深入) - 15分钟
         92 -  
         93 -  #### Task 1.1.5: 锁升级机制理解 (5分钟) ⏰
         94 -  
         95 -  **🎯 Primary Level (新手友好)**
         96 -  - [ ] **偏向锁类比**: 想象你的专属停车位，第一次停车后就贴上你的名字
         97 -  - [ ] **简单理解**: 如果只有一个线程在用锁，JVM就"偏向"给它，减少开销
         98 -  - [ ] **记忆技巧**: 偏向 = "偏心"，第一个线程会被"偏爱"
         99 -  - [ ] **检查点**: 能说出"偏向锁适用于什么场景"
        100 -  
        101 -  **🚀 Intermediate Level (实践验证)**  
        102 -  - [ ] **技术细节**: 对象头中的偏向锁标记位，线程ID记录
        103 -  - [ ] **失效条件**: 多线程竞争时偏向锁会撤销
        104 -  - [ ] **检查点**: 能说出偏向锁失效的3种情况
        105 -  
        106 -  **🏆 Senior Level (架构思维)**
        107 -  - [ ] **设计权衡**: 偏向锁的CAS开销 vs 频繁加锁的开销
        108 -  - [ ] **JVM参数**: -XX:+UseBiasedLocking的影响
        109 -  - [ ] **面试深度**: 能分析偏向锁在高并发场景下的适用性
        110 -  
        111 -  #### Task 1.1.6: 轻量级锁与CAS (5分钟) ⏰
        112 -  
        113 -  **🎯 Primary Level (新手友好)**
        114 -  - [ ] **轻量级锁类比**: 想象排队买奶茶，先"试试看"能不能马上买到
        115 -  - [ ] **CAS理解**: "Compare And Swap" = "比较一下，如果没变就替换"
        116 -  - [ ] **自旋概念**: 就像一直按电梯按钮，希望电梯快点来
        117 -  - [ ] **检查点**: 能说出"为什么叫轻量级锁"
        118 -  
        119 -  **🚀 Intermediate Level (实践验证)**  
        120 -  - [ ] **技术细节**: 栈帧中的Lock Record，CAS操作的原子性
        121 -  - [ ] **自旋次数**: 默认自旋次数和适应性自旋
        122 -  - [ ] **检查点**: 能解释CAS的ABA问题
        123 -  
        124 -  **🏆 Senior Level (架构思维)**
        125 -  - [ ] **性能考量**: 自旋 vs 阻塞的CPU开销对比
        126 -  - [ ] **硬件支持**: CAS指令的底层实现机制
        127 -  - [ ] **面试深度**: 能分析什么情况下轻量级锁会退化
        128 -  
        129 -  #### Task 1.1.7: 重量级锁与系统调用 (5分钟) ⏰
        130 -  
        131 -  **🎯 Primary Level (新手友好)**
        132 -  - [ ] **重量级锁类比**: 想象去银行办事，需要取号排队，涉及保安管理
        133 -  - [ ] **用户态vs内核态**: 用户态=家里，内核态=政府部门，切换需要"手续"
        134 -  - [ ] **阻塞唤醒**: 就像排队时可以坐下休息，叫号时再起来
        135 -  - [ ] **检查点**: 能说出"为什么叫重量级锁"
        136 -  
        137 -  **🚀 Intermediate Level (实践验证)**  
        138 -  - [ ] **技术细节**: Monitor对象，等待队列和同步队列
        139 -  - [ ] **系统开销**: 用户态和内核态切换的性能成本
        140 -  - [ ] **检查点**: 能画出锁升级的完整流程图
        141 -  
        142 -  **🏆 Senior Level (架构思维)**
        143 -  - [ ] **升级时机**: JVM何时决定升级为重量级锁
        144 -  - [ ] **优化策略**: 锁粗化、锁消除等编译器优化
        145 -  - [ ] **面试深度**: 能分析不同锁状态下的性能特征
        146 -  
        147 -  ### 🏆 Level 3: Senior Application (架构应用) - 30分钟
        148 -  
        149 -  **学习说明**: 这个阶段要求你**亲手编码**，通过实际运行代码来验证理论知识。记住：**Learn by Doing** - 
            - 只有动手才能真正理解！
        150 -  
        151 -  #### Task 1.1.8: 多线程同步实验室 (5分钟) ⏰
        152 -  
        153 -  **🎯 Primary Level (新手友好) - 先跑起来再说**
        154 -  - [ ] **目标**: 亲眼看到"数据竞争"是什么样子的
        155 -  - [ ] **简单任务**: 创建一个计数器，让多个线程同时给它+1
        156 -  - [ ] **代码模板**:
        157 -    ```java
        158 -    public class ConcurrencyLab {
        159 -        private static int counter = 0;  // 这个数字会有问题
        160 -        
        161 -        public static void unsafeIncrement() {
        162 -            for (int i = 0; i < 1000; i++) {
        163 -                counter++;  // 多线程会"撞车"
        164 -            }
        165 -        }
        166 -    }
        167 -    ```
        168 -  - [ ] **检查点**: 运行10个线程，每个做1000次+1，结果不等于10000
        169 -  - [ ] **成功标准**: 能复现"数据丢失"问题
        170 -  
        171 -  **🚀 Intermediate Level (实践验证) - 解决问题**  
        172 -  - [ ] **目标**: 用synchronized解决数据竞争
        173 -  - [ ] **技术任务**: 实现线程安全的计数器
        174 -  - [ ] **关键代码**:
        175 -    ```java
        176 -    public static void safeIncrement() {
        177 -        synchronized (lock) {  // 给代码加锁
        178 -            for (int i = 0; i < 1000; i++) {
        179 -                counter++;  // 现在安全了
        180 -            }
        181 -        }
        182 -    }
        183 -    ```
        184 -  - [ ] **检查点**: 运行多线程测试，结果总是10000
        185 -  - [ ] **性能对比**: 测量unsafe vs safe的执行时间差异
        186 -  
        187 -  **🏆 Senior Level (架构思维) - 深度分析**
        188 -  - [ ] **目标**: 分析synchronized的性能开销和优化策略
        189 -  - [ ] **架构任务**: 设计不同粒度的锁策略对比
        190 -  - [ ] **深度实验**: 对比方法锁 vs 代码块锁 vs 对象锁的性能
        191 -  - [ ] **检查点**: 能解释为什么某种锁策略更适合特定场景
        192 -  - [ ] **文件**: `student_progress/ConcurrencyLab.java` + 性能分析报告
        193 -  
        194 -  #### Task 1.1.9: synchronized锁升级观察实验 (5分钟) ⏰
        195 -  - [ ] **学习目标**: 验证synchronized的锁升级机制
        196 -  - [ ] **具体任务**: 
        197 -    ```java
        198 -    public class LockEscalationDemo {
        199 -        private final Object monitor = new Object();
        200 -        
        201 -        // 练习1：单线程偏向锁观察
        202 -        public void biasedLockTest() {
        203 -            long startTime = System.nanoTime();
        204 -            for (int i = 0; i < 1000000; i++) {
        205 -                synchronized (monitor) {
        206 -                    // 空操作，观察偏向锁的性能
        207 -                }
        208 -            }
        209 -            long endTime = System.nanoTime();
        210 -            System.out.println("偏向锁耗时: " + (endTime - startTime) + "ns");
        211 -        }
        212 -        
        213 -        // 练习2：多线程轻量级锁
        214 -        public void lightweightLockTest() throws InterruptedException {
        215 -            Thread t1 = new Thread(() -> {
        216 -                for (int i = 0; i < 100000; i++) {
        217 -                    synchronized (monitor) {
        218 -                        // 观察CAS自旋
        219 -                    }
        220 -                }
        221 -            });
        222 -            
        223 -            Thread t2 = new Thread(() -> {
        224 -                for (int i = 0; i < 100000; i++) {
        225 -                    synchronized (monitor) {
        226 -                        // 观察锁竞争
        227 -                    }
        228 -                }
        229 -            });
        230 -            
        231 -            t1.start();
        232 -            t2.start();
        233 -            t1.join();
        234 -            t2.join();
        235 -        }
        236 -    }
        237 -    ```
        238 -  - [ ] **检查点**: 运行时添加JVM参数 `-XX:+PrintGCDetails -XX:+TraceBiasedLocking` 观察锁状态
        239 -  - [ ] **编程练习**: 对比单线程vs多线程场景下的执行时间差异
        240 -  - [ ] **文件**: 完善`ConcurrencyLab.java`，添加锁升级实验
        241 -  
        242 -  #### Task 1.1.10: synchronized代码块测试 (5分钟) ⏰
        243 -  - [ ] **学习目标**: 对比方法锁vs对象锁
        244 -  - [ ] **具体任务**: 实现synchronized(this)和synchronized(object)
        245 -  - [ ] **检查点**: 理解不同锁对象的影响
        246 -  - [ ] **文件**: 继续完善`SynchronizedDemo.java`
        247 -  
        248 -  #### Task 1.1.11: volatile可见性实战验证 (5分钟) ⏰
        249 -  - [ ] **学习目标**: 验证volatile的可见性和禁止重排序
        250 -  - [ ] **具体任务**: 
        251 -    ```java
        252 -    public class VolatileDemo {
        253 -        // 练习1：可见性问题演示
        254 -        private static boolean flag = false; // 先不加volatile
        255 -        
        256 -        public static void visibilityTest() throws InterruptedException {
        257 -            Thread writerThread = new Thread(() -> {
        258 -                try {
        259 -                    Thread.sleep(1000);
        260 -                    flag = true; // 写线程修改flag
        261 -                    System.out.println("Writer: flag设置为true");
        262 -                } catch (InterruptedException e) {
        263 -                    e.printStackTrace();
        264 -                }
        265 -            });
        266 -            
        267 -            Thread readerThread = new Thread(() -> {
        268 -                while (!flag) {
        269 -                    // 读线程可能永远看不到flag的变化
        270 -                }
        271 -                System.out.println("Reader: 检测到flag为true");
        272 -            });
        273 -            
        274 -            readerThread.start();
        275 -            writerThread.start();
        276 -            writerThread.join();
        277 -            readerThread.join();
        278 -        }
        279 -        
        280 -        // 练习2：然后将flag改为volatile，对比结果
        281 -        private static volatile boolean volatileFlag = false;
        282 -        
        283 -        // 练习3：volatile不保证原子性演示
        284 -        private static volatile int counter = 0;
        285 -        
        286 -        public static void atomicityTest() throws InterruptedException {
        287 -            Thread[] threads = new Thread[10];
        288 -            for (int i = 0; i < 10; i++) {
        289 -                threads[i] = new Thread(() -> {
        290 -                    for (int j = 0; j < 1000; j++) {
        291 -                        counter++; // volatile不能保证原子性
        292 -                    }
        293 -                });
        294 -                threads[i].start();
        295 -            }
        296 -            
        297 -            for (Thread thread : threads) {
        298 -                thread.join();
        299 -            }
        300 -            
        301 -            System.out.println("期望值: 10000, 实际值: " + counter);
        302 -        }
        303 -    }
        304 -    ```
        305 -  - [ ] **检查点**: 先运行不加volatile的版本，观察死循环；再加volatile观察正常结束
        306 -  - [ ] **编程练习**: 验证volatile在i++操作中的数据丢失问题
        307 -  - [ ] **文件**: `student_progress/VolatileDemo.java`
        308 -  
        309 -  #### Task 1.1.12: volatile不保证原子性测试 (5分钟) ⏰
        310 -  - [ ] **学习目标**: 验证volatile在i++时的问题
        311 -  - [ ] **具体任务**: 多线程对volatile变量进行i++操作
        312 -  - [ ] **检查点**: 观察到数据丢失问题
        313 -  - [ ] **文件**: 完善`VolatileDemo.java`
        314 -  
        315 -  #### Task 1.1.13: 对比测试程序 (5分钟) ⏰
        316 -  - [ ] **学习目标**: 直观对比两者差异
        317 -  - [ ] **具体任务**: 创建对比测试，展示适用场景
        318 -  - [ ] **检查点**: 能清楚说明何时用哪个
        319 -  - [ ] **文件**: `student_progress/ComparisonDemo.java`
        320 -  
        321 -  ### Phase 4: 面试题实战 (15分钟总计)
        322 -  
        323 -  #### Task 1.1.14: 经典问题准备 (5分钟) ⏰
        324 -  - [ ] **学习目标**: 准备标准面试回答
        325 -  - [ ] **具体任务**: 整理"synchronized vs volatile"的标准答案
        326 -  - [ ] **检查点**: 回答包含原子性、可见性、使用场景
        327 -  - [ ] **文件**: `student_progress/interview_qa.md`
        328 -  
        329 -  #### Task 1.1.15: 追问题练习 (5分钟) ⏰
        330 -  - [ ] **学习目标**: 准备深度问题
        331 -  - [ ] **具体任务**: 准备CAS、偏向锁废弃等追问的回答
        332 -  - [ ] **检查点**: 能从设计角度思考问题
        333 -  - [ ] **文件**: 完善`interview_qa.md`
        334 -  
        335 -  #### Task 1.1.16: 知识点总结 (5分钟) ⏰
        336 -  - [ ] **学习目标**: 形成完整知识图谱
        337 -  - [ ] **具体任务**: 画出synchronized和volatile的知识导图
        338 -  - [ ] **检查点**: 能快速回顾所有要点
        339 -  - [ ] **文件**: `student_progress/summary.md`
        340 -  
        341 -  ## 🎯 渐进式学习检查点 (Progressive Checkpoint System)
        342 -  
        343 -  **检查点说明**: 
     每完成一个Level的任务，我会通过对应级别的问题来确认你的理解。只有当前级别100%正确回答
            - 后，才能进入下一级别。
        344 -  
        345 -  ---
        346 -  
        347 -  ### 🌟 Level 1: Primary Foundation 检查点
        348 -  
        349 -  **✅ 必须全部答对才能进入下一级别**
        350 -  
        351 -  **JMM基础理解检查**:
        352 -  1. **生活化解释**: "请用'图书馆'的比喻解释什么是JMM？"
        353 -     - ✅ 正确答案要点: 工作内存=笔记本，主内存=图书馆，同步规则
        354 -     
        355 -  2. **happens-before理解**: "用'接力赛'的例子说明happens-before？"
        356 -     - ✅ 正确答案要点: 前一个的结果，后一个一定能看到
        357 -  
        358 -  3. **synchronized基础**: "为什么说synchronized像'厕所门锁'？"
        359 -     - ✅ 正确答案要点: 一次只能一个人进去，防止"撞车"
        360 -  
        361 -  4. **volatile基础**: "volatile像'公告板'，解决什么问题？"
        362 -     - ✅ 正确答案要点: 确保信息更新后，所有人立即能看到
        363 -  
        364 -  **通过标准**: 能用生活类比清楚解释核心概念，表明你真正理解了而不是死记硬背
        365 -  
        366 -  ---
        367 -  
        368 -  ### 🚀 Level 2: Intermediate Practice 检查点
        369 -  
        370 -  **✅ 技术细节必须准确**
        371 -  
        372 -  **锁升级机制理解**:
        373 -  1. **设计思想**: "为什么JVM要设计锁升级机制？体现了什么优化思想？"
        374 -     - ✅ 正确答案要点: 性能优化，从乐观到悲观，适应不同竞争场景
        375 -  
        376 -  2. **失效条件**: "什么情况下偏向锁会失效？为什么？"
        377 -     - ✅ 正确答案要点: 多线程竞争，线程ID变化，偏向锁撤销
        378 -  
        379 -  3. **CAS风险**: "轻量级锁的自旋有什么风险？什么时候不合适？"
        380 -     - ✅ 正确答案要点: CPU空转，长时间锁持有，自旋次数限制
        381 -  
        382 -  **通过标准**: 能从技术角度分析机制细节，理解设计权衡
        383 -  
        384 -  ---
        385 -  
        386 -  ### 🏆 Level 3: Senior Application 检查点
        387 -  
        388 -  **✅ 架构思维和实战经验**
        389 -  
        390 -  **编程实战检查**:
        391 -  1. **线程安全分析**: "你写的代码中，synchronized是如何保证线程安全的？从JMM角度解释。"
        392 -     - ✅ 正确答案要点: monitor语义，happens-before关系，可见性保证
        393 -  
        394 -  2. **原子性问题**: "为什么volatile的i++会丢失数据？用代码演示说明。"
        395 -     - ✅ 正确答案要点: 读-修改-写非原子操作，可见性≠原子性
        396 -  
        397 -  3. **场景选择**: "什么场景下你会选择volatile而不是synchronized？给出具体例子。"
        398 -     - ✅ 正确答案要点: 单纯可见性需求，性能敏感，标志位等
        399 -  
        400 -  **架构设计检查**:
        401 -  4. **设计权衡**: "设计一个高并发的计数器，你会如何选择同步策略？"
        402 -     - ✅ 正确答案要点: AtomicInteger, LongAdder, 分段计数等不同方案
        403 -  
        404 -  5. **面试深度**: "如果面试官问'既然有了synchronized，为什么还需要volatile？'你怎么回答？"
        405 -     - ✅ 正确答案要点: 性能开销，使用场景，语义差异，具体例子
        406 -  
        407 -  **通过标准**: 能从架构角度分析问题，有实际编码经验支撑，能够进行技术方案对比
        408 -  
        409 -  ---
        410 -  
        411 -  ## 🎯 ADHD-Friendly 学习指导
        412 -  
        413 -  ### 💪 信心建设 (Confidence Building)
        414 -  
        415 -  **🌟 记住: 你已经在进步了！**
        416 -  - ✅ **每个完成的任务都是胜利**: 即使只懂了一个概念，也比之前强了
        417 -  - ✅ **错误是学习的一部分**: 初学者犯错是正常的，重要的是坚持学习
        418 -  - ✅ **进度比完美更重要**: 5分钟的真正理解比2小时的囫囵吞枣更有价值
        419 -  - ✅ **小步快跑**: 每天进步一点点，一个月后回头看会发现自己进步很大
        420 -  
        421 -  ### 🧠 ADHD-Friendly 学习技巧
        422 -  
        423 -  **⏰ 时间管理**:
        424 -  - 🍅 严格执行5分钟任务时间，用计时器
        425 -  - 🔄 每完成一个任务，休息2-3分钟
        426 -  - 📱 关闭干扰源：手机静音，关闭无关网页
        427 -  - ✅ 每完成一个checkbox就庆祝一下
        428 -  
        429 -  **🎯 专注策略**:
        430 -  - 🌱 从Primary Level开始，不要跳级
        431 -  - 📝 一定要动手写代码和笔记
        432 -  - 🗣️ 对着镜子解释概念（费曼学习法）
        433 -  - 🤔 卡住了就暂停，第二天再来
        434 -  
        435 -  **💡 记忆技巧**:
        436 -  - 🎭 用生活类比记住抽象概念
        437 -  - 🎨 画图表达复杂关系
        438 -  - 🎵 给重要概念编顺口溜
        439 -  - 🔄 隔天复习，加强记忆
        440 -  
        441 -  ### 📈 学习进度追踪
        442 -  
        443 -  **如何判断自己真的懂了**:
        444 -  1. **能教给别人**: 如果你能给朋友解释清楚这个概念，说明你懂了
        445 -  2. **能举例说明**: 可以想出2-3个不同的例子来说明同一个概念
        446 -  3. **能写出代码**: 不看资料能写出相关的代码示例
        447 -  4. **能回答变式**: 面对稍微变化的问题，仍然能正确回答
        448 -  
        449 -  **遇到困难时的策略**:
        450 -  - 🔍 回到Primary Level重新理解基础概念
        451 -  - 🎯 专注于"是什么"和"为什么"，而不是复杂的"怎么做"
        452 -  - 💬 找学习伙伴讨论，或在论坛提问
        453 -  - 📚 查看不同的资料，可能某个解释更适合你
        454 -  
        455 -  ---
        456 -  
        457 -  # 🎯 1.2 主力集合：HashMap & ConcurrentHashMap 源码剖析
        458 -  
        459 -  ## Phase 5: HashMap基础原理 (25分钟总计)
        460 -  
        461 -  #### Task 1.2.1: HashMap基本结构理解 (5分钟) ⏰
        462 -  
        463 -  **🎯 Primary Level (新手友好)**
        464 -  - [ ] **什么是HashMap**: 想象一个图书馆，书按照编号放在不同书架(数组)上
        465 -  - [ ] **基本结构**: 数组存储"书架"，每个书架可能有多本书(链表)
        466 -  - [ ] **生活类比**: 就像学校班级(数组) + 每班学生名单(链表)
        467 -  - [ ] **检查点**: 能说出"HashMap用什么数据结构存储数据"
        468 -  - [ ] **文件**: 创建`student_progress/hashmap_notes.md`，用图画出结构
        469 -  
        470 -  **🚀 Intermediate Level (实践验证)**  
        471 -  - [ ] **技术细节**: 理解Node数组 + 链表 + 红黑树的混合结构
        472 -  - [ ] **优化原理**: JDK1.8为什么要引入红黑树(解决链表过长问题)
        473 -  - [ ] **检查点**: 能画出完整的HashMap内部结构图
        474 -  
        475 -  **🏆 Senior Level (架构思维)**
        476 -  - [ ] **设计权衡**: 数组 vs 链表 vs 红黑树的查找性能对比
        477 -  - [ ] **阈值设计**: TREEIFY_THRESHOLD=8的统计学考虑
        478 -  - [ ] **面试深度**: 能分析HashMap设计选择的trade-off
        479 -  
        480 -  #### Task 1.2.2: hash函数和索引计算 (5分钟) ⏰
        481 -  - [ ] **学习目标**: 理解hashCode()到数组索引的转换
        482 -  - [ ] **具体任务**: 学习`(n-1) & hash`的位运算技巧
        483 -  - [ ] **检查点**: 能解释为什么容量必须是2的幂次方
        484 -  - [ ] **文件**: 在`hashmap_notes.md`中添加hash计算部分
        485 -  
        486 -  #### Task 1.2.3: JDK1.7 vs 1.8差异 (5分钟) ⏰
        487 -  - [ ] **学习目标**: 理解链表到红黑树的优化
        488 -  - [ ] **具体任务**: 学习TREEIFY_THRESHOLD=8的设计原理
        489 -  - [ ] **检查点**: 能解释为什么选择8作为阈值
        490 -  - [ ] **文件**: 继续完善`hashmap_notes.md`
        491 -  
        492 -  #### Task 1.2.4: put方法流程分析 (5分钟) ⏰
        493 -  - [ ] **学习目标**: 理解HashMap插入元素的完整流程
        494 -  - [ ] **具体任务**: 梳理hash计算→定位→插入→扩容的流程
        495 -  - [ ] **检查点**: 能完整描述put方法的执行步骤
        496 -  - [ ] **文件**: 添加put流程图到notes中
        497 -  
        498 -  #### Task 1.2.5: 扩容机制深入 (5分钟) ⏰
        499 -  - [ ] **学习目标**: 理解resize()方法和rehash过程
        500 -  - [ ] **具体任务**: 学习负载因子0.75的设计考虑
        501 -  - [ ] **检查点**: 能解释扩容时元素重新分布的规律
        502 -  - [ ] **文件**: 完善扩容机制说明
        503 -  
        504 -  ## Phase 6: ConcurrentHashMap并发控制 (25分钟总计)
        505 -  
        506 -  #### Task 1.2.6: JDK1.7分段锁机制 (5分钟) ⏰
        507 -  - [ ] **学习目标**: 理解Segment数组的设计思想
        508 -  - [ ] **具体任务**: 学习分段锁如何降低锁竞争
        509 -  - [ ] **检查点**: 能解释为什么并发度等于Segment数量
        510 -  - [ ] **文件**: 创建`student_progress/concurrenthashmap_notes.md`
        511 -  
        512 -  #### Task 1.2.7: JDK1.8优化策略 (5分钟) ⏰
        513 -  - [ ] **学习目标**: 理解CAS+synchronized的新方案
        514 -  - [ ] **具体任务**: 学习锁粒度从Segment缩小到Node头节点
        515 -  - [ ] **检查点**: 能对比1.7和1.8的并发性能差异
        516 -  - [ ] **文件**: 在notes中添加1.8优化部分
        517 -  
        518 -  #### Task 1.2.8: get操作的无锁设计 (5分钟) ⏰
        519 -  - [ ] **学习目标**: 理解读操作如何实现近似无锁
        520 -  - [ ] **具体任务**: 学习volatile保证可见性的机制
        521 -  - [ ] **检查点**: 能解释为什么get方法几乎不需要加锁
        522 -  - [ ] **文件**: 添加get操作分析
        523 -  
        524 -  #### Task 1.2.9: CAS操作原理 (5分钟) ⏰
        525 -  - [ ] **学习目标**: 理解Compare-And-Swap的无锁算法
        526 -  - [ ] **具体任务**: 学习CAS的ABA问题和解决方案
        527 -  - [ ] **检查点**: 能解释CAS在ConcurrentHashMap中的应用
        528 -  - [ ] **文件**: 添加CAS原理说明
        529 -  
        530 -  #### Task 1.2.10: 计数器CounterCell设计 (5分钟) ⏰
        531 -  - [ ] **学习目标**: 理解size()方法在并发环境下的挑战
        532 -  - [ ] **具体任务**: 学习分段计数的设计思想
        533 -  - [ ] **检查点**: 能解释为什么不直接用AtomicLong
        534 -  - [ ] **文件**: 完善并发控制机制说明
        535 -  
        536 -  ## Phase 7: 手写HashMap实现 (30分钟总计)
        537 -  
        538 -  #### Task 1.2.11: 手写HashMap核心实现 (5分钟) ⏰
        539 -  - [ ] **学习目标**: 从零实现HashMap的核心数据结构和算法
        540 -  - [ ] **具体任务**: 
        541 -    ```java
        542 -    public class MyHashMap<K, V> {
        543 -        // 练习1：设计Node节点结构
        544 -        static class Node<K, V> {
        545 -            final int hash;
        546 -            final K key;
        547 -            V value;
        548 -            Node<K, V> next;
        549 -            
        550 -            Node(int hash, K key, V value, Node<K, V> next) {
        551 -                // TODO: 学生实现构造方法
        552 -            }
        553 -        }
        554 -        
        555 -        private Node<K, V>[] table;
        556 -        private int size = 0;
        557 -        private static final int DEFAULT_CAPACITY = 16;
        558 -        private static final float LOAD_FACTOR = 0.75f;
        559 -        
        560 -        // 练习2：实现高效的hash函数
        561 -        private int hash(K key) {
        562 -            if (key == null) return 0;
        563 -            int h = key.hashCode();
        564 -            // TODO: 为什么要进行扰动函数？ h ^ (h >>> 16)
        565 -            return h ^ (h >>> 16);
        566 -        }
        567 -        
        568 -        // 练习3：实现索引计算
        569 -        private int indexFor(int hash, int length) {
        570 -            // TODO: 为什么用 (length-1) & hash 而不是 hash % length？
        571 -            // 学生需要理解位运算的性能优势
        572 -            return hash & (length - 1);
        573 -        }
        574 -        
        575 -        // 练习4：实现核心put方法
        576 -        public V put(K key, V value) {
        577 -            // TODO: 实现完整的put逻辑
        578 -            // 1. 计算hash值
        579 -            // 2. 找到对应bucket
        580 -            // 3. 处理hash冲突（链表插入）
        581 -            // 4. 检查是否需要扩容
        582 -            return null;
        583 -        }
        584 -    }
        585 -    ```
        586 -  - [ ] **检查点**: 理解为什么容量必须是2的幂次方，扰动函数的作用
        587 -  - [ ] **编程练习**: 测试不同hash函数的分布均匀性
        588 -  - [ ] **文件**: `student_progress/MyHashMap.java`
        589 -  
        590 -  #### Task 1.2.12: 实现hash函数 (5分钟) ⏰
        591 -  - [ ] **学习目标**: 实现高效的hash计算方法
        592 -  - [ ] **具体任务**: 实现hash()和indexFor()方法
        593 -  - [ ] **检查点**: hash分布均匀，索引计算正确
        594 -  - [ ] **文件**: 完善`MyHashMap.java`
        595 -  
        596 -  #### Task 1.2.13: 实现put方法 (5分钟) ⏰
        597 -  - [ ] **学习目标**: 实现元素插入逻辑
        598 -  - [ ] **具体任务**: 处理hash冲突和链表插入
        599 -  - [ ] **检查点**: 能正确插入键值对
        600 -  - [ ] **文件**: 继续完善`MyHashMap.java`
        601 -  
        602 -  #### Task 1.2.14: 实现get方法 (5分钟) ⏰
        603 -  - [ ] **学习目标**: 实现元素查找逻辑
        604 -  - [ ] **具体任务**: 遍历链表查找目标key
        605 -  - [ ] **检查点**: 能正确获取对应的value
        606 -  - [ ] **文件**: 继续完善`MyHashMap.java`
        607 -  
        608 -  #### Task 1.2.15: 实现扩容机制 (5分钟) ⏰
        609 -  - [ ] **学习目标**: 实现动态扩容和rehash
        610 -  - [ ] **具体任务**: 当负载因子超过阈值时自动扩容
        611 -  - [ ] **检查点**: 扩容后数据完整性保持
        612 -  - [ ] **文件**: 完善`MyHashMap.java`
        613 -  
        614 -  #### Task 1.2.16: 测试和优化 (5分钟) ⏰
        615 -  - [ ] **学习目标**: 验证实现的正确性
        616 -  - [ ] **具体任务**: 编写测试用例，对比性能
        617 -  - [ ] **检查点**: 与JDK HashMap行为一致
        618 -  - [ ] **文件**: 创建`student_progress/HashMapTest.java`
        619 -  
        620 -  ## Phase 8: 并发安全对比测试 (20分钟总计)
        621 -  
        622 -  #### Task 1.2.17: 创建并发测试框架 (5分钟) ⏰
        623 -  - [ ] **学习目标**: 搭建多线程测试环境
        624 -  - [ ] **具体任务**: 创建多线程同时操作Map的测试
        625 -  - [ ] **检查点**: 能模拟高并发场景
        626 -  - [ ] **文件**: `student_progress/ConcurrencyTest.java`
        627 -  
        628 -  #### Task 1.2.18: HashMap并发安全性实战验证 (5分钟) ⏰
        629 -  - [ ] **学习目标**: 观察HashMap在并发环境下的问题和ConcurrentHashMap的解决方案
        630 -  - [ ] **具体任务**: 
        631 -    ```java
        632 -    public class ConcurrentMapTest {
        633 -        private static final int THREAD_COUNT = 10;
        634 -        private static final int OPERATIONS_PER_THREAD = 1000;
        635 -        
        636 -        // 练习1：HashMap并发问题重现
        637 -        public static void testHashMapConcurrency() throws InterruptedException {
        638 -            Map<Integer, Integer> map = new HashMap<>();
        639 -            CountDownLatch latch = new CountDownLatch(THREAD_COUNT);
        640 -            
        641 -            for (int i = 0; i < THREAD_COUNT; i++) {
        642 -                final int threadId = i;
        643 -                new Thread(() -> {
        644 -                    try {
        645 -                        for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
        646 -                            map.put(threadId * OPERATIONS_PER_THREAD + j, j);
        647 -                        }
        648 -                    } finally {
        649 -                        latch.countDown();
        650 -                    }
        651 -                }).start();
        652 -            }
        653 -            
        654 -            latch.await();
        655 -            System.out.println("HashMap 期望大小: " + (THREAD_COUNT * OPERATIONS_PER_THREAD));
        656 -            System.out.println("HashMap 实际大小: " + map.size());
        657 -            // 观察数据丢失问题
        658 -        }
        659 -        
        660 -        // 练习2：ConcurrentHashMap安全性验证
        661 -        public static void testConcurrentHashMapSafety() throws InterruptedException {
        662 -            Map<Integer, Integer> map = new ConcurrentHashMap<>();
        663 -            CountDownLatch latch = new CountDownLatch(THREAD_COUNT);
        664 -            
        665 -            long startTime = System.currentTimeMillis();
        666 -            
        667 -            for (int i = 0; i < THREAD_COUNT; i++) {
        668 -                final int threadId = i;
        669 -                new Thread(() -> {
        670 -                    try {
        671 -                        for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
        672 -                            map.put(threadId * OPERATIONS_PER_THREAD + j, j);
        673 -                            // 模拟读操作
        674 -                            map.get(threadId * OPERATIONS_PER_THREAD + j);
        675 -                        }
        676 -                    } finally {
        677 -                        latch.countDown();
        678 -                    }
        679 -                }).start();
        680 -            }
        681 -            
        682 -            latch.await();
        683 -            long endTime = System.currentTimeMillis();
        684 -            
        685 -            System.out.println("ConcurrentHashMap 期望大小: " + (THREAD_COUNT * 
            - OPERATIONS_PER_THREAD));
        686 -            System.out.println("ConcurrentHashMap 实际大小: " + map.size());
        687 -            System.out.println("执行时间: " + (endTime - startTime) + "ms");
        688 -        }
        689 -        
        690 -        // 练习3：性能对比测试
        691 -        public static void performanceComparison() throws InterruptedException {
        692 -            System.out.println("=== HashMap并发测试 ===");
        693 -            testHashMapConcurrency();
        694 -            
        695 -            System.out.println("\n=== ConcurrentHashMap并发测试 ===");
        696 -            testConcurrentHashMapSafety();
        697 -        }
        698 -    }
        699 -    ```
        700 -  - [ ] **检查点**: 观察HashMap的数据丢失，ConcurrentHashMap的数据完整性
        701 -  - [ ] **编程练习**: 尝试重现HashMap的死循环问题（需要特定JDK版本和条件）
        702 -  - [ ] **文件**: 完善`student_progress/ConcurrentMapTest.java`
        703 -  
        704 -  #### Task 1.2.19: ConcurrentHashMap安全性验证 (5分钟) ⏰
        705 -  - [ ] **学习目标**: 验证ConcurrentHashMap的线程安全性
        706 -  - [ ] **具体任务**: 相同条件下测试ConcurrentHashMap
        707 -  - [ ] **检查点**: 观察到数据一致性和性能优势
        708 -  - [ ] **文件**: 继续完善测试代码
        709 -  
        710 -  #### Task 1.2.20: 性能基准测试 (5分钟) ⏰
        711 -  - [ ] **学习目标**: 对比不同Map在并发场景下的性能
        712 -  - [ ] **具体任务**: 测试读写操作的吞吐量
        713 -  - [ ] **检查点**: 理解不同实现的性能特点
        714 -  - [ ] **文件**: 添加性能测试结果
        715 -  
        716 -  ## Phase 9: 面试题实战训练 (15分钟总计)
        717 -  
        718 -  #### Task 1.2.21: 经典问题准备 (5分钟) ⏰
        719 -  - [ ] **学习目标**: 准备HashMap核心面试问题
        720 -  - [ ] **具体任务**: 整理容量2的幂次方、扩容机制等问题
        721 -  - [ ] **检查点**: 能从底层原理解释设计决策
        722 -  - [ ] **文件**: 更新`student_progress/interview_qa.md`
        723 -  
        724 -  #### Task 1.2.22: 白板编程练习 (5分钟) ⏰
        725 -  - [ ] **学习目标**: 练习手写HashMap关键方法
        726 -  - [ ] **具体任务**: 在纸上写出put方法的伪代码
        727 -  - [ ] **检查点**: 逻辑清晰，考虑边界情况
        728 -  - [ ] **文件**: 拍照上传手写代码到progress文件夹
        729 -  
        730 -  #### Task 1.2.23: 追问题深度回答 (5分钟) ⏰
        731 -  - [ ] **学习目标**: 准备深度技术问题
        732 -  - [ ] **具体任务**: 准备红黑树、一致性hash等进阶问题
        733 -  - [ ] **检查点**: 能扩展到分布式系统设计
        734 -  - [ ] **文件**: 完善面试问答集
        735 -  
        736 -  ---
        737 -  
        738 -  # 🎯 1.3 现代范式：Kotlin 协程
        739 -  
        740 -  ## Phase 10: 协程基础理念 (25分钟总计)
        741 -  
        742 -  #### Task 1.3.1: 协程vs线程对比 (5分钟) ⏰
        743 -  - [ ] **学习目标**: 理解协程的轻量级特性
        744 -  - [ ] **具体任务**: 学习用户态vs内核态的区别
        745 -  - [ ] **检查点**: 能解释为什么协程比线程轻量
        746 -  - [ ] **文件**: 创建`student_progress/coroutine_notes.md`
        747 -  
        748 -  #### Task 1.3.2: 挂起vs阻塞概念 (5分钟) ⏰
        749 -  - [ ] **学习目标**: 理解suspend的核心思想
        750 -  - [ ] **具体任务**: 学习协程如何让出线程执行权
        751 -  - [ ] **检查点**: 能区分suspend和block的本质差异
        752 -  - [ ] **文件**: 在notes中添加挂起机制说明
        753 -  
        754 -  #### Task 1.3.3: 结构化并发原理 (5分钟) ⏰
        755 -  - [ ] **学习目标**: 理解CoroutineScope的生命周期管理
        756 -  - [ ] **具体任务**: 学习父子协程的取消传播机制
        757 -  - [ ] **检查点**: 能解释如何避免协程泄漏
        758 -  - [ ] **文件**: 添加结构化并发部分
        759 -  
        760 -  #### Task 1.3.4: CoroutineContext组成 (5分钟) ⏰
        761 -  - [ ] **学习目标**: 理解协程上下文的构成要素
        762 -  - [ ] **具体任务**: 学习Job、Dispatcher、CoroutineName等组件
        763 -  - [ ] **检查点**: 能解释上下文继承和覆盖规则
        764 -  - [ ] **文件**: 添加Context说明
        765 -  
        766 -  #### Task 1.3.5: Dispatchers调度器详解 (5分钟) ⏰
        767 -  - [ ] **学习目标**: 理解不同调度器的适用场景
        768 -  - [ ] **具体任务**: 学习Main、IO、Default、Unconfined的区别
        769 -  - [ ] **检查点**: 能为不同任务选择合适的调度器
        770 -  - [ ] **文件**: 完善调度器说明
        771 -  
        772 -  ## Phase 11: 协程核心API实践 (30分钟总计)
        773 -  
        774 -  #### Task 1.3.6: 协程基础API实战练习 (5分钟) ⏰
        775 -  - [ ] **学习目标**: 掌握launch、async、runBlocking的使用场景和区别
        776 -  - [ ] **具体任务**: 
        777 -    ```kotlin
        778 -    class CoroutineBasicsLab {
        779 -        
        780 -        // 练习1：对比阻塞vs非阻塞调用
        781 -        fun compareBlockingVsSuspend() {
        782 -            // TODO: 先实现传统回调方式的网络请求
        783 -            fun fetchUserCallback(userId: String, callback: (User?) -> Unit) {
        784 -                Thread {
        785 -                    Thread.sleep(1000) // 模拟网络延迟
        786 -                    callback(User(userId, "张三"))
        787 -                }.start()
        788 -            }
        789 -            
        790 -            // TODO: 改写为suspend函数，体验简洁性
        791 -            suspend fun fetchUserSuspend(userId: String): User? {
        792 -                return withContext(Dispatchers.IO) {
        793 -                    delay(1000) // 非阻塞延迟
        794 -                    User(userId, "张三")
        795 -                }
        796 -            }
        797 -            
        798 -            // 对比两种方式的代码复杂度
        799 -        }
        800 -        
        801 -        // 练习2：launch vs async的选择决策
        802 -        fun practiceJobTypes() = runBlocking {
        803 -            println("=== Launch vs Async 对比 ===")
        804 -            
        805 -            // 场景1：发射后不管 - 使用launch
        806 -            val job = launch {
        807 -                repeat(3) {
        808 -                    delay(500)
        809 -                    println("后台任务执行中... $it")
        810 -                }
        811 -            }
        812 -            
        813 -            // 场景2：需要返回值 - 使用async
        814 -            val deferred1 = async {
        815 -                delay(1000)
        816 -                "数据源1的结果"
        817 -            }
        818 -            
        819 -            val deferred2 = async {
        820 -                delay(1500)
        821 -                "数据源2的结果"
        822 -            }
        823 -            
        824 -            // 等待并获取结果
        825 -            val result1 = deferred1.await()
        826 -            val result2 = deferred2.await()
        827 -            
        828 -            println("合并结果: $result1 + $result2")
        829 -            job.join() // 等待后台任务完成
        830 -        }
        831 -        
        832 -        // 练习3：并发vs串行执行对比
        833 -        suspend fun concurrentVsSequential() {
        834 -            // 串行执行
        835 -            val sequentialTime = measureTimeMillis {
        836 -                val result1 = fetchData("数据1") // 1秒
        837 -                val result2 = fetchData("数据2") // 1秒  
        838 -                println("串行结果: $result1, $result2")
        839 -            }
        840 -            
        841 -            // 并发执行
        842 -            val concurrentTime = measureTimeMillis {
        843 -                val deferred1 = async { fetchData("数据1") }
        844 -                val deferred2 = async { fetchData("数据2") }
        845 -                val result1 = deferred1.await()
        846 -                val result2 = deferred2.await()
        847 -                println("并发结果: $result1, $result2")
        848 -            }
        849 -            
        850 -            println("串行耗时: ${sequentialTime}ms")
        851 -            println("并发耗时: ${concurrentTime}ms")
        852 -        }
        853 -        
        854 -        private suspend fun fetchData(name: String): String {
        855 -            delay(1000)
        856 -            return "${name}的结果"
        857 -        }
        858 -    }
        859 -    
        860 -    data class User(val id: String, val name: String)
        861 -    ```
        862 -  - [ ] **检查点**: 理解launch适合"发射后不管"，async适合"需要返回值"
        863 -  - [ ] **编程练习**: 对比串行vs并发执行的性能差异
        864 -  - [ ] **文件**: `student_progress/CoroutineBasicsLab.kt`
        865 -  
        866 -  #### Task 1.3.7: runBlocking使用场景 (5分钟) ⏰
        867 -  - [ ] **学习目标**: 理解阻塞式协程的适用性
        868 -  - [ ] **具体任务**: 在main函数和测试中使用runBlocking
        869 -  - [ ] **检查点**: 理解为什么生产代码要避免runBlocking
        870 -  - [ ] **文件**: 完善`CoroutineBasics.kt`
        871 -  
        872 -  #### Task 1.3.8: 线程切换实战演练 (5分钟) ⏰
        873 -  - [ ] **学习目标**: 掌握withContext进行线程切换的实际应用
        874 -  - [ ] **具体任务**: 
        875 -    ```kotlin
        876 -    class ThreadSwitchingPractice {
        877 -        
        878 -        // 练习：模拟真实的Android开发场景
        879 -        suspend fun realWorldNetworkCall() {
        880 -            println("开始执行 - 线程: ${Thread.currentThread().name}")
        881 -            
        882 -            // 第一步：网络线程获取数据
        883 -            val userData = withContext(Dispatchers.IO) {
        884 -                println("网络请求 - 线程: ${Thread.currentThread().name}")
        885 -                delay(1000) // 模拟网络延迟
        886 -                "User Data from Network"
        887 -            }
        888 -            
        889 -            // 第二步：计算线程处理数据
        890 -            val processedData = withContext(Dispatchers.Default) {
        891 -                println("数据处理 - 线程: ${Thread.currentThread().name}")
        892 -                // 模拟CPU密集计算
        893 -                Thread.sleep(500) // 阻塞当前线程
        894 -                userData.uppercase().reversed()
        895 -            }
        896 -            
        897 -            // 第三步：主线程更新UI
        898 -            withContext(Dispatchers.Main) {
        899 -                println("UI更新 - 线程: ${Thread.currentThread().name}")
        900 -                // 模拟TextView更新
        901 -                println("UI Updated: $processedData")
        902 -            }
        903 -            
        904 -            println("完成执行 - 线程: ${Thread.currentThread().name}")
        905 -        }
        906 -        
        907 -        // 高级练习：错误处理和取消传播
        908 -        suspend fun advancedErrorHandling() {
        909 -            val job = CoroutineScope(Dispatchers.IO).launch {
        910 -                try {
        911 -                    // 模拟可取消的长时间操作
        912 -                    repeat(10) { i ->
        913 -                        if (!isActive) { // 检查协程是否被取消
        914 -                            println("协程被取消，停止执行")
        915 -                            return@launch
        916 -                        }
        917 -                        
        918 -                        println("执行步骤 $i")
        919 -                        delay(500)
        920 -                    }
        921 -                } catch (e: CancellationException) {
        922 -                    println("捕获取消异常: ${e.message}")
        923 -                    // 清理资源
        924 -                    withContext(NonCancellable) {
        925 -                        println("执行清理工作")
        926 -                        delay(200) // 确保清理完成
        927 -                    }
        928 -                    throw e // 重新抛出取消异常
        929 -                } catch (e: Exception) {
        930 -                    println("捕获其他异常: ${e.message}")
        931 -                }
        932 -            }
        933 -            
        934 -            delay(2000) // 让协程运行2秒
        935 -            job.cancel("用户取消操作") // 取消协程
        936 -            job.join() // 等待协程完成清理
        937 -        }
        938 -        
        939 -        // 练习：协程作用域管理
        940 -        class ViewModelSimulation {
        941 -            private val viewModelScope = CoroutineScope(
        942 -                SupervisorJob() + Dispatchers.Main
        943 -            )
        944 -            
        945 -            fun loadUserData(userId: String) {
        946 -                viewModelScope.launch {
        947 -                    try {
        948 -                        val userData = withContext(Dispatchers.IO) {
        949 -                            // 模拟网络请求
        950 -                            delay(1000)
        951 -                            if (userId == "error") {
        952 -                                throw RuntimeException("网络错误")
        953 -                            }
        954 -                            "用户数据: $userId"
        955 -                        }
        956 -                        
        957 -                        // 更新UI（主线程）
        958 -                        updateUI(userData)
        959 -                    } catch (e: Exception) {
        960 -                        handleError(e)
        961 -                    }
        962 -                }
        963 -            }
        964 -            
        965 -            private fun updateUI(data: String) {
        966 -                println("UI更新: $data - 线程: ${Thread.currentThread().name}")
        967 -            }
        968 -            
        969 -            private fun handleError(error: Exception) {
        970 -                println("错误处理: ${error.message}")
        971 -            }
        972 -            
        973 -            fun onDestroy() {
        974 -                viewModelScope.cancel() // 清理所有协程
        975 -            }
        976 -        }
        977 -    }
        978 -    ```
        979 -  - [ ] **检查点**: 观察每步操作在不同线程上执行，理解线程切换的开销
        980 -  - [ ] **编程练习**: 实现一个完整的网络请求→数据处理→UI更新的流程
        981 -  - [ ] **文件**: 创建`student_progress/ThreadSwitchingPractice.kt`
        982 -  
        983 -  #### Task 1.3.9: 协程取消机制 (5分钟) ⏰
        984 -  - [ ] **学习目标**: 理解协程的取消和异常处理
        985 -  - [ ] **具体任务**: 实现可取消的长时间运行任务
        986 -  - [ ] **检查点**: 能正确响应取消信号
        987 -  - [ ] **文件**: 创建`student_progress/CancellationDemo.kt`
        988 -  
        989 -  #### Task 1.3.10: suspend函数编写 (5分钟) ⏰
        990 -  - [ ] **学习目标**: 创建自定义的挂起函数
        991 -  - [ ] **具体任务**: 包装回调式API为suspend函数
        992 -  - [ ] **检查点**: 理解suspend的传染性
        993 -  - [ ] **文件**: 创建`student_progress/SuspendFunctions.kt`
        994 -  
        995 -  #### Task 1.3.11: 异常处理策略 (5分钟) ⏰
        996 -  - [ ] **学习目标**: 理解协程中的异常传播
        997 -  - [ ] **具体任务**: 使用try-catch和CoroutineExceptionHandler
        998 -  - [ ] **检查点**: 能处理结构化并发中的异常
        999 -  - [ ] **文件**: 创建`student_progress/ExceptionHandling.kt`
       1000 -  
       1001 -  ## Phase 12: 实际应用场景练习 (25分钟总计)
       1002 -  
       1003 -  #### Task 1.3.12: 网络请求对比实现 (5分钟) ⏰
       1004 -  - [ ] **学习目标**: 对比回调vs协程的代码可读性
       1005 -  - [ ] **具体任务**: 同一个网络请求用两种方式实现
       1006 -  - [ ] **检查点**: 体验协程消除回调地狱的优势
       1007 -  - [ ] **文件**: `student_progress/NetworkComparison.kt`
       1008 -  
       1009 -  #### Task 1.3.13: 并发网络请求 (5分钟) ⏰
       1010 -  - [ ] **学习目标**: 实现多个请求的并发执行
       1011 -  - [ ] **具体任务**: 使用async+awaitAll并发获取数据
       1012 -  - [ ] **检查点**: 理解并发vs并行的区别
       1013 -  - [ ] **文件**: 完善`NetworkComparison.kt`
       1014 -  
       1015 -  #### Task 1.3.14: Flow响应式编程实践 (5分钟) ⏰
       1016 -  - [ ] **学习目标**: 掌握Flow的响应式数据流编程
       1017 -  - [ ] **具体任务**: 
       1018 -    ```kotlin
       1019 -    class FlowPracticalExercises {
       1020 -        
       1021 -        // 练习1：构建实时数据流
       1022 -        fun createRealtimeDataStream(): Flow<String> = flow {
       1023 -            println("Flow开始发射数据")
       1024 -            repeat(5) { i ->
       1025 -                delay(500) // 模拟数据到达间隔
       1026 -                emit("实时数据 $i 来自线程: ${Thread.currentThread().name}")
       1027 -            }
       1028 -            println("Flow发射完成")
       1029 -        }
       1030 -        
       1031 -        // 练习2：流的变换和处理
       1032 -        suspend fun practiceFlowTransformations() {
       1033 -            println("=== Flow变换操作演示 ===")
       1034 -            
       1035 -            createRealtimeDataStream()
       1036 -                .map { data ->
       1037 -                    println("转换: $data")
       1038 -                    data.uppercase() // 转换为大写
       1039 -                }
       1040 -                .filter { data ->
       1041 -                    val shouldKeep = data.contains("2") || data.contains("4")
       1042 -                    println("过滤: $data -> ${if (shouldKeep) "保留" else "丢弃"}")
       1043 -                    shouldKeep
       1044 -                }
       1045 -                .collect { processedData ->
       1046 -                    println("消费: $processedData")
       1047 -                }
       1048 -        }
       1049 -        
       1050 -        // 练习3：冷流vs热流对比
       1051 -        suspend fun coldVsHotFlowDemo() {
       1052 -            println("=== 冷流演示 ===")
       1053 -            val coldFlow = flow {
       1054 -                println("冷流：开始执行")
       1055 -                repeat(3) {
       1056 -                    emit(it)
       1057 -                    delay(300)
       1058 -                }
       1059 -            }
       1060 -            
       1061 -            // 每次collect都会重新执行flow代码块
       1062 -            println("第一个收集者:")
       1063 -            coldFlow.collect { println("收集到: $it") }
       1064 -            
       1065 -            println("第二个收集者:")
       1066 -            coldFlow.collect { println("收集到: $it") }
       1067 -            
       1068 -            println("\n=== 热流演示 ===")
       1069 -            val hotFlow = MutableSharedFlow<Int>()
       1070 -            
       1071 -            // 启动发射者
       1072 -            launch {
       1073 -                repeat(3) {
       1074 -                    hotFlow.emit(it)
       1075 -                    delay(300)
       1076 -                }
       1077 -            }
       1078 -            
       1079 -            delay(100) // 稍微延迟
       1080 -            println("第一个收集者:")
       1081 -            launch {
       1082 -                hotFlow.collect { println("收集者1: $it") }
       1083 -            }
       1084 -            
       1085 -            delay(500) // 延迟更久
       1086 -            println("第二个收集者:")
       1087 -            launch {
       1088 -                hotFlow.collect { println("收集者2: $it") }
       1089 -            }
       1090 -            
       1091 -            delay(1000) // 等待完成
       1092 -        }
       1093 -        
       1094 -        // 练习4：StateFlow状态管理
       1095 -        class ViewModelSimulation {
       1096 -            private val _uiState = MutableStateFlow("初始状态")
       1097 -            val uiState: StateFlow<String> = _uiState.asStateFlow()
       1098 -            
       1099 -            private val _userInfo = MutableStateFlow<User?>(null)
       1100 -            val userInfo: StateFlow<User?> = _userInfo.asStateFlow()
       1101 -            
       1102 -            fun updateState(newState: String) {
       1103 -                println("状态更新: ${_uiState.value} -> $newState")
       1104 -                _uiState.value = newState
       1105 -            }
       1106 -            
       1107 -            suspend fun loadUser(userId: String) {
       1108 -                _uiState.value = "加载中..."
       1109 -                
       1110 -                try {
       1111 -                    delay(1000) // 模拟网络请求
       1112 -                    val user = User(userId, "用户$userId")
       1113 -                    _userInfo.value = user
       1114 -                    _uiState.value = "加载完成"
       1115 -                } catch (e: Exception) {
       1116 -                    _uiState.value = "加载失败: ${e.message}"
       1117 -                }
       1118 -            }
       1119 -            
       1120 -            // 组合多个状态流
       1121 -            val combinedState: Flow<String> = combine(uiState, userInfo) { state, user ->
       1122 -                when {
       1123 -                    user == null -> state
       1124 -                    else -> "$state - 当前用户: ${user.name}"
       1125 -                }
       1126 -            }
       1127 -        }
       1128 -        
       1129 -        // 练习5：Flow异常处理
       1130 -        suspend fun flowErrorHandling() {
       1131 -            flow {
       1132 -                repeat(5) { i ->
       1133 -                    if (i == 3) {
       1134 -                        throw RuntimeException("模拟网络错误")
       1135 -                    }
       1136 -                    emit(i)
       1137 -                }
       1138 -            }
       1139 -            .catch { e ->
       1140 -                println("捕获异常: ${e.message}")
       1141 -                emit(-1) // 发射默认值
       1142 -            }
       1143 -            .collect { value ->
       1144 -                println("接收到值: $value")
       1145 -            }
       1146 -        }
       1147 -    }
       1148 -    ```
       1149 -  - [ ] **检查点**: 理解冷流vs热流的区别，StateFlow的状态管理特性
       1150 -  - [ ] **编程练习**: 实现一个包含状态管理和错误处理的完整数据流
       1151 -  - [ ] **文件**: `student_progress/FlowPracticalExercises.kt`
       1152 -  
       1153 -  #### Task 1.3.15: StateFlow和SharedFlow (5分钟) ⏰
       1154 -  - [ ] **学习目标**: 理解状态流和事件流的区别
       1155 -  - [ ] **具体任务**: 实现MVVM模式中的状态管理
       1156 -  - [ ] **检查点**: 理解热流vs冷流的概念
       1157 -  - [ ] **文件**: 创建`student_progress/StateManagement.kt`
       1158 -  
       1159 -  #### Task 1.3.16: 协程测试编写 (5分钟) ⏰
       1160 -  - [ ] **学习目标**: 学会测试协程代码
       1161 -  - [ ] **具体任务**: 使用TestCoroutineDispatcher编写单元测试
       1162 -  - [ ] **检查点**: 能控制测试中的时间流逝
       1163 -  - [ ] **文件**: `student_progress/CoroutineTest.kt`
       1164 -  
       1165 -  ## Phase 13: 底层原理探索 (20分钟总计)
       1166 -  
       1167 -  #### Task 1.3.17: suspend关键字原理 (5分钟) ⏰
       1168 -  - [ ] **学习目标**: 理解编译器如何处理suspend
       1169 -  - [ ] **具体任务**: 查看反编译后的状态机代码
       1170 -  - [ ] **检查点**: 理解CPS(Continuation Passing Style)变换
       1171 -  - [ ] **文件**: 在notes中添加编译原理说明
       1172 -  
       1173 -  #### Task 1.3.18: Continuation接口分析 (5分钟) ⏰
       1174 -  - [ ] **学习目标**: 理解协程的底层实现机制
       1175 -  - [ ] **具体任务**: 分析Continuation的resumeWith方法
       1176 -  - [ ] **检查点**: 理解协程如何实现挂起和恢复
       1177 -  - [ ] **文件**: 添加Continuation原理说明
       1178 -  
       1179 -  #### Task 1.3.19: 协程调度原理 (5分钟) ⏰
       1180 -  - [ ] **学习目标**: 理解协程如何被调度执行
       1181 -  - [ ] **具体任务**: 分析EventLoop和线程池的配合
       1182 -  - [ ] **检查点**: 理解协程并不绑定线程的原理
       1183 -  - [ ] **文件**: 添加调度机制说明
       1184 -  
       1185 -  #### Task 1.3.20: 性能特点分析 (5分钟) ⏰
       1186 -  - [ ] **学习目标**: 理解协程的性能优势和局限性
       1187 -  - [ ] **具体任务**: 对比协程vs线程的创建销毁开销
       1188 -  - [ ] **检查点**: 理解协程适用的场景边界
       1189 -  - [ ] **文件**: 完善性能分析
       1190 -  
       1191 -  ## Phase 14: 协程面试准备 (15分钟总计)
       1192 -  
       1193 -  #### Task 1.3.21: 核心概念问答 (5分钟) ⏰
       1194 -  - [ ] **学习目标**: 准备协程基础概念问题
       1195 -  - [ ] **具体任务**: 整理协程vs线程、挂起机制等答案
       1196 -  - [ ] **检查点**: 能清晰解释协程的核心优势
       1197 -  - [ ] **文件**: 更新`interview_qa.md`
       1198 -  
       1199 -  #### Task 1.3.22: 实际应用问题 (5分钟) ⏰
       1200 -  - [ ] **学习目标**: 准备协程在Android中的应用
       1201 -  - [ ] **具体任务**: 整理viewModelScope、lifecycleScope等问题
       1202 -  - [ ] **检查点**: 能结合Android生命周期解释协程使用
       1203 -  - [ ] **文件**: 添加Android相关问答
       1204 -  
       1205 -  #### Task 1.3.23: 深度技术问题 (5分钟) ⏰
       1206 -  - [ ] **学习目标**: 准备协程底层原理问题
       1207 -  - [ ] **具体任务**: 整理状态机、CPS变换等深度问题
       1208 -  - [ ] **检查点**: 能从编译器角度解释协程实现
       1209 -  - [ ] **文件**: 完善深度问答
       1210 -  
       1211 -  ## 🎯 第一章学习检查点汇总
       1212 -  
       1213 -  ### 1.1 并发原语检查问题:
       1214 -  1. "JMM的核心作用是什么？工作内存和主内存如何交互？"
       1215 -  2. "synchronized的锁升级过程体现了什么设计思想？"
       1216 -  3. "volatile不能保证原子性，那什么时候用它最合适？"
       1217 -  4. "能手写一个线程安全的单例模式吗？用synchronized和volatile两种方式。"
       1218 -  
       1219 -  ### 1.2 集合框架检查问题:
       1220 -  1. "为什么HashMap的容量必须是2的幂次方？能从位运算角度解释吗？"
       1221 -  2. "ConcurrentHashMap 1.8的get操作几乎无锁，它如何保证读到最新数据？"
       1222 -  3. "让你设计一个线程安全的缓存，你会怎么设计？"
       1223 -  4. "能在白板上画出HashMap的put流程吗？包括扩容场景。"
       1224 -  
       1225 -  ### 1.3 协程机制检查问题:
       1226 -  1. "协程的suspend关键字底层是如何实现的？"
       1227 -  2. "launch和async的使用场景有什么区别？"
       1228 -  3. "结构化并发如何解决传统异步编程的问题？"
       1229 -  4. "能用协程重写一个回调地狱的网络请求吗？"
       1230 -  
       1231 -  ## 🏆 第一章总进度跟踪
       1232 -  - **1.1 并发原语**: 0/16 tasks (预计完成时间: 1.5小时)
       1233 -  - **1.2 集合框架**: 0/13 tasks (预计完成时间: 1.2小时)  
       1234 -  - **1.3 协程机制**: 0/14 tasks (预计完成时间: 1.3小时)
       1235 -  - **第一章总计**: 0/43 tasks (预计完成时间: 4小时)
          1   \ No newline at end of file
          2 +  # 🌱 ADHD-Friendly Android 面试准备系统 (5分钟每个任务)
          3 +  
          4 +  > **💡 学习哲学**: 从初学者到资深工程师的渐进式成长路径  
          5 +  > **🎯 目标**: 每个概念都要做到真正理解，而不是死记硬背  
          6 +  > **🕐 节奏**: 5分钟专注 + 确认理解 + 逐步进阶
          7 +  > **🔥 新增**: 强制性手动编程 - **No Copy-Paste Policy**
          8 +  
          9 +  ## 🎯 当前学习: 第一章 1.1 并发原语：synchronized, volatile 与 JMM
         10 +  
         11 +  **学习方法说明**: 每个任务都包含 Primary(基础) → Intermediate(实践) → Senior(架构) 
            + 三个层次，确保你能从"知道"进展到"理解"再到"应用"。
         12 +  
         13 +  **🚨 强制性编程框架**: 
         14 +  - ✋ **严禁复制粘贴**: 所有代码必须手动输入，培养肌肉记忆
         15 +  - 🏃 **Learn by Doing**: 每个概念必须通过编程验证
         16 +  - 📊 **渐进复杂度**: 50行demo → 150行实现 → 300+行企业级系统
         17 +  
         18 +  ---
         19 +  
         20 +  ### 🌟 Level 1: Primary Foundation (基础打牢) - 20分钟
         21 +  
         22 +  #### Task 1.1.1: JMM概念入门 + 首个编程实验 (5分钟) ⏰
         23 +  
         24 +  **🎯 Primary Level (新手友好)**
         25 +  - [✅] **什么是JMM**: 想象你有一个笔记本(工作内存)和一个公共图书馆(主内存)
         26 +  - [✅] **简单理解**: JMM就是Java定义的"多个程序员如何共享数据"的规则
         27 +  - [✅] **生活类比**: 就像办公室里多人共用一台打印机，需要排队规则一样
         28 +  - [✅] **检查点**: 能说出"JMM是用来解决什么问题的"
         29 +  - [ ] **文件**: 在`student_progress/`创建`jmm_notes.md`，用自己的话写下理解
         30 +  
         31 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
         32 +  ```java
         33 +  // 练习目标: 亲眼看到"可见性问题"
         34 +  public class MemoryVisibilityDemo {
         35 +      // 第一步: 创建一个简单的可见性问题演示
         36 +      private static boolean flag = false;    // 注意: 不使用volatile
         37 +      private static int counter = 0;
         38 +      
         39 +      public static void main(String[] args) throws InterruptedException {
         40 +          // TODO: 学生手动输入以下代码，观察现象
         41 +          
         42 +          // 线程1: 读取者 - 等待flag变为true
         43 +          Thread readerThread = new Thread(() -> {
         44 +              System.out.println("读取者: 开始等待flag变为true...");
         45 +              while (!flag) {
         46 +                  // 空循环 - 可能永远等待下去!
         47 +              }
         48 +              System.out.println("读取者: 检测到flag为true, counter=" + counter);
         49 +          });
         50 +          
         51 +          // 线程2: 写入者 - 修改共享变量
         52 +          Thread writerThread = new Thread(() -> {
         53 +              try {
         54 +                  Thread.sleep(1000);  // 等待1秒
         55 +                  counter = 42;        // 先修改counter
         56 +                  flag = true;         // 再修改flag
         57 +                  System.out.println("写入者: 已设置flag=true, counter=" + counter);
         58 +              } catch (InterruptedException e) {
         59 +                  e.printStackTrace();
         60 +              }
         61 +          });
         62 +          
         63 +          readerThread.start();
         64 +          writerThread.start();
         65 +          
         66 +          // 等待3秒，观察是否出现死循环
         67 +          Thread.sleep(3000);
         68 +          if (readerThread.isAlive()) {
         69 +              System.out.println("⚠️  JMM可见性问题重现! 读取者线程仍在等待");
         70 +              readerThread.interrupt();
         71 +          }
         72 +          
         73 +          writerThread.join();
         74 +      }
         75 +  }
         76 +  ```
         77 +  
         78 +  **📝 编程任务检查点**:
         79 +  - [ ] **手动输入**: 完整代码必须手动输入，体验每一行的含义
         80 +  - [ ] **运行验证**: 程序能运行并观察到可见性问题(读取者可能永远等待)
         81 +  - [ ] **现象理解**: 理解为什么flag的修改对读取者不可见
         82 +  - [ ] **代码位置**: `student_progress/JavaLearning/src/MemoryVisibilityDemo.java`
         83 +  
         84 +  **🚀 Intermediate Level (实践验证)**  
         85 +  - [ ] **深入概念**: 理解"线程工作内存"和"主内存"的数据同步机制
         86 +  - [ ] **技术细节**: 学习缓存一致性、CPU缓存对Java程序的影响
         87 +  - [ ] **检查点**: 能画出简单的JMM内存结构图
         88 +  
         89 +  **🏆 Senior Level (架构思维)**
         90 +  - [ ] **设计原理**: 理解为什么JVM要设计这样的内存模型
         91 +  - [ ] **性能权衡**: CPU缓存 vs 数据一致性的trade-off
         92 +  - [ ] **面试深度**: 能从JMM角度分析并发问题的根本原因
         93 +  
         94 +  #### Task 1.1.2: happens-before原则 + 编程验证 (5分钟) ⏰  
         95 +  
         96 +  **🎯 Primary Level (新手友好)**
         97 +  - [✅] **什么是happens-before**: 想象一个接力赛，前一个跑步者的成绩，后一个跑步者一定能看到
         98 +  - [✅] **简单理解**: "A发生在B之前"意味着"B能看到A的所有结果"
         99 +  - [✅] **记忆技巧**: happens-before = "发生在前面" + "结果可见"
        100 +  - [✅] **检查点**: 能用"接力赛"例子解释happens-before
        101 +  - [ ] **文件**: 在`jmm_notes.md`中用生活例子写下理解
        102 +  
        103 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
        104 +  ```java
        105 +  // 练习目标: 验证happens-before规则
        106 +  public class HappensBeforeDemo {
        107 +      private static int sharedData = 0;
        108 +      private static boolean dataReady = false;
        109 +      
        110 +      public static void main(String[] args) throws InterruptedException {
        111 +          
        112 +          // 实验1: 无同步的数据竞争
        113 +          System.out.println("=== 实验1: 无同步情况 ===");
        114 +          testWithoutSynchronization();
        115 +          
        116 +          Thread.sleep(2000);
        117 +          
        118 +          // 实验2: 使用volatile保证happens-before
        119 +          System.out.println("\n=== 实验2: volatile同步情况 ===");
        120 +          testWithVolatile();
        121 +      }
        122 +      
        123 +      // TODO: 学生手动实现这两个方法
        124 +      private static void testWithoutSynchronization() throws InterruptedException {
        125 +          sharedData = 0;
        126 +          dataReady = false;
        127 +          
        128 +          // 写入者线程
        129 +          Thread writer = new Thread(() -> {
        130 +              sharedData = 42;      // 步骤1: 设置数据
        131 +              dataReady = true;     // 步骤2: 设置标志 (无happens-before保证)
        132 +              System.out.println("写入者: 数据已准备好");
        133 +          });
        134 +          
        135 +          // 读取者线程  
        136 +          Thread reader = new Thread(() -> {
        137 +              while (!dataReady) {  // 等待数据准备好
        138 +                  Thread.yield();   // 让出CPU避免busy-wait
        139 +              }
        140 +              // 问题: 即使dataReady为true，sharedData可能还是0!
        141 +              System.out.println("读取者看到的数据: " + sharedData);
        142 +          });
        143 +          
        144 +          reader.start();
        145 +          writer.start();
        146 +          
        147 +          writer.join();
        148 +          reader.join();
        149 +      }
        150 +      
        151 +      private static void testWithVolatile() {
        152 +          // TODO: 学生修改上面的代码，给dataReady加上volatile
        153 +          // 观察volatile如何建立happens-before关系
        154 +      }
        155 +  }
        156 +  ```
        157 +  
        158 +  **📝 编程任务检查点**:
        159 +  - [ ] **手动输入**: 必须手动输入代码，理解每一行的作用
        160 +  - [ ] **对比实验**: 运行无同步版本，观察数据不一致问题
        161 +  - [ ] **volatile修复**: 为dataReady添加volatile，观察问题解决
        162 +  - [ ] **原理理解**: 理解volatile写-读如何建立happens-before关系
        163 +  
        164 +  **🚀 Intermediate Level (实践验证)**  
        165 +  - [ ] **技术定义**: 学习"如果A happens-before B，那么A的结果对B可见"
        166 +  - [ ] **常见场景**: synchronized块、volatile写读、线程start/join
        167 +  - [ ] **检查点**: 能列出3个具体的happens-before规则
        168 +  
        169 +  **🏆 Senior Level (架构思维)**
        170 +  - [ ] **内存语义**: 理解happens-before与内存可见性的关系
        171 +  - [ ] **编译器优化**: 知道happens-before如何约束重排序
        172 +  - [ ] **面试深度**: 能分析复杂并发场景的happens-before关系
        173 +  
        174 +  #### Task 1.1.3: synchronized基本原理 + 线程安全实战 (5分钟) ⏰
        175 +  
        176 +  **🎯 Primary Level (新手友好)**
        177 +  - [✅] **什么是synchronized**: 想象一个厕所门锁，一次只能一个人进去
        178 +  - [✅] **简单理解**: synchronized就是给代码加了一把锁，确保不会"撞车"
        179 +  - [✅] **生活类比**: 就像银行只有一个窗口，大家要排队一个一个来
        180 +  - [✅] **检查点**: 能说出"synchronized是用来防止什么问题的"
        181 +  - [ ] **文件**: 在`student_progress/`创建`synchronized_notes.md`
        182 +  
        183 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
        184 +  ```java
        185 +  // 练习目标: 先看到问题，再解决问题
        186 +  public class SynchronizedDemo {
        187 +      private static int unsafeCounter = 0;      // 不安全的计数器
        188 +      private static int safeCounter = 0;        // 安全的计数器
        189 +      private static final Object lock = new Object();
        190 +      
        191 +      public static void main(String[] args) throws InterruptedException {
        192 +          final int THREAD_COUNT = 10;
        193 +          final int INCREMENT_COUNT = 1000;
        194 +          
        195 +          System.out.println("=== 步骤1: 展示数据竞争问题 ===");
        196 +          testUnsafeIncrement(THREAD_COUNT, INCREMENT_COUNT);
        197 +          
        198 +          System.out.println("\n=== 步骤2: synchronized解决方案 ===");
        199 +          testSafeIncrement(THREAD_COUNT, INCREMENT_COUNT);
        200 +          
        201 +          System.out.println("\n=== 步骤3: 性能对比分析 ===");
        202 +          performanceComparison();
        203 +      }
        204 +      
        205 +      // TODO: 学生手动实现不安全的递增操作
        206 +      private static void testUnsafeIncrement(int threadCount, int incrementCount) 
        207 +              throws InterruptedException {
        208 +          unsafeCounter = 0;
        209 +          Thread[] threads = new Thread[threadCount];
        210 +          
        211 +          long startTime = System.currentTimeMillis();
        212 +          
        213 +          // 创建多个线程同时对counter进行++操作
        214 +          for (int i = 0; i < threadCount; i++) {
        215 +              threads[i] = new Thread(() -> {
        216 +                  for (int j = 0; j < incrementCount; j++) {
        217 +                      unsafeCounter++;  // 线程不安全！可能丢失数据
        218 +                  }
        219 +              });
        220 +              threads[i].start();
        221 +          }
        222 +          
        223 +          // 等待所有线程完成
        224 +          for (Thread thread : threads) {
        225 +              thread.join();
        226 +          }
        227 +          
        228 +          long endTime = System.currentTimeMillis();
        229 +          
        230 +          System.out.println("期望结果: " + (threadCount * incrementCount));
        231 +          System.out.println("实际结果: " + unsafeCounter);
        232 +          System.out.println("数据丢失: " + (threadCount * incrementCount - unsafeCounter));
        233 +          System.out.println("执行时间: " + (endTime - startTime) + "ms");
        234 +      }
        235 +      
        236 +      // TODO: 学生实现synchronized版本
        237 +      private static void testSafeIncrement(int threadCount, int incrementCount) 
        238 +              throws InterruptedException {
        239 +          // 实现线程安全的版本，使用synchronized
        240 +          safeCounter = 0;
        241 +          Thread[] threads = new Thread[threadCount];
        242 +          
        243 +          long startTime = System.currentTimeMillis();
        244 +          
        245 +          for (int i = 0; i < threadCount; i++) {
        246 +              threads[i] = new Thread(() -> {
        247 +                  for (int j = 0; j < incrementCount; j++) {
        248 +                      synchronized (lock) {    // 关键: 同步块
        249 +                          safeCounter++;       // 现在是线程安全的
        250 +                      }
        251 +                  }
        252 +              });
        253 +              threads[i].start();
        254 +          }
        255 +          
        256 +          for (Thread thread : threads) {
        257 +              thread.join();
        258 +          }
        259 +          
        260 +          long endTime = System.currentTimeMillis();
        261 +          
        262 +          System.out.println("期望结果: " + (threadCount * incrementCount));
        263 +          System.out.println("实际结果: " + safeCounter);
        264 +          System.out.println("数据正确: " + (safeCounter == threadCount * incrementCount));
        265 +          System.out.println("执行时间: " + (endTime - startTime) + "ms");
        266 +      }
        267 +      
        268 +      // TODO: 学生实现性能对比
        269 +      private static void performanceComparison() {
        270 +          // 比较不同同步策略的性能差异
        271 +          // 1. 无同步 (不安全但快)
        272 +          // 2. synchronized代码块 
        273 +          // 3. synchronized方法
        274 +          // 4. 不同锁粒度的影响
        275 +      }
        276 +  }
        277 +  ```
        278 +  
        279 +  **📝 编程任务检查点**:
        280 +  - [ ] **问题重现**: 能够运行代码并观察到数据丢失问题
        281 +  - [ ] **解决方案**: 使用synchronized成功解决数据竞争
        282 +  - [ ] **性能理解**: 观察同步带来的性能开销
        283 +  - [ ] **多种方式**: 尝试synchronized方法 vs synchronized代码块
        284 +  
        285 +  **🚀 Intermediate Level (实践验证)**  
        286 +  - [ ] **技术细节**: 理解monitor机制，每个对象都有一个内置锁
        287 +  - [ ] **使用方式**: 同步方法 vs 同步代码块的区别
        288 +  - [ ] **检查点**: 能写出简单的synchronized代码示例
        289 +  
        290 +  **🏆 Senior Level (架构思维)**
        291 +  - [ ] **锁升级**: 偏向锁→轻量级锁→重量级锁的优化过程
        292 +  - [ ] **性能考虑**: 锁粒度、锁竞争对性能的影响
        293 +  - [ ] **面试深度**: 能分析synchronized的底层实现机制
        294 +  
        295 +  #### Task 1.1.4: volatile基本原理 + 可见性验证 (5分钟) ⏰
        296 +  
        297 +  **🎯 Primary Level (新手友好)**
        298 +  - [✅] **什么是volatile**: 想象一个公告板，任何人更新后，所有人立即能看到
        299 +  - [✅] **简单理解**: volatile确保变量的"最新消息"能被所有线程看到
        300 +  - [✅] **常见错误**: volatile ≠ synchronized，它不能防止"撞车"
        301 +  - [✅] **检查点**: 能说出"volatile解决什么问题，不解决什么问题"
        302 +  - [ ] **文件**: 在`student_progress/`创建`volatile_notes.md`
        303 +  
        304 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
        305 +  ```java
        306 +  // 练习目标: 对比volatile和非volatile的差异
        307 +  public class VolatileDemo {
        308 +      
        309 +      // 实验1: 可见性问题演示
        310 +      private static boolean normalFlag = false;          // 普通变量
        311 +      private static volatile boolean volatileFlag = false;   // volatile变量
        312 +      
        313 +      // 实验2: 原子性问题演示  
        314 +      private static volatile int volatileCounter = 0;    // volatile不保证原子性
        315 +      
        316 +      public static void main(String[] args) throws InterruptedException {
        317 +          System.out.println("=== 实验1: 可见性对比 ===");
        318 +          testVisibility();
        319 +          
        320 +          Thread.sleep(3000);
        321 +          
        322 +          System.out.println("\n=== 实验2: volatile不保证原子性 ===");
        323 +          testAtomicity();
        324 +      }
        325 +      
        326 +      // TODO: 学生手动实现可见性测试
        327 +      private static void testVisibility() throws InterruptedException {
        328 +          
        329 +          // 测试普通变量的可见性问题
        330 +          System.out.println("--- 测试普通变量 ---");
        331 +          normalFlag = false;
        332 +          
        333 +          Thread readerThread1 = new Thread(() -> {
        334 +              System.out.println("普通变量读取者: 开始等待...");
        335 +              while (!normalFlag) {
        336 +                  // 可能永远循环下去！
        337 +              }
        338 +              System.out.println("普通变量读取者: 检测到flag变化!");
        339 +          });
        340 +          
        341 +          Thread writerThread1 = new Thread(() -> {
        342 +              try {
        343 +                  Thread.sleep(1000);
        344 +                  normalFlag = true;
        345 +                  System.out.println("普通变量写入者: 已设置flag=true");
        346 +              } catch (InterruptedException e) {
        347 +                  e.printStackTrace();
        348 +              }
        349 +          });
        350 +          
        351 +          readerThread1.start();
        352 +          writerThread1.start();
        353 +          
        354 +          // 等待2秒看是否有死循环
        355 +          Thread.sleep(2000);
        356 +          if (readerThread1.isAlive()) {
        357 +              System.out.println("⚠️  普通变量可见性问题: 读取者仍在等待");
        358 +              readerThread1.interrupt();
        359 +          }
        360 +          writerThread1.join();
        361 +          
        362 +          Thread.sleep(500);
        363 +          
        364 +          // 测试volatile变量
        365 +          System.out.println("--- 测试volatile变量 ---");
        366 +          volatileFlag = false;
        367 +          
        368 +          Thread readerThread2 = new Thread(() -> {
        369 +              System.out.println("volatile读取者: 开始等待...");
        370 +              while (!volatileFlag) {
        371 +                  // volatile保证可见性，会正常退出
        372 +              }
        373 +              System.out.println("volatile读取者: 检测到flag变化!");
        374 +          });
        375 +          
        376 +          Thread writerThread2 = new Thread(() -> {
        377 +              try {
        378 +                  Thread.sleep(1000);
        379 +                  volatileFlag = true;
        380 +                  System.out.println("volatile写入者: 已设置flag=true");
        381 +              } catch (InterruptedException e) {
        382 +                  e.printStackTrace();
        383 +              }
        384 +          });
        385 +          
        386 +          readerThread2.start();
        387 +          writerThread2.start();
        388 +          readerThread2.join();
        389 +          writerThread2.join();
        390 +      }
        391 +      
        392 +      // TODO: 学生实现原子性测试
        393 +      private static void testAtomicity() throws InterruptedException {
        394 +          final int THREAD_COUNT = 10;
        395 +          final int INCREMENT_COUNT = 1000;
        396 +          
        397 +          volatileCounter = 0;
        398 +          Thread[] threads = new Thread[THREAD_COUNT];
        399 +          
        400 +          for (int i = 0; i < THREAD_COUNT; i++) {
        401 +              threads[i] = new Thread(() -> {
        402 +                  for (int j = 0; j < INCREMENT_COUNT; j++) {
        403 +                      volatileCounter++;  // volatile不保证原子性！
        404 +                  }
        405 +              });
        406 +              threads[i].start();
        407 +          }
        408 +          
        409 +          for (Thread thread : threads) {
        410 +              thread.join();
        411 +          }
        412 +          
        413 +          System.out.println("期望结果: " + (THREAD_COUNT * INCREMENT_COUNT));
        414 +          System.out.println("实际结果: " + volatileCounter);
        415 +          System.out.println("数据丢失: " + (THREAD_COUNT * INCREMENT_COUNT - volatileCounter));
        416 +          System.out.println("结论: volatile保证可见性，但不保证原子性");
        417 +      }
        418 +  }
        419 +  ```
        420 +  
        421 +  **📝 编程任务检查点**:
        422 +  - [ ] **可见性验证**: 观察普通变量的可见性问题，volatile的解决效果
        423 +  - [ ] **原子性问题**: 验证volatile在++操作中仍然会丢失数据
        424 +  - [ ] **场景理解**: 理解volatile适用于纯赋值，不适用于复合操作
        425 +  - [ ] **代码位置**: `student_progress/JavaLearning/src/VolatileDemo.java`
        426 +  
        427 +  **🚀 Intermediate Level (实践验证)**  
        428 +  - [ ] **两个作用**: 保证可见性 + 禁止指令重排序
        429 +  - [ ] **经典场景**: 单例模式双重检查锁定
        430 +  - [ ] **检查点**: 能解释为什么volatile不能保证原子性
        431 +  
        432 +  **🏆 Senior Level (架构思维)**
        433 +  - [ ] **内存屏障**: volatile如何通过内存屏障实现语义
        434 +  - [ ] **性能特点**: volatile vs synchronized的性能对比
        435 +  - [ ] **面试深度**: 能分析volatile在并发框架中的应用
        436 +  
        437 +  ### 🚀 Level 2: Intermediate Practice (实践深入) - 15分钟
        438 +  
        439 +  #### Task 1.1.5: 锁升级机制理解 + JVM参数实验 (5分钟) ⏰
        440 +  
        441 +  **🎯 Primary Level (新手友好)**
        442 +  - [ ] **偏向锁类比**: 想象你的专属停车位，第一次停车后就贴上你的名字
        443 +  - [ ] **简单理解**: 如果只有一个线程在用锁，JVM就"偏向"给它，减少开销
        444 +  - [ ] **记忆技巧**: 偏向 = "偏心"，第一个线程会被"偏爱"
        445 +  - [ ] **检查点**: 能说出"偏向锁适用于什么场景"
        446 +  
        447 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
        448 +  ```java
        449 +  // 练习目标: 观察锁升级的实际过程
        450 +  public class LockEscalationDemo {
        451 +      private final Object monitor = new Object();
        452 +      private static final int ITERATIONS = 1000000;
        453 +      
        454 +      public static void main(String[] args) throws InterruptedException {
        455 +          LockEscalationDemo demo = new LockEscalationDemo();
        456 +          
        457 +          System.out.println("=== 锁升级观察实验 ===");
        458 +          System.out.println("JVM参数: 运行时添加 -XX:+PrintGCDetails -XX:+TraceBiasedLocking");
        459 +          
        460 +          // 实验1: 单线程场景 - 偏向锁
        461 +          demo.testBiasedLock();
        462 +          
        463 +          Thread.sleep(1000);
        464 +          
        465 +          // 实验2: 轻度竞争 - 轻量级锁
        466 +          demo.testLightweightLock();
        467 +          
        468 +          Thread.sleep(1000);
        469 +          
        470 +          // 实验3: 激烈竞争 - 重量级锁
        471 +          demo.testHeavyweightLock();
        472 +      }
        473 +      
        474 +      // TODO: 学生实现偏向锁测试
        475 +      private void testBiasedLock() {
        476 +          System.out.println("\n--- 实验1: 偏向锁场景 (单线程) ---");
        477 +          
        478 +          long startTime = System.nanoTime();
        479 +          
        480 +          // 单线程重复获取同一个锁
        481 +          for (int i = 0; i < ITERATIONS; i++) {
        482 +              synchronized (monitor) {
        483 +                  // 空操作，专注观察锁的开销
        484 +              }
        485 +          }
        486 +          
        487 +          long endTime = System.nanoTime();
        488 +          long duration = endTime - startTime;
        489 +          
        490 +          System.out.println("单线程执行时间: " + duration / 1000000 + "ms");
        491 +          System.out.println("平均每次加锁: " + duration / ITERATIONS + "ns");
        492 +          System.out.println("预期: 偏向锁应该有很低的开销");
        493 +      }
        494 +      
        495 +      // TODO: 学生实现轻量级锁测试
        496 +      private void testLightweightLock() throws InterruptedException {
        497 +          System.out.println("\n--- 实验2: 轻量级锁场景 (交替访问) ---");
        498 +          
        499 +          final Object sharedMonitor = new Object();
        500 +          final int[] sharedCounter = {0};
        501 +          
        502 +          Thread thread1 = new Thread(() -> {
        503 +              for (int i = 0; i < ITERATIONS / 2; i++) {
        504 +                  synchronized (sharedMonitor) {
        505 +                      sharedCounter[0]++;
        506 +                  }
        507 +                  // 小延迟，让另一个线程有机会获取锁
        508 +                  if (i % 1000 == 0) {
        509 +                      Thread.yield();
        510 +                  }
        511 +              }
        512 +          });
        513 +          
        514 +          Thread thread2 = new Thread(() -> {
        515 +              for (int i = 0; i < ITERATIONS / 2; i++) {
        516 +                  synchronized (sharedMonitor) {
        517 +                      sharedCounter[0]++;
        518 +                  }
        519 +                  if (i % 1000 == 0) {
        520 +                      Thread.yield();
        521 +                  }
        522 +              }
        523 +          });
        524 +          
        525 +          long startTime = System.nanoTime();
        526 +          
        527 +          thread1.start();
        528 +          thread2.start();
        529 +          thread1.join();
        530 +          thread2.join();
        531 +          
        532 +          long endTime = System.nanoTime();
        533 +          
        534 +          System.out.println("双线程执行时间: " + (endTime - startTime) / 1000000 + "ms");
        535 +          System.out.println("共享计数器: " + sharedCounter[0]);
        536 +          System.out.println("预期: 轻量级锁通过CAS自旋，开销中等");
        537 +      }
        538 +      
        539 +      // TODO: 学生实现重量级锁测试
        540 +      private void testHeavyweightLock() throws InterruptedException {
        541 +          System.out.println("\n--- 实验3: 重量级锁场景 (激烈竞争) ---");
        542 +          
        543 +          final Object contentionMonitor = new Object();
        544 +          final int THREAD_COUNT = 10;
        545 +          final int[] sharedCounter = {0};
        546 +          
        547 +          Thread[] threads = new Thread[THREAD_COUNT];
        548 +          
        549 +          long startTime = System.nanoTime();
        550 +          
        551 +          for (int i = 0; i < THREAD_COUNT; i++) {
        552 +              threads[i] = new Thread(() -> {
        553 +                  for (int j = 0; j < ITERATIONS / THREAD_COUNT; j++) {
        554 +                      synchronized (contentionMonitor) {
        555 +                          sharedCounter[0]++;
        556 +                          // 模拟一些工作，增加锁持有时间
        557 +                          try {
        558 +                              Thread.sleep(0, 100); // 0.1微秒
        559 +                          } catch (InterruptedException e) {
        560 +                              Thread.currentThread().interrupt();
        561 +                          }
        562 +                      }
        563 +                  }
        564 +              });
        565 +              threads[i].start();
        566 +          }
        567 +          
        568 +          for (Thread thread : threads) {
        569 +              thread.join();
        570 +          }
        571 +          
        572 +          long endTime = System.nanoTime();
        573 +          
        574 +          System.out.println("多线程激烈竞争执行时间: " + (endTime - startTime) / 1000000 + "ms");
        575 +          System.out.println("共享计数器: " + sharedCounter[0]);
        576 +          System.out.println("预期: 重量级锁涉及系统调用，开销最大");
        577 +          
        578 +          // 性能总结
        579 +          System.out.println("\n=== 锁升级性能总结 ===");
        580 +          System.out.println("偏向锁: 适用于单线程重复获取，开销最小");
        581 +          System.out.println("轻量级锁: 适用于轻度竞争，CAS自旋");
        582 +          System.out.println("重量级锁: 适用于激烈竞争，系统调用阻塞/唤醒");
        583 +      }
        584 +  }
        585 +  ```
        586 +  
        587 +  **📝 编程任务检查点**:
        588 +  - [ ] **手动输入**: 完整实现三种锁场景的测试代码
        589 +  - [ ] **性能对比**: 观察不同锁状态下的执行时间差异
        590 +  - [ ] **JVM参数**: 运行时添加JVM参数观察锁状态变化
        591 +  - [ ] **原理理解**: 理解为什么不同场景会触发不同的锁升级
        592 +  
        593 +  **🚀 Intermediate Level (实践验证)**  
        594 +  - [ ] **技术细节**: 对象头中的偏向锁标记位，线程ID记录
        595 +  - [ ] **失效条件**: 多线程竞争时偏向锁会撤销
        596 +  - [ ] **检查点**: 能说出偏向锁失效的3种情况
        597 +  
        598 +  **🏆 Senior Level (架构思维)**
        599 +  - [ ] **设计权衡**: 偏向锁的CAS开销 vs 频繁加锁的开销
        600 +  - [ ] **JVM参数**: -XX:+UseBiasedLocking的影响
        601 +  - [ ] **面试深度**: 能分析偏向锁在高并发场景下的适用性
        602 +  
        603 +  #### Task 1.1.6: 轻量级锁与CAS深度实践 (5分钟) ⏰
        604 +  
        605 +  **🎯 Primary Level (新手友好)**
        606 +  - [ ] **轻量级锁类比**: 想象排队买奶茶，先"试试看"能不能马上买到
        607 +  - [ ] **CAS理解**: "Compare And Swap" = "比较一下，如果没变就替换"
        608 +  - [ ] **自旋概念**: 就像一直按电梯按钮，希望电梯快点来
        609 +  - [ ] **检查点**: 能说出"为什么叫轻量级锁"
        610 +  
        611 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
        612 +  ```java
        613 +  import java.util.concurrent.atomic.AtomicInteger;
        614 +  import java.util.concurrent.atomic.AtomicReference;
        615 +  
        616 +  // 练习目标: 深入理解CAS机制和ABA问题
        617 +  public class CASandLightweightLockDemo {
        618 +      
        619 +      // 实验1: 手写CAS操作模拟
        620 +      private static class SimpleCAS {
        621 +          private volatile int value = 0;
        622 +          
        623 +          // 模拟CAS操作 (实际的CAS是原子的硬件指令)
        624 +          public synchronized boolean compareAndSet(int expect, int update) {
        625 +              if (value == expect) {
        626 +                  value = update;
        627 +                  return true;  // CAS成功
        628 +              }
        629 +              return false;     // CAS失败
        630 +          }
        631 +          
        632 +          public int getValue() {
        633 +              return value;
        634 +          }
        635 +      }
        636 +      
        637 +      // 实验2: ABA问题演示
        638 +      private static class ABADemo {
        639 +          private AtomicReference<String> reference = new AtomicReference<>("A");
        640 +          
        641 +          public void demonstrateABAProblem() throws InterruptedException {
        642 +              System.out.println("=== ABA问题演示 ===");
        643 +              System.out.println("初始值: " + reference.get());
        644 +              
        645 +              // 线程1: 想要把A改成B，但被延迟了
        646 +              Thread thread1 = new Thread(() -> {
        647 +                  String original = reference.get();  // 读取到A
        648 +                  System.out.println("线程1: 读取到值 = " + original);
        649 +                  
        650 +                  try {
        651 +                      Thread.sleep(1000);  // 模拟延迟
        652 +                  } catch (InterruptedException e) {
        653 +                      e.printStackTrace();
        654 +                  }
        655 +                  
        656 +                  // 尝试CAS: A -> B
        657 +                  boolean success = reference.compareAndSet(original, "B");
        658 +                  System.out.println("线程1: CAS A->B " + (success ? "成功" : "失败"));
        659 +                  System.out.println("线程1: 当前值 = " + reference.get());
        660 +              });
        661 +              
        662 +              // 线程2: 快速执行 A->C->A 的操作
        663 +              Thread thread2 = new Thread(() -> {
        664 +                  try {
        665 +                      Thread.sleep(200);  // 稍等一下
        666 +                      
        667 +                      // A -> C
        668 +                      boolean step1 = reference.compareAndSet("A", "C");
        669 +                      System.out.println("线程2: CAS A->C " + (step1 ? "成功" : "失败"));
        670 +                      
        671 +                      Thread.sleep(300);
        672 +                      
        673 +                      // C -> A (恢复原值)
        674 +                      boolean step2 = reference.compareAndSet("C", "A");
        675 +                      System.out.println("线程2: CAS C->A " + (step2 ? "成功" : "失败"));
        676 +                      System.out.println("线程2: 已将值恢复为A");
        677 +                      
        678 +                  } catch (InterruptedException e) {
        679 +                      e.printStackTrace();
        680 +                  }
        681 +              });
        682 +              
        683 +              thread1.start();
        684 +              thread2.start();
        685 +              thread1.join();
        686 +              thread2.join();
        687 +              
        688 +              System.out.println("最终值: " + reference.get());
        689 +              System.out.println("问题: 线程1不知道值被改动过!");
        690 +          }
        691 +      }
        692 +      
        693 +      public static void main(String[] args) throws InterruptedException {
        694 +          
        695 +          // 实验1: 基础CAS操作
        696 +          System.out.println("=== 实验1: CAS基础操作 ===");
        697 +          testBasicCAS();
        698 +          
        699 +          Thread.sleep(1000);
        700 +          
        701 +          // 实验2: CAS自旋模拟轻量级锁
        702 +          System.out.println("\n=== 实验2: CAS自旋机制 ===");
        703 +          testCASSpinning();
        704 +          
        705 +          Thread.sleep(1000);
        706 +          
        707 +          // 实验3: ABA问题
        708 +          System.out.println("\n=== 实验3: ABA问题 ===");
        709 +          ABADemo abaDemo = new ABADemo();
        710 +          abaDemo.demonstrateABAProblem();
        711 +          
        712 +          Thread.sleep(1000);
        713 +          
        714 +          // 实验4: 原子类vs synchronized性能对比
        715 +          System.out.println("\n=== 实验4: 性能对比 ===");
        716 +          performanceComparison();
        717 +      }
        718 +      
        719 +      // TODO: 学生实现基础CAS测试
        720 +      private static void testBasicCAS() throws InterruptedException {
        721 +          SimpleCAS cas = new SimpleCAS();
        722 +          final int THREAD_COUNT = 5;
        723 +          final int ATTEMPTS_PER_THREAD = 1000;
        724 +          
        725 +          Thread[] threads = new Thread[THREAD_COUNT];
        726 +          
        727 +          for (int i = 0; i < THREAD_COUNT; i++) {
        728 +              final int threadId = i;
        729 +              threads[i] = new Thread(() -> {
        730 +                  int successCount = 0;
        731 +                  int failureCount = 0;
        732 +                  
        733 +                  for (int j = 0; j < ATTEMPTS_PER_THREAD; j++) {
        734 +                      int currentValue = cas.getValue();
        735 +                      boolean success = cas.compareAndSet(currentValue, currentValue + 1);
        736 +                      
        737 +                      if (success) {
        738 +                          successCount++;
        739 +                      } else {
        740 +                          failureCount++;
        741 +                          // CAS失败，重试
        742 +                          j--; // 重试同一次操作
        743 +                      }
        744 +                  }
        745 +                  
        746 +                  System.out.println("线程" + threadId + ": 成功=" + successCount + ", 失败=" + 
            + failureCount);
        747 +              });
        748 +              threads[i].start();
        749 +          }
        750 +          
        751 +          for (Thread thread : threads) {
        752 +              thread.join();
        753 +          }
        754 +          
        755 +          System.out.println("最终计数器值: " + cas.getValue());
        756 +          System.out.println("期望值: " + (THREAD_COUNT * ATTEMPTS_PER_THREAD));
        757 +      }
        758 +      
        759 +      // TODO: 学生实现CAS自旋模拟
        760 +      private static void testCASSpinning() throws InterruptedException {
        761 +          AtomicInteger atomicCounter = new AtomicInteger(0);
        762 +          final int THREAD_COUNT = 3;
        763 +          final int TARGET_VALUE = 10000;
        764 +          
        765 +          Thread[] threads = new Thread[THREAD_COUNT];
        766 +          
        767 +          for (int i = 0; i < THREAD_COUNT; i++) {
        768 +              final int threadId = i;
        769 +              threads[i] = new Thread(() -> {
        770 +                  int spinCount = 0;
        771 +                  
        772 +                  while (atomicCounter.get() < TARGET_VALUE) {
        773 +                      int currentValue = atomicCounter.get();
        774 +                      
        775 +                      if (currentValue >= TARGET_VALUE) {
        776 +                          break;  // 已经达到目标
        777 +                      }
        778 +                      
        779 +                      // 尝试CAS递增
        780 +                      boolean success = atomicCounter.compareAndSet(currentValue, currentValue + 1);
        781 +                      
        782 +                      if (!success) {
        783 +                          spinCount++;  // 记录自旋次数
        784 +                      }
        785 +                      
        786 +                      // 模拟轻量级锁的自旋限制
        787 +                      if (spinCount > 100) {
        788 +                          Thread.yield();  // 让出CPU
        789 +                          spinCount = 0;
        790 +                      }
        791 +                  }
        792 +                  
        793 +                  System.out.println("线程" + threadId + ": 自旋次数=" + spinCount);
        794 +              });
        795 +              threads[i].start();
        796 +          }
        797 +          
        798 +          for (Thread thread : threads) {
        799 +              thread.join();
        800 +          }
        801 +          
        802 +          System.out.println("原子计数器最终值: " + atomicCounter.get());
        803 +      }
        804 +      
        805 +      // TODO: 学生实现性能对比
        806 +      private static void performanceComparison() throws InterruptedException {
        807 +          final int THREAD_COUNT = 10;
        808 +          final int OPERATIONS = 100000;
        809 +          
        810 +          // 测试1: AtomicInteger (CAS)
        811 +          AtomicInteger atomicInt = new AtomicInteger(0);
        812 +          long startTime = System.nanoTime();
        813 +          
        814 +          Thread[] atomicThreads = new Thread[THREAD_COUNT];
        815 +          for (int i = 0; i < THREAD_COUNT; i++) {
        816 +              atomicThreads[i] = new Thread(() -> {
        817 +                  for (int j = 0; j < OPERATIONS; j++) {
        818 +                      atomicInt.incrementAndGet();  // CAS操作
        819 +                  }
        820 +              });
        821 +              atomicThreads[i].start();
        822 +          }
        823 +          
        824 +          for (Thread thread : atomicThreads) {
        825 +              thread.join();
        826 +          }
        827 +          
        828 +          long atomicTime = System.nanoTime() - startTime;
        829 +          
        830 +          // 测试2: synchronized
        831 +          int[] syncCounter = {0};
        832 +          Object lock = new Object();
        833 +          
        834 +          startTime = System.nanoTime();
        835 +          
        836 +          Thread[] syncThreads = new Thread[THREAD_COUNT];
        837 +          for (int i = 0; i < THREAD_COUNT; i++) {
        838 +              syncThreads[i] = new Thread(() -> {
        839 +                  for (int j = 0; j < OPERATIONS; j++) {
        840 +                      synchronized (lock) {
        841 +                          syncCounter[0]++;  // synchronized操作
        842 +                      }
        843 +                  }
        844 +              });
        845 +              syncThreads[i].start();
        846 +          }
        847 +          
        848 +          for (Thread thread : syncThreads) {
        849 +              thread.join();
        850 +          }
        851 +          
        852 +          long syncTime = System.nanoTime() - startTime;
        853 +          
        854 +          System.out.println("AtomicInteger (CAS): " + atomicTime / 1000000 + "ms, 结果=" + 
            + atomicInt.get());
        855 +          System.out.println("Synchronized: " + syncTime / 1000000 + "ms, 结果=" + syncCounter[0]);
        856 +          System.out.println("性能比: " + (double) syncTime / atomicTime + "x");
        857 +      }
        858 +  }
        859 +  ```
        860 +  
        861 +  **📝 编程任务检查点**:
        862 +  - [ ] **CAS理解**: 理解比较交换的原子性和重试机制
        863 +  - [ ] **ABA问题**: 观察和理解ABA问题的产生原因
        864 +  - [ ] **自旋机制**: 实现自旋重试和自旋次数限制
        865 +  - [ ] **性能对比**: 对比CAS vs synchronized的性能差异
        866 +  
        867 +  **🚀 Intermediate Level (实践验证)**  
        868 +  - [ ] **技术细节**: 栈帧中的Lock Record，CAS操作的原子性
        869 +  - [ ] **自旋次数**: 默认自旋次数和适应性自旋
        870 +  - [ ] **检查点**: 能解释CAS的ABA问题
        871 +  
        872 +  **🏆 Senior Level (架构思维)**
        873 +  - [ ] **性能考量**: 自旋 vs 阻塞的CPU开销对比
        874 +  - [ ] **硬件支持**: CAS指令的底层实现机制
        875 +  - [ ] **面试深度**: 能分析什么情况下轻量级锁会退化
        876 +  
        877 +  #### Task 1.1.7: 重量级锁与系统调用实验 (5分钟) ⏰
        878 +  
        879 +  **🎯 Primary Level (新手友好)**
        880 +  - [ ] **重量级锁类比**: 想象去银行办事，需要取号排队，涉及保安管理
        881 +  - [ ] **用户态vs内核态**: 用户态=家里，内核态=政府部门，切换需要"手续"
        882 +  - [ ] **阻塞唤醒**: 就像排队时可以坐下休息，叫号时再起来
        883 +  - [ ] **检查点**: 能说出"为什么叫重量级锁"
        884 +  
        885 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
        886 +  ```java
        887 +  import java.util.concurrent.locks.LockSupport;
        888 +  import java.lang.management.ManagementFactory;
        889 +  import java.lang.management.ThreadMXBean;
        890 +  
        891 +  // 练习目标: 观察重量级锁的系统调用开销
        892 +  public class HeavyweightLockDemo {
        893 +      
        894 +      private static final Object heavyLock = new Object();
        895 +      private static volatile boolean running = true;
        896 +      
        897 +      public static void main(String[] args) throws InterruptedException {
        898 +          System.out.println("=== 重量级锁与系统调用实验 ===");
        899 +          
        900 +          // 实验1: 观察线程状态变化
        901 +          demonstrateThreadStates();
        902 +          
        903 +          Thread.sleep(2000);
        904 +          
        905 +          // 实验2: 用户态vs内核态切换开销
        906 +          measureContextSwitchOverhead();
        907 +          
        908 +          Thread.sleep(2000);
        909 +          
        910 +          // 实验3: 等待队列和同步队列
        911 +          demonstrateWaitingQueues();
        912 +      }
        913 +      
        914 +      // TODO: 学生实现线程状态观察
        915 +      private static void demonstrateThreadStates() throws InterruptedException {
        916 +          System.out.println("\n--- 实验1: 观察线程状态变化 ---");
        917 +          
        918 +          Thread lockHolder = new Thread(() -> {
        919 +              synchronized (heavyLock) {
        920 +                  System.out.println("锁持有者: 获得锁，开始长时间工作...");
        921 +                  try {
        922 +                      Thread.sleep(3000);  // 持有锁3秒
        923 +                  } catch (InterruptedException e) {
        924 +                      Thread.currentThread().interrupt();
        925 +                  }
        926 +                  System.out.println("锁持有者: 工作完成，释放锁");
        927 +              }
        928 +          }, "LockHolder");
        929 +          
        930 +          Thread lockWaiter1 = new Thread(() -> {
        931 +              System.out.println("等待者1: 尝试获取锁...");
        932 +              synchronized (heavyLock) {
        933 +                  System.out.println("等待者1: 获得锁!");
        934 +              }
        935 +          }, "LockWaiter1");
        936 +          
        937 +          Thread lockWaiter2 = new Thread(() -> {
        938 +              System.out.println("等待者2: 尝试获取锁...");
        939 +              synchronized (heavyLock) {
        940 +                  System.out.println("等待者2: 获得锁!");
        941 +              }
        942 +          }, "LockWaiter2");
        943 +          
        944 +          // 状态监控线程
        945 +          Thread stateMonitor = new Thread(() -> {
        946 +              try {
        947 +                  while (running) {
        948 +                      System.out.println("\n--- 线程状态快照 ---");
        949 +                      System.out.println("LockHolder: " + lockHolder.getState());
        950 +                      System.out.println("LockWaiter1: " + lockWaiter1.getState());
        951 +                      System.out.println("LockWaiter2: " + lockWaiter2.getState());
        952 +                      Thread.sleep(500);
        953 +                  }
        954 +              } catch (InterruptedException e) {
        955 +                  Thread.currentThread().interrupt();
        956 +              }
        957 +          }, "StateMonitor");
        958 +          
        959 +          // 启动实验
        960 +          lockHolder.start();
        961 +          Thread.sleep(100);  // 确保lockHolder先获得锁
        962 +          
        963 +          lockWaiter1.start();
        964 +          lockWaiter2.start();
        965 +          stateMonitor.start();
        966 +          
        967 +          // 等待所有线程完成
        968 +          lockHolder.join();
        969 +          lockWaiter1.join();
        970 +          lockWaiter2.join();
        971 +          running = false;
        972 +          stateMonitor.join();
        973 +      }
        974 +      
        975 +      // TODO: 学生实现上下文切换开销测量
        976 +      private static void measureContextSwitchOverhead() throws InterruptedException {
        977 +          System.out.println("\n--- 实验2: 上下文切换开销测量 ---");
        978 +          
        979 +          final int ITERATIONS = 10000;
        980 +          ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
        981 +          
        982 +          // 测试1: 重量级锁的阻塞/唤醒开销
        983 +          long startTime = System.nanoTime();
        984 +          long startCpuTime = threadMXBean.getCurrentThreadCpuTime();
        985 +          
        986 +          Object contendedLock = new Object();
        987 +          volatile boolean shouldStop = false;
        988 +          
        989 +          // 创建一个持续竞争的场景
        990 +          Thread contender1 = new Thread(() -> {
        991 +              while (!shouldStop) {
        992 +                  synchronized (contendedLock) {
        993 +                      // 短暂持有锁
        994 +                      try {
        995 +                          Thread.sleep(1);  // 强制线程阻塞
        996 +                      } catch (InterruptedException e) {
        997 +                          break;
        998 +                      }
        999 +                  }
       1000 +              }
       1001 +          });
       1002 +          
       1003 +          Thread contender2 = new Thread(() -> {
       1004 +              while (!shouldStop) {
       1005 +                  synchronized (contendedLock) {
       1006 +                      try {
       1007 +                          Thread.sleep(1);
       1008 +                      } catch (InterruptedException e) {
       1009 +                          break;
       1010 +                      }
       1011 +                  }
       1012 +              }
       1013 +          });
       1014 +          
       1015 +          contender1.start();
       1016 +          contender2.start();
       1017 +          
       1018 +          // 让竞争持续1秒
       1019 +          Thread.sleep(1000);
       1020 +          shouldStop = true;
       1021 +          
       1022 +          contender1.join();
       1023 +          contender2.join();
       1024 +          
       1025 +          long endTime = System.nanoTime();
       1026 +          long endCpuTime = threadMXBean.getCurrentThreadCpuTime();
       1027 +          
       1028 +          long wallClockTime = endTime - startTime;
       1029 +          long cpuTime = endCpuTime - startCpuTime;
       1030 +          
       1031 +          System.out.println("重量级锁竞争:");
       1032 +          System.out.println("  墙钟时间: " + wallClockTime / 1000000 + "ms");
       1033 +          System.out.println("  CPU时间: " + cpuTime / 1000000 + "ms");
       1034 +          System.out.println("  阻塞时间: " + (wallClockTime - cpuTime) / 1000000 + "ms");
       1035 +          System.out.println("  系统调用比例: " + ((double)(wallClockTime - cpuTime) / wallClockTime * 
            + 100) + "%");
       1036 +          
       1037 +          // 测试2: 对比轻量级锁(无竞争)的开销
       1038 +          System.out.println("\n对比: 无竞争锁开销");
       1039 +          Object uncontendedLock = new Object();
       1040 +          
       1041 +          startTime = System.nanoTime();
       1042 +          
       1043 +          for (int i = 0; i < ITERATIONS; i++) {
       1044 +              synchronized (uncontendedLock) {
       1045 +                  // 空操作
       1046 +              }
       1047 +          }
       1048 +          
       1049 +          endTime = System.nanoTime();
       1050 +          
       1051 +          System.out.println("无竞争锁平均开销: " + (endTime - startTime) / ITERATIONS + "ns");
       1052 +      }
       1053 +      
       1054 +      // TODO: 学生实现等待队列演示
       1055 +      private static void demonstrateWaitingQueues() throws InterruptedException {
       1056 +          System.out.println("\n--- 实验3: 等待队列机制 ---");
       1057 +          
       1058 +          Object monitor = new Object();
       1059 +          final int WAITER_COUNT = 5;
       1060 +          
       1061 +          // 创建多个等待者
       1062 +          Thread[] waiters = new Thread[WAITER_COUNT];
       1063 +          
       1064 +          for (int i = 0; i < WAITER_COUNT; i++) {
       1065 +              final int waiterId = i;
       1066 +              waiters[i] = new Thread(() -> {
       1067 +                  synchronized (monitor) {
       1068 +                      System.out.println("等待者" + waiterId + ": 进入同步块");
       1069 +                      try {
       1070 +                          System.out.println("等待者" + waiterId + ": 调用wait()进入等待队列");
       1071 +                          monitor.wait();  // 进入等待队列
       1072 +                          System.out.println("等待者" + waiterId + ": 被唤醒，重新获得锁");
       1073 +                      } catch (InterruptedException e) {
       1074 +                          Thread.currentThread().interrupt();
       1075 +                      }
       1076 +                  }
       1077 +              }, "Waiter" + i);
       1078 +          }
       1079 +          
       1080 +          // 启动所有等待者
       1081 +          for (Thread waiter : waiters) {
       1082 +              waiter.start();
       1083 +              Thread.sleep(100);  // 确保按顺序进入等待
       1084 +          }
       1085 +          
       1086 +          Thread.sleep(1000);
       1087 +          
       1088 +          // 唤醒线程
       1089 +          Thread notifier = new Thread(() -> {
       1090 +              synchronized (monitor) {
       1091 +                  System.out.println("\n唤醒者: 开始逐个唤醒等待的线程");
       1092 +                  
       1093 +                  for (int i = 0; i < WAITER_COUNT; i++) {
       1094 +                      System.out.println("唤醒者: 调用notify()唤醒一个线程");
       1095 +                      monitor.notify();  // 从等待队列唤醒一个线程到同步队列
       1096 +                      
       1097 +                      try {
       1098 +                          Thread.sleep(500);  // 给被唤醒的线程一些执行时间
       1099 +                      } catch (InterruptedException e) {
       1100 +                          Thread.currentThread().interrupt();
       1101 +                      }
       1102 +                  }
       1103 +              }
       1104 +          }, "Notifier");
       1105 +          
       1106 +          notifier.start();
       1107 +          
       1108 +          // 等待所有线程完成
       1109 +          for (Thread waiter : waiters) {
       1110 +              waiter.join();
       1111 +          }
       1112 +          notifier.join();
       1113 +          
       1114 +          System.out.println("\n总结:");
       1115 +          System.out.println("1. 等待队列: 调用wait()的线程进入，释放锁");
       1116 +          System.out.println("2. 同步队列: 等待获取锁的线程排队");
       1117 +          System.out.println("3. notify(): 从等待队列移动一个线程到同步队列");
       1118 +          System.out.println("4. 重量级锁涉及内核态系统调用，开销大");
       1119 +      }
       1120 +  }
       1121 +  ```
       1122 +  
       1123 +  **📝 编程任务检查点**:
       1124 +  - [ ] **线程状态**: 观察BLOCKED、WAITING、RUNNABLE状态的变化
       1125 +  - [ ] **系统开销**: 测量上下文切换和系统调用的时间开销
       1126 +  - [ ] **队列机制**: 理解等待队列和同步队列的区别
       1127 +  - [ ] **代码位置**: `student_progress/JavaLearning/src/HeavyweightLockDemo.java`
       1128 +  
       1129 +  **🚀 Intermediate Level (实践验证)**  
       1130 +  - [ ] **技术细节**: Monitor对象，等待队列和同步队列
       1131 +  - [ ] **系统开销**: 用户态和内核态切换的性能成本
       1132 +  - [ ] **检查点**: 能画出锁升级的完整流程图
       1133 +  
       1134 +  **🏆 Senior Level (架构思维)**
       1135 +  - [ ] **升级时机**: JVM何时决定升级为重量级锁
       1136 +  - [ ] **优化策略**: 锁粗化、锁消除等编译器优化
       1137 +  - [ ] **面试深度**: 能分析不同锁状态下的性能特征
       1138 +  
       1139 +  ### 🏆 Level 3: Senior Application (架构应用) - 30分钟
       1140 +  
       1141 +  **学习说明**: 这个阶段要求你**亲手编码**，通过实际运行代码来验证理论知识。记住：**Learn by Doing** - 
            + 只有动手才能真正理解！
       1142 +  
       1143 +  #### Task 1.1.8: 企业级线程安全组件设计 (10分钟) ⏰
       1144 +  
       1145 +  **🎯 综合项目目标**: 设计一个生产级的线程安全缓存系统
       1146 +  - **代码规模**: 200-300行
       1147 +  - **技术要求**: 使用所有学过的并发原语
       1148 +  - **业务场景**: 高并发Web应用的数据缓存
       1149 +  
       1150 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
       1151 +  ```java
       1152 +  import java.util.concurrent.ConcurrentHashMap;
       1153 +  import java.util.concurrent.locks.ReadWriteLock;
       1154 +  import java.util.concurrent.locks.ReentrantReadWriteLock;
       1155 +  import java.util.concurrent.atomic.AtomicLong;
       1156 +  import java.util.concurrent.Executors;
       1157 +  import java.util.concurrent.ScheduledExecutorService;
       1158 +  import java.util.concurrent.TimeUnit;
       1159 +  
       1160 +  // 练习目标: 设计企业级线程安全缓存组件
       1161 +  public class EnterpriseThreadSafeCacheSystem {
       1162 +      
       1163 +      /**
       1164 +       * 高性能线程安全缓存实现
       1165 +       * 技术特性:
       1166 +       * 1. 使用ConcurrentHashMap作为存储结构
       1167 +       * 2. 读写锁提升读操作性能 
       1168 +       * 3. 原子计数器统计缓存指标
       1169 +       * 4. volatile保证配置可见性
       1170 +       * 5. synchronized保证批量操作原子性
       1171 +       */
       1172 +      public static class HighPerformanceCache<K, V> {
       1173 +          
       1174 +          // 核心存储: 线程安全的HashMap
       1175 +          private final ConcurrentHashMap<K, CacheEntry<V>> cache;
       1176 +          
       1177 +          // 读写锁: 读操作并发，写操作互斥
       1178 +          private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
       1179 +          
       1180 +          // 原子计数器: 线程安全的统计信息
       1181 +          private final AtomicLong hitCount = new AtomicLong(0);
       1182 +          private final AtomicLong missCount = new AtomicLong(0);
       1183 +          private final AtomicLong evictionCount = new AtomicLong(0);
       1184 +          
       1185 +          // volatile配置: 保证可见性
       1186 +          private volatile int maxSize;
       1187 +          private volatile long defaultTtl;
       1188 +          
       1189 +          // 定时清理服务
       1190 +          private final ScheduledExecutorService cleanupService;
       1191 +          
       1192 +          // 缓存条目
       1193 +          private static class CacheEntry<V> {
       1194 +              final V value;
       1195 +              final long createTime;
       1196 +              final long ttl;
       1197 +              volatile long lastAccessTime;  // volatile保证访问时间可见性
       1198 +              
       1199 +              CacheEntry(V value, long ttl) {
       1200 +                  this.value = value;
       1201 +                  this.createTime = System.currentTimeMillis();
       1202 +                  this.ttl = ttl;
       1203 +                  this.lastAccessTime = createTime;
       1204 +              }
       1205 +              
       1206 +              boolean isExpired() {
       1207 +                  return ttl > 0 && (System.currentTimeMillis() - createTime) > ttl;
       1208 +              }
       1209 +              
       1210 +              void updateAccessTime() {
       1211 +                  this.lastAccessTime = System.currentTimeMillis();
       1212 +              }
       1213 +          }
       1214 +          
       1215 +          public HighPerformanceCache(int maxSize, long defaultTtl) {
       1216 +              this.cache = new ConcurrentHashMap<>(maxSize);
       1217 +              this.maxSize = maxSize;
       1218 +              this.defaultTtl = defaultTtl;
       1219 +              this.cleanupService = Executors.newSingleThreadScheduledExecutor(r -> {
       1220 +                  Thread t = new Thread(r, "CacheCleanup");
       1221 +                  t.setDaemon(true);  // 守护线程
       1222 +                  return t;
       1223 +              });
       1224 +              
       1225 +              // 启动定时清理任务
       1226 +              startCleanupTask();
       1227 +          }
       1228 +          
       1229 +          // TODO: 学生实现线程安全的put操作
       1230 +          public V put(K key, V value) {
       1231 +              return put(key, value, defaultTtl);
       1232 +          }
       1233 +          
       1234 +          public V put(K key, V value, long ttl) {
       1235 +              if (key == null || value == null) {
       1236 +                  throw new IllegalArgumentException("Key and value cannot be null");
       1237 +              }
       1238 +              
       1239 +              // 检查容量限制 (需要同步保证一致性)
       1240 +              synchronized (this) {  // 使用synchronized保证原子性
       1241 +                  if (cache.size() >= maxSize && !cache.containsKey(key)) {
       1242 +                      evictLRUEntry();  // 驱逐最少使用的条目
       1243 +                  }
       1244 +              }
       1245 +              
       1246 +              CacheEntry<V> newEntry = new CacheEntry<>(value, ttl);
       1247 +              CacheEntry<V> oldEntry = cache.put(key, newEntry);
       1248 +              
       1249 +              return oldEntry != null ? oldEntry.value : null;
       1250 +          }
       1251 +          
       1252 +          // TODO: 学生实现读写锁优化的get操作
       1253 +          public V get(K key) {
       1254 +              if (key == null) {
       1255 +                  return null;
       1256 +              }
       1257 +              
       1258 +              // 使用读锁进行并发读取
       1259 +              rwLock.readLock().lock();
       1260 +              try {
       1261 +                  CacheEntry<V> entry = cache.get(key);
       1262 +                  
       1263 +                  if (entry == null) {
       1264 +                      missCount.incrementAndGet();  // 原子递增
       1265 +                      return null;
       1266 +                  }
       1267 +                  
       1268 +                  if (entry.isExpired()) {
       1269 +                      // 升级为写锁移除过期条目
       1270 +                      rwLock.readLock().unlock();
       1271 +                      rwLock.writeLock().lock();
       1272 +                      try {
       1273 +                          // 双重检查: 防止其他线程已经移除
       1274 +                          entry = cache.get(key);
       1275 +                          if (entry != null && entry.isExpired()) {
       1276 +                              cache.remove(key);
       1277 +                              evictionCount.incrementAndGet();
       1278 +                          }
       1279 +                          missCount.incrementAndGet();
       1280 +                          return null;
       1281 +                      } finally {
       1282 +                          rwLock.writeLock().unlock();
       1283 +                      }
       1284 +                  } else {
       1285 +                      entry.updateAccessTime();  // volatile写操作
       1286 +                      hitCount.incrementAndGet();  // 原子递增
       1287 +                      return entry.value;
       1288 +                  }
       1289 +                  
       1290 +              } finally {
       1291 +                  if (rwLock.readLock().tryLock()) {
       1292 +                      rwLock.readLock().unlock();
       1293 +                  }
       1294 +              }
       1295 +          }
       1296 +          
       1297 +          // TODO: 学生实现LRU驱逐算法
       1298 +          private void evictLRUEntry() {
       1299 +              if (cache.isEmpty()) return;
       1300 +              
       1301 +              K lruKey = null;
       1302 +              long oldestTime = Long.MAX_VALUE;
       1303 +              
       1304 +              // 找到最少使用的条目
       1305 +              for (ConcurrentHashMap.Entry<K, CacheEntry<V>> entry : cache.entrySet()) {
       1306 +                  long accessTime = entry.getValue().lastAccessTime;
       1307 +                  if (accessTime < oldestTime) {
       1308 +                      oldestTime = accessTime;
       1309 +                      lruKey = entry.getKey();
       1310 +                  }
       1311 +              }
       1312 +              
       1313 +              if (lruKey != null) {
       1314 +                  cache.remove(lruKey);
       1315 +                  evictionCount.incrementAndGet();
       1316 +              }
       1317 +          }
       1318 +          
       1319 +          // TODO: 学生实现定时清理任务
       1320 +          private void startCleanupTask() {
       1321 +              cleanupService.scheduleAtFixedRate(() -> {
       1322 +                  try {
       1323 +                      rwLock.writeLock().lock();
       1324 +                      try {
       1325 +                          // 移除所有过期条目
       1326 +                          cache.entrySet().removeIf(entry -> {
       1327 +                              if (entry.getValue().isExpired()) {
       1328 +                                  evictionCount.incrementAndGet();
       1329 +                                  return true;
       1330 +                              }
       1331 +                              return false;
       1332 +                          });
       1333 +                      } finally {
       1334 +                          rwLock.writeLock().unlock();
       1335 +                      }
       1336 +                  } catch (Exception e) {
       1337 +                      System.err.println("缓存清理异常: " + e.getMessage());
       1338 +                  }
       1339 +              }, 60, 60, TimeUnit.SECONDS);  // 每分钟清理一次
       1340 +          }
       1341 +          
       1342 +          // TODO: 学生实现批量操作 (需要synchronized保证原子性)
       1343 +          public synchronized void putAll(java.util.Map<K, V> map) {
       1344 +              for (java.util.Map.Entry<K, V> entry : map.entrySet()) {
       1345 +                  put(entry.getKey(), entry.getValue());
       1346 +              }
       1347 +          }
       1348 +          
       1349 +          public synchronized void clear() {
       1350 +              cache.clear();
       1351 +              // 重置统计计数器
       1352 +              hitCount.set(0);
       1353 +              missCount.set(0);
       1354 +              evictionCount.set(0);
       1355 +          }
       1356 +          
       1357 +          // 线程安全的统计信息获取
       1358 +          public CacheStats getStats() {
       1359 +              long hits = hitCount.get();
       1360 +              long misses = missCount.get();
       1361 +              long evictions = evictionCount.get();
       1362 +              double hitRate = hits + misses > 0 ? (double) hits / (hits + misses) : 0.0;
       1363 +              
       1364 +              return new CacheStats(hits, misses, evictions, cache.size(), hitRate);
       1365 +          }
       1366 +          
       1367 +          public void shutdown() {
       1368 +              cleanupService.shutdown();
       1369 +          }
       1370 +      }
       1371 +      
       1372 +      // 统计信息类
       1373 +      public static class CacheStats {
       1374 +          public final long hitCount;
       1375 +          public final long missCount;
       1376 +          public final long evictionCount;
       1377 +          public final int currentSize;
       1378 +          public final double hitRate;
       1379 +          
       1380 +          CacheStats(long hitCount, long missCount, long evictionCount, int currentSize, double 
            + hitRate) {
       1381 +              this.hitCount = hitCount;
       1382 +              this.missCount = missCount;
       1383 +              this.evictionCount = evictionCount;
       1384 +              this.currentSize = currentSize;
       1385 +              this.hitRate = hitRate;
       1386 +          }
       1387 +          
       1388 +          @Override
       1389 +          public String toString() {
       1390 +              return String.format(
       1391 +                  "CacheStats{hits=%d, misses=%d, evictions=%d, size=%d, hitRate=%.2f%%}",
       1392 +                  hitCount, missCount, evictionCount, currentSize, hitRate * 100
       1393 +              );
       1394 +          }
       1395 +      }
       1396 +      
       1397 +      // TODO: 学生实现并发压力测试
       1398 +      public static void main(String[] args) throws InterruptedException {
       1399 +          System.out.println("=== 企业级线程安全缓存系统测试 ===");
       1400 +          
       1401 +          HighPerformanceCache<String, String> cache = new HighPerformanceCache<>(1000, 5000);
       1402 +          
       1403 +          // 并发测试
       1404 +          final int THREAD_COUNT = 20;
       1405 +          final int OPERATIONS_PER_THREAD = 1000;
       1406 +          
       1407 +          Thread[] threads = new Thread[THREAD_COUNT];
       1408 +          
       1409 +          // 创建并发读写测试
       1410 +          for (int i = 0; i < THREAD_COUNT; i++) {
       1411 +              final int threadId = i;
       1412 +              threads[i] = new Thread(() -> {
       1413 +                  for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
       1414 +                      String key = "key_" + (threadId * OPERATIONS_PER_THREAD + j);
       1415 +                      String value = "value_" + threadId + "_" + j;
       1416 +                      
       1417 +                      // 写操作
       1418 +                      cache.put(key, value);
       1419 +                      
       1420 +                      // 读操作
       1421 +                      String retrieved = cache.get(key);
       1422 +                      
       1423 +                      // 验证数据一致性
       1424 +                      if (!value.equals(retrieved)) {
       1425 +                          System.err.println("数据不一致! 期望: " + value + ", 实际: " + retrieved);
       1426 +                      }
       1427 +                      
       1428 +                      // 随机读取已存在的数据
       1429 +                      if (j > 100) {
       1430 +                          String randomKey = "key_" + (threadId * OPERATIONS_PER_THREAD + j - 50);
       1431 +                          cache.get(randomKey);
       1432 +                      }
       1433 +                  }
       1434 +              }, "TestThread-" + i);
       1435 +          }
       1436 +          
       1437 +          long startTime = System.currentTimeMillis();
       1438 +          
       1439 +          // 启动所有测试线程
       1440 +          for (Thread thread : threads) {
       1441 +              thread.start();
       1442 +          }
       1443 +          
       1444 +          // 等待所有线程完成
       1445 +          for (Thread thread : threads) {
       1446 +              thread.join();
       1447 +          }
       1448 +          
       1449 +          long endTime = System.currentTimeMillis();
       1450 +          
       1451 +          // 输出测试结果
       1452 +          System.out.println("并发测试完成!");
       1453 +          System.out.println("总操作数: " + (THREAD_COUNT * OPERATIONS_PER_THREAD * 2)); // 读+写
       1454 +          System.out.println("执行时间: " + (endTime - startTime) + "ms");
       1455 +          System.out.println("缓存统计: " + cache.getStats());
       1456 +          
       1457 +          // 测试缓存功能
       1458 +          testCacheFeatures(cache);
       1459 +          
       1460 +          cache.shutdown();
       1461 +      }
       1462 +      
       1463 +      private static void testCacheFeatures(HighPerformanceCache<String, String> cache) throws 
            + InterruptedException {
       1464 +          System.out.println("\n=== 缓存功能测试 ===");
       1465 +          
       1466 +          // 测试TTL过期
       1467 +          cache.put("ttl_test", "will_expire", 1000);  // 1秒后过期
       1468 +          System.out.println("TTL测试 - 立即读取: " + cache.get("ttl_test"));
       1469 +          
       1470 +          Thread.sleep(1100);  // 等待过期
       1471 +          System.out.println("TTL测试 - 过期后读取: " + cache.get("ttl_test"));
       1472 +          
       1473 +          // 测试批量操作
       1474 +          java.util.Map<String, String> batch = new java.util.HashMap<>();
       1475 +          batch.put("batch1", "value1");
       1476 +          batch.put("batch2", "value2");
       1477 +          batch.put("batch3", "value3");
       1478 +          cache.putAll(batch);
       1479 +          
       1480 +          System.out.println("批量操作测试: " + cache.get("batch2"));
       1481 +          
       1482 +          System.out.println("最终统计: " + cache.getStats());
       1483 +      }
       1484 +  }
       1485 +  ```
       1486 +  
       1487 +  **📝 编程任务检查点**:
       1488 +  - [ ] **架构设计**: 使用合适的并发原语解决不同场景的问题
       1489 +  - [ ] **性能优化**: 读写锁提升读性能，原子计数器减少锁竞争
       1490 +  - [ ] **数据一致性**: 在高并发场景下保证数据正确性
       1491 +  - [ ] **功能完整性**: TTL过期、LRU驱逐、统计监控等企业级功能
       1492 +  - [ ] **代码质量**: 异常处理、资源管理、线程安全性
       1493 +  - [ ] **压力测试**: 多线程并发测试验证系统稳定性
       1494 +  
       1495 +  #### Task 1.1.9: 性能基准测试框架 (10分钟) ⏰
       1496 +  
       1497 +  **🎯 项目目标**: 创建专业的并发性能测试框架
       1498 +  - **测试维度**: 吞吐量、延迟、可扩展性、稳定性  
       1499 +  - **对比分析**: synchronized vs volatile vs CAS vs 无锁算法
       1500 +  
       1501 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
       1502 +  ```java
       1503 +  import java.util.concurrent.*;
       1504 +  import java.util.concurrent.atomic.AtomicLong;
       1505 +  import java.util.concurrent.atomic.LongAdder;
       1506 +  import java.util.List;
       1507 +  import java.util.ArrayList;
       1508 +  import java.util.concurrent.locks.ReentrantLock;
       1509 +  
       1510 +  // 练习目标: 构建专业的并发性能基准测试框架
       1511 +  public class ConcurrencyPerformanceBenchmark {
       1512 +      
       1513 +      /**
       1514 +       * 性能测试框架
       1515 +       * 测试不同并发原语在各种场景下的性能表现
       1516 +       */
       1517 +      public static class BenchmarkSuite {
       1518 +          
       1519 +          private final int warmupIterations = 3;
       1520 +          private final int benchmarkIterations = 5;
       1521 +          
       1522 +          // 测试场景定义
       1523 +          public interface BenchmarkTask {
       1524 +              void execute(int threadCount, int operationsPerThread) throws InterruptedException;
       1525 +              String getName();
       1526 +          }
       1527 +          
       1528 +          // 性能测试结果
       1529 +          public static class BenchmarkResult {
       1530 +              final String testName;
       1531 +              final int threadCount;
       1532 +              final long totalOperations;
       1533 +              final long executionTimeMs;
       1534 +              final double throughputOpsPerSec;
       1535 +              final double avgLatencyNs;
       1536 +              
       1537 +              BenchmarkResult(String testName, int threadCount, long totalOperations, 
       1538 +                            long executionTimeMs, double avgLatencyNs) {
       1539 +                  this.testName = testName;
       1540 +                  this.threadCount = threadCount;
       1541 +                  this.totalOperations = totalOperations;
       1542 +                  this.executionTimeMs = executionTimeMs;
       1543 +                  this.throughputOpsPerSec = (double) totalOperations / executionTimeMs * 1000;
       1544 +                  this.avgLatencyNs = avgLatencyNs;
       1545 +              }
       1546 +              
       1547 +              @Override
       1548 +              public String toString() {
       1549 +                  return String.format("%s [线程数=%d]: 吞吐量=%.0f ops/sec, 平均延迟=%.2f ns, 
            + 总时间=%d ms",
       1550 +                      testName, threadCount, throughputOpsPerSec, avgLatencyNs, executionTimeMs);
       1551 +              }
       1552 +          }
       1553 +          
       1554 +          // TODO: 学生实现性能测试执行器
       1555 +          public List<BenchmarkResult> runBenchmark(BenchmarkTask task, int[] threadCounts, int 
            + operationsPerThread) {
       1556 +              List<BenchmarkResult> results = new ArrayList<>();
       1557 +              
       1558 +              System.out.println("\n=== 开始基准测试: " + task.getName() + " ===");
       1559 +              
       1560 +              for (int threadCount : threadCounts) {
       1561 +                  System.out.println("预热阶段 - 线程数: " + threadCount);
       1562 +                  
       1563 +                  // 预热阶段
       1564 +                  for (int i = 0; i < warmupIterations; i++) {
       1565 +                      try {
       1566 +                          task.execute(threadCount, operationsPerThread / 10);  // 预热用较少操作
       1567 +                      } catch (InterruptedException e) {
       1568 +                          Thread.currentThread().interrupt();
       1569 +                          return results;
       1570 +                      }
       1571 +                  }
       1572 +                  
       1573 +                  System.out.println("正式测试 - 线程数: " + threadCount);
       1574 +                  
       1575 +                  // 正式测试
       1576 +                  long totalTime = 0;
       1577 +                  long totalLatency = 0;
       1578 +                  int validRuns = 0;
       1579 +                  
       1580 +                  for (int i = 0; i < benchmarkIterations; i++) {
       1581 +                      try {
       1582 +                          long startTime = System.nanoTime();
       1583 +                          task.execute(threadCount, operationsPerThread);
       1584 +                          long endTime = System.nanoTime();
       1585 +                          
       1586 +                          long runTime = (endTime - startTime) / 1_000_000;  // 转换为毫秒
       1587 +                          totalTime += runTime;
       1588 +                          totalLatency += (endTime - startTime) / (threadCount * operationsPerThread);
       1589 +                          validRuns++;
       1590 +                          
       1591 +                      } catch (InterruptedException e) {
       1592 +                          Thread.currentThread().interrupt();
       1593 +                          break;
       1594 +                      }
       1595 +                  }
       1596 +                  
       1597 +                  if (validRuns > 0) {
       1598 +                      long avgTimeMs = totalTime / validRuns;
       1599 +                      double avgLatencyNs = (double) totalLatency / validRuns;
       1600 +                      long totalOps = (long) threadCount * operationsPerThread;
       1601 +                      
       1602 +                      BenchmarkResult result = new BenchmarkResult(
       1603 +                          task.getName(), threadCount, totalOps, avgTimeMs, avgLatencyNs);
       1604 +                      
       1605 +                      results.add(result);
       1606 +                      System.out.println("  " + result);
       1607 +                  }
       1608 +              }
       1609 +              
       1610 +              return results;
       1611 +          }
       1612 +      }
       1613 +      
       1614 +      // TODO: 学生实现各种并发原语的性能测试
       1615 +      
       1616 +      // 测试1: synchronized性能
       1617 +      static class SynchronizedCounterTask implements BenchmarkSuite.BenchmarkTask {
       1618 +          @Override
       1619 +          public void execute(int threadCount, int operationsPerThread) throws InterruptedException {
       1620 +              final Object lock = new Object();
       1621 +              final int[] counter = {0};
       1622 +              
       1623 +              CountDownLatch latch = new CountDownLatch(threadCount);
       1624 +              
       1625 +              for (int i = 0; i < threadCount; i++) {
       1626 +                  new Thread(() -> {
       1627 +                      try {
       1628 +                          for (int j = 0; j < operationsPerThread; j++) {
       1629 +                              synchronized (lock) {
       1630 +                                  counter[0]++;
       1631 +                              }
       1632 +                          }
       1633 +                      } finally {
       1634 +                          latch.countDown();
       1635 +                      }
       1636 +                  }).start();
       1637 +              }
       1638 +              
       1639 +              latch.await();
       1640 +          }
       1641 +          
       1642 +          @Override
       1643 +          public String getName() {
       1644 +              return "Synchronized计数器";
       1645 +          }
       1646 +      }
       1647 +      
       1648 +      // 测试2: AtomicLong性能
       1649 +      static class AtomicCounterTask implements BenchmarkSuite.BenchmarkTask {
       1650 +          @Override
       1651 +          public void execute(int threadCount, int operationsPerThread) throws InterruptedException {
       1652 +              AtomicLong counter = new AtomicLong(0);
       1653 +              CountDownLatch latch = new CountDownLatch(threadCount);
       1654 +              
       1655 +              for (int i = 0; i < threadCount; i++) {
       1656 +                  new Thread(() -> {
       1657 +                      try {
       1658 +                          for (int j = 0; j < operationsPerThread; j++) {
       1659 +                              counter.incrementAndGet();
       1660 +                          }
       1661 +                      } finally {
       1662 +                          latch.countDown();
       1663 +                      }
       1664 +                  }).start();
       1665 +              }
       1666 +              
       1667 +              latch.await();
       1668 +          }
       1669 +          
       1670 +          @Override
       1671 +          public String getName() {
       1672 +              return "AtomicLong计数器";
       1673 +          }
       1674 +      }
       1675 +      
       1676 +      // 测试3: LongAdder性能 (高并发优化)
       1677 +      static class LongAdderCounterTask implements BenchmarkSuite.BenchmarkTask {
       1678 +          @Override
       1679 +          public void execute(int threadCount, int operationsPerThread) throws InterruptedException {
       1680 +              LongAdder counter = new LongAdder();
       1681 +              CountDownLatch latch = new CountDownLatch(threadCount);
       1682 +              
       1683 +              for (int i = 0; i < threadCount; i++) {
       1684 +                  new Thread(() -> {
       1685 +                      try {
       1686 +                          for (int j = 0; j < operationsPerThread; j++) {
       1687 +                              counter.increment();
       1688 +                          }
       1689 +                      } finally {
       1690 +                          latch.countDown();
       1691 +                      }
       1692 +                  }).start();
       1693 +              }
       1694 +              
       1695 +              latch.await();
       1696 +          }
       1697 +          
       1698 +          @Override
       1699 +          public String getName() {
       1700 +              return "LongAdder计数器";
       1701 +          }
       1702 +      }
       1703 +      
       1704 +      // 测试4: ReentrantLock性能
       1705 +      static class ReentrantLockCounterTask implements BenchmarkSuite.BenchmarkTask {
       1706 +          @Override
       1707 +          public void execute(int threadCount, int operationsPerThread) throws InterruptedException {
       1708 +              ReentrantLock lock = new ReentrantLock();
       1709 +              final int[] counter = {0};
       1710 +              CountDownLatch latch = new CountDownLatch(threadCount);
       1711 +              
       1712 +              for (int i = 0; i < threadCount; i++) {
       1713 +                  new Thread(() -> {
       1714 +                      try {
       1715 +                          for (int j = 0; j < operationsPerThread; j++) {
       1716 +                              lock.lock();
       1717 +                              try {
       1718 +                                  counter[0]++;
       1719 +                              } finally {
       1720 +                                  lock.unlock();
       1721 +                              }
       1722 +                          }
       1723 +                      } finally {
       1724 +                          latch.countDown();
       1725 +                      }
       1726 +                  }).start();
       1727 +              }
       1728 +              
       1729 +              latch.await();
       1730 +          }
       1731 +          
       1732 +          @Override
       1733 +          public String getName() {
       1734 +              return "ReentrantLock计数器";
       1735 +          }
       1736 +      }
       1737 +      
       1738 +      // 测试5: volatile读写性能
       1739 +      static class VolatileReadWriteTask implements BenchmarkSuite.BenchmarkTask {
       1740 +          @Override
       1741 +          public void execute(int threadCount, int operationsPerThread) throws InterruptedException {
       1742 +              volatile long value = 0;
       1743 +              CountDownLatch latch = new CountDownLatch(threadCount);
       1744 +              
       1745 +              for (int i = 0; i < threadCount; i++) {
       1746 +                  final int threadId = i;
       1747 +                  new Thread(() -> {
       1748 +                      try {
       1749 +                          for (int j = 0; j < operationsPerThread; j++) {
       1750 +                              if (threadId % 2 == 0) {
       1751 +                                  // 50%的线程进行写操作
       1752 +                                  value = j;
       1753 +                              } else {
       1754 +                                  // 50%的线程进行读操作
       1755 +                                  long temp = value;
       1756 +                              }
       1757 +                          }
       1758 +                      } finally {
       1759 +                          latch.countDown();
       1760 +                      }
       1761 +                  }).start();
       1762 +              }
       1763 +              
       1764 +              latch.await();
       1765 +          }
       1766 +          
       1767 +          @Override
       1768 +          public String getName() {
       1769 +              return "Volatile读写操作";
       1770 +          }
       1771 +      }
       1772 +      
       1773 +      // TODO: 学生实现主测试方法
       1774 +      public static void main(String[] args) {
       1775 +          BenchmarkSuite suite = new BenchmarkSuite();
       1776 +          
       1777 +          // 测试配置
       1778 +          int[] threadCounts = {1, 2, 4, 8, 16, 32};
       1779 +          int operationsPerThread = 100_000;
       1780 +          
       1781 +          // 所有测试任务
       1782 +          BenchmarkSuite.BenchmarkTask[] tasks = {
       1783 +              new SynchronizedCounterTask(),
       1784 +              new AtomicCounterTask(),
       1785 +              new LongAdderCounterTask(),
       1786 +              new ReentrantLockCounterTask(),
       1787 +              new VolatileReadWriteTask()
       1788 +          };
       1789 +          
       1790 +          // 收集所有结果
       1791 +          List<List<BenchmarkSuite.BenchmarkResult>> allResults = new ArrayList<>();
       1792 +          
       1793 +          for (BenchmarkSuite.BenchmarkTask task : tasks) {
       1794 +              List<BenchmarkSuite.BenchmarkResult> results = suite.runBenchmark(task, threadCounts, 
            + operationsPerThread);
       1795 +              allResults.add(results);
       1796 +          }
       1797 +          
       1798 +          // 生成性能对比报告
       1799 +          generatePerformanceReport(allResults, threadCounts);
       1800 +      }
       1801 +      
       1802 +      // TODO: 学生实现性能报告生成
       1803 +      private static void generatePerformanceReport(List<List<BenchmarkSuite.BenchmarkResult>> 
            + allResults, int[] threadCounts) {
       1804 +          System.out.println("\n" + "=".repeat(80));
       1805 +          System.out.println("                         性能基准测试报告");
       1806 +          System.out.println("=".repeat(80));
       1807 +          
       1808 +          // 按线程数生成对比表格
       1809 +          for (int threadCount : threadCounts) {
       1810 +              System.out.println(String.format("\n线程数: %d", threadCount));
       1811 +              System.out.println("-".repeat(70));
       1812 +              System.out.printf("%-20s %-15s %-15s %-15s%n", "测试类型", "吞吐量(ops/sec)", 
            + "平均延迟(ns)", "相对性能");
       1813 +              System.out.println("-".repeat(70));
       1814 +              
       1815 +              double maxThroughput = 0;
       1816 +              List<BenchmarkSuite.BenchmarkResult> threadResults = new ArrayList<>();
       1817 +              
       1818 +              // 收集同线程数的所有结果
       1819 +              for (List<BenchmarkSuite.BenchmarkResult> results : allResults) {
       1820 +                  for (BenchmarkSuite.BenchmarkResult result : results) {
       1821 +                      if (result.threadCount == threadCount) {
       1822 +                          threadResults.add(result);
       1823 +                          maxThroughput = Math.max(maxThroughput, result.throughputOpsPerSec);
       1824 +                      }
       1825 +                  }
       1826 +              }
       1827 +              
       1828 +              // 输出对比结果
       1829 +              for (BenchmarkSuite.BenchmarkResult result : threadResults) {
       1830 +                  double relativePerf = result.throughputOpsPerSec / maxThroughput;
       1831 +                  System.out.printf("%-20s %-15.0f %-15.2f %-15.2f%%\n",
       1832 +                      result.testName,
       1833 +                      result.throughputOpsPerSec,
       1834 +                      result.avgLatencyNs,
       1835 +                      relativePerf * 100);
       1836 +              }
       1837 +          }
       1838 +          
       1839 +          // 生成可扩展性分析
       1840 +          System.out.println("\n" + "=".repeat(80));
       1841 +          System.out.println("                         可扩展性分析");
       1842 +          System.out.println("=".repeat(80));
       1843 +          
       1844 +          for (List<BenchmarkSuite.BenchmarkResult> results : allResults) {
       1845 +              if (!results.isEmpty()) {
       1846 +                  String testName = results.get(0).testName;
       1847 +                  System.out.println("\n" + testName + " 可扩展性:");
       1848 +                  
       1849 +                  double singleThreadThroughput = results.get(0).throughputOpsPerSec;
       1850 +                  
       1851 +                  for (BenchmarkSuite.BenchmarkResult result : results) {
       1852 +                      double scalingEfficiency = result.throughputOpsPerSec / singleThreadThroughput / 
            + result.threadCount;
       1853 +                      System.out.printf("  %d线程: %.2fx speedup, %.2f%% 扩展效率\n",
       1854 +                          result.threadCount,
       1855 +                          result.throughputOpsPerSec / singleThreadThroughput,
       1856 +                          scalingEfficiency * 100);
       1857 +                  }
       1858 +              }
       1859 +          }
       1860 +          
       1861 +          // 总结和建议
       1862 +          System.out.println("\n" + "=".repeat(80));
       1863 +          System.out.println("                         性能优化建议");
       1864 +          System.out.println("=".repeat(80));
       1865 +          System.out.println("1. 低竞争场景: 优先使用volatile，性能最佳");
       1866 +          System.out.println("2. 中等竞争场景: AtomicLong提供良好的性能与安全性平衡");
       1867 +          System.out.println("3. 高竞争场景: LongAdder在多核环境下扩展性最好");
       1868 +          System.out.println("4. 复杂同步: synchronized简单易用，ReentrantLock功能更强");
       1869 +          System.out.println("5. 读多写少: 考虑使用ReadWriteLock优化读性能");
       1870 +      }
       1871 +  }
       1872 +  ```
       1873 +  
       1874 +  **📝 编程任务检查点**:
       1875 +  - [ ] **基准测试**: 实现科学的性能测试方法(预热、多次测试、统计分析)
       1876 +  - [ ] **多维度对比**: 吞吐量、延迟、可扩展性全面评估
       1877 +  - [ ] **场景覆盖**: 不同并发度下的性能表现对比
       1878 +  - [ ] **数据分析**: 生成专业的性能报告和优化建议
       1879 +  - [ ] **代码质量**: 测试框架的可扩展性和重用性
       1880 +  
       1881 +  #### Task 1.1.10: 综合项目 - 分布式锁实现 (10分钟) ⏰
       1882 +  
       1883 +  **🎯 最终项目目标**: 实现生产级分布式锁系统
       1884 +  - **技术栈**: 所有学过的并发原语 + 网络编程
       1885 +  - **业务场景**: 微服务架构下的分布式同步
       1886 +  - **代码规模**: 300+行企业级实现
       1887 +  
       1888 +  **🚀 Hands-On Coding Exercise (强制编程练习)**
       1889 +  ```java
       1890 +  import java.util.concurrent.*;
       1891 +  import java.util.concurrent.atomic.AtomicBoolean;
       1892 +  import java.util.concurrent.atomic.AtomicReference;
       1893 +  import java.util.concurrent.locks.LockSupport;
       1894 +  import java.util.UUID;
       1895 +  import java.util.Map;
       1896 +  
       1897 +  // 练习目标: 实现企业级分布式锁系统
       1898 +  public class DistributedLockSystem {
       1899 +      
       1900 +      /**
       1901 +       * 基于内存的分布式锁实现 (模拟Redis/Zookeeper)
       1902 +       * 核心技术:
       1903 +       * 1. ConcurrentHashMap存储锁信息
       1904 +       * 2. 原子操作保证获锁/释锁的原子性
       1905 +       * 3. volatile保证锁状态可见性
       1906 +       * 4. 超时机制防止死锁
       1907 +       * 5. 重入锁支持
       1908 +       * 6. 公平锁队列
       1909 +       */
       1910 +      public static class DistributedLock {
       1911 +          
       1912 +          // 锁信息存储
       1913 +          private final ConcurrentHashMap<String, LockInfo> locks = new ConcurrentHashMap<>();
       1914 +          
       1915 +          // 等待队列 (公平锁)
       1916 +          private final ConcurrentHashMap<String, ConcurrentLinkedQueue<LockWaiter>> waitQueues = new 
            + ConcurrentHashMap<>();
       1917 +          
       1918 +          // 锁清理服务
       1919 +          private final ScheduledExecutorService cleanupService;
       1920 +          
       1921 +          // 锁信息
       1922 +          private static class LockInfo {
       1923 +              final String lockId;
       1924 +              final String ownerId;
       1925 +              final long createTime;
       1926 +              final long ttl;
       1927 +              volatile int reentrantCount;  // 重入次数
       1928 +              
       1929 +              LockInfo(String lockId, String ownerId, long ttl) {
       1930 +                  this.lockId = lockId;
       1931 +                  this.ownerId = ownerId;
       1932 +                  this.createTime = System.currentTimeMillis();
       1933 +                  this.ttl = ttl;
       1934 +                  this.reentrantCount = 1;
       1935 +              }
       1936 +              
       1937 +              boolean isExpired() {
       1938 +                  return ttl > 0 && (System.currentTimeMillis() - createTime) > ttl;
       1939 +              }
       1940 +              
       1941 +              boolean isOwnedBy(String ownerId) {
       1942 +                  return this.ownerId.equals(ownerId);
       1943 +              }
       1944 +          }
       1945 +          
       1946 +          // 等待者信息
       1947 +          private static class LockWaiter {
       1948 +              final String ownerId;
       1949 +              final CountDownLatch latch;
       1950 +              final long waitStartTime;
       1951 +              volatile boolean cancelled = false;
       1952 +              
       1953 +              LockWaiter(String ownerId) {
       1954 +                  this.ownerId = ownerId;
       1955 +                  this.latch = new CountDownLatch(1);
       1956 +                  this.waitStartTime = System.currentTimeMillis();
       1957 +              }
       1958 +          }
       1959 +          
       1960 +          public DistributedLock() {
       1961 +              this.cleanupService = Executors.newSingleThreadScheduledExecutor(r -> {
       1962 +                  Thread t = new Thread(r, "DistributedLock-Cleanup");
       1963 +                  t.setDaemon(true);
       1964 +                  return t;
       1965 +              });
       1966 +              
       1967 +              // 启动过期锁清理任务
       1968 +              startCleanupTask();
       1969 +          }
       1970 +          
       1971 +          // TODO: 学生实现分布式锁获取
       1972 +          public boolean tryLock(String lockKey, String ownerId, long ttlMs) {
       1973 +              if (lockKey == null || ownerId == null) {
       1974 +                  throw new IllegalArgumentException("LockKey and ownerId cannot be null");
       1975 +              }
       1976 +              
       1977 +              // 原子操作: 尝试获取锁
       1978 +              LockInfo existingLock = locks.get(lockKey);
       1979 +              
       1980 +              if (existingLock == null) {
       1981 +                  // 锁不存在，尝试获取
       1982 +                  LockInfo newLock = new LockInfo(lockKey, ownerId, ttlMs);
       1983 +                  LockInfo prevLock = locks.putIfAbsent(lockKey, newLock);
       1984 +                  
       1985 +                  if (prevLock == null) {
       1986 +                      // 成功获取锁
       1987 +                      notifyNextWaiter(lockKey);  // 这里不会有等待者，但保持一致性
       1988 +                      return true;
       1989 +                  } else {
       1990 +                      // 其他线程抢先获取了锁
       1991 +                      existingLock = prevLock;
       1992 +                  }
       1993 +              }
       1994 +              
       1995 +              // 检查重入锁
       1996 +              if (existingLock.isOwnedBy(ownerId) && !existingLock.isExpired()) {
       1997 +                  // 重入锁: 同一个owner可以多次获取
       1998 +                  synchronized (existingLock) {  // 同步保证重入计数的原子性
       1999 +                      if (existingLock.isOwnedBy(ownerId) && !existingLock.isExpired()) {
       2000 +                          existingLock.reentrantCount++;
       2001 +                          return true;
       2002 +                      }
       2003 +                  }
       2004 +              }
       2005 +              
       2006 +              // 检查锁是否过期
       2007 +              if (existingLock.isExpired()) {
       2008 +                  // 原子地移除过期锁并重试
       2009 +                  if (locks.remove(lockKey, existingLock)) {
       2010 +                      return tryLock(lockKey, ownerId, ttlMs);  // 递归重试
       2011 +                  }
       2012 +              }
       2013 +              
       2014 +              return false;  // 获取锁失败
       2015 +          }
       2016 +          
       2017 +          // TODO: 学生实现阻塞式锁获取
       2018 +          public boolean lock(String lockKey, String ownerId, long ttlMs, long timeoutMs) 
       2019 +                  throws InterruptedException {
       2020 +              
       2021 +              long startTime = System.currentTimeMillis();
       2022 +              
       2023 +              // 先尝试非阻塞获取
       2024 +              if (tryLock(lockKey, ownerId, ttlMs)) {
       2025 +                  return true;
       2026 +              }
       2027 +              
       2028 +              if (timeoutMs <= 0) {
       2029 +                  return false;  // 不等待
       2030 +              }
       2031 +              
       2032 +              // 加入等待队列
       2033 +              ConcurrentLinkedQueue<LockWaiter> waitQueue = waitQueues.computeIfAbsent(
       2034 +                  lockKey, k -> new ConcurrentLinkedQueue<>());
       2035 +              
       2036 +              LockWaiter waiter = new LockWaiter(ownerId);
       2037 +              waitQueue.offer(waiter);
       2038 +              
       2039 +              try {
       2040 +                  while (System.currentTimeMillis() - startTime < timeoutMs) {
       2041 +                      // 计算剩余等待时间
       2042 +                      long remainingTime = timeoutMs - (System.currentTimeMillis() - startTime);
       2043 +                      if (remainingTime <= 0) {
       2044 +                          break;
       2045 +                      }
       2046 +                      
       2047 +                      // 等待被唤醒或超时
       2048 +                      boolean signaled = waiter.latch.await(remainingTime, TimeUnit.MILLISECONDS);
       2049 +                      
       2050 +                      if (waiter.cancelled) {
       2051 +                          return false;  // 被取消
       2052 +                      }
       2053 +                      
       2054 +                      // 被唤醒后尝试获取锁
       2055 +                      if (signaled && tryLock(lockKey, ownerId, ttlMs)) {
       2056 +                          return true;
       2057 +                      }
       2058 +                      
       2059 +                      // 如果没有被信号唤醒，可能是虚假唤醒，继续等待
       2060 +                  }
       2061 +                  
       2062 +                  return false;  // 超时
       2063 +                  
       2064 +              } finally {
       2065 +                  // 清理等待队列
       2066 +                  waiter.cancelled = true;
       2067 +                  waitQueue.remove(waiter);
       2068 +                  if (waitQueue.isEmpty()) {
       2069 +                      waitQueues.remove(lockKey);
       2070 +                  }
       2071 +              }
       2072 +          }
       2073 +          
       2074 +          // TODO: 学生实现锁释放
       2075 +          public boolean unlock(String lockKey, String ownerId) {
       2076 +              if (lockKey == null || ownerId == null) {
       2077 +                  return false;
       2078 +              }
       2079 +              
       2080 +              LockInfo lockInfo = locks.get(lockKey);
       2081 +              if (lockInfo == null || !lockInfo.isOwnedBy(ownerId)) {
       2082 +                  return false;  // 锁不存在或不是当前owner
       2083 +              }
       2084 +              
       2085 +              synchronized (lockInfo) {  // 同步保证重入计数的原子性
       2086 +                  if (!lockInfo.isOwnedBy(ownerId)) {
       2087 +                      return false;  // 双重检查
       2088 +                  }
       2089 +                  
       2090 +                  lockInfo.reentrantCount--;
       2091 +                  
       2092 +                  if (lockInfo.reentrantCount <= 0) {
       2093 +                      // 完全释放锁
       2094 +                      if (locks.remove(lockKey, lockInfo)) {
       2095 +                          // 唤醒下一个等待者
       2096 +                          notifyNextWaiter(lockKey);
       2097 +                          return true;
       2098 +                      }
       2099 +                  } else {
       2100 +                      // 减少重入计数但保持锁
       2101 +                      return true;
       2102 +                  }
       2103 +              }
       2104 +              
       2105 +              return false;
       2106 +          }
       2107 +          
       2108 +          // TODO: 学生实现公平锁队列通知
       2109 +          private void notifyNextWaiter(String lockKey) {
       2110 +              ConcurrentLinkedQueue<LockWaiter> waitQueue = waitQueues.get(lockKey);
       2111 +              if (waitQueue != null) {
       2112 +                  LockWaiter nextWaiter;
       2113 +                  
       2114 +                  // 找到下一个有效的等待者
       2115 +                  while ((nextWaiter = waitQueue.poll()) != null) {
       2116 +                      if (!nextWaiter.cancelled) {
       2117 +                          nextWaiter.latch.countDown();  // 唤醒等待者
       2118 +                          break;
       2119 +                      }
       2120 +                  }
       2121 +                  
       2122 +                  // 如果队列为空，移除它
       2123 +                  if (waitQueue.isEmpty()) {
       2124 +                      waitQueues.remove(lockKey);
       2125 +                  }
       2126 +              }
       2127 +          }
       2128 +          
       2129 +          // TODO: 学生实现锁续期 (防止业务逻辑执行时间过长导致锁过期)
       2130 +          public boolean renewLock(String lockKey, String ownerId, long newTtlMs) {
       2131 +              LockInfo lockInfo = locks.get(lockKey);
       2132 +              if (lockInfo == null || !lockInfo.isOwnedBy(ownerId) || lockInfo.isExpired()) {
       2133 +                  return false;
       2134 +              }
       2135 +              
       2136 +              // 创建新的锁信息 (更新TTL)
       2137 +              LockInfo newLockInfo = new LockInfo(lockKey, ownerId, newTtlMs);
       2138 +              newLockInfo.reentrantCount = lockInfo.reentrantCount;
       2139 +              
       2140 +              return locks.replace(lockKey, lockInfo, newLockInfo);
       2141 +          }
       2142 +          
       2143 +          // TODO: 学生实现锁清理任务
       2144 +          private void startCleanupTask() {
       2145 +              cleanupService.scheduleAtFixedRate(() -> {
       2146 +                  try {
       2147 +                      // 清理过期锁
       2148 +                      locks.entrySet().removeIf(entry -> {
       2149 +                          LockInfo lockInfo = entry.getValue();
       2150 +                          if (lockInfo.isExpired()) {
       2151 +                              String lockKey = entry.getKey();
       2152 +                              System.out.println("清理过期锁: " + lockKey);
       2153 +                              
       2154 +                              // 通知等待者
       2155 +                              notifyNextWaiter(lockKey);
       2156 +                              return true;
       2157 +                          }
       2158 +                          return false;
       2159 +                      });
       2160 +                      
       2161 +                      // 清理过期的等待者
       2162 +                      waitQueues.entrySet().removeIf(entry -> {
       2163 +                          ConcurrentLinkedQueue<LockWaiter> queue = entry.getValue();
       2164 +                          queue.removeIf(waiter -> {
       2165 +                              long waitTime = System.currentTimeMillis() - waiter.waitStartTime;
       2166 +                              if (waitTime > 30000) {  // 30秒超时
       2167 +                                  waiter.cancelled = true;
       2168 +                                  waiter.latch.countDown();
       2169 +                                  return true;
       2170 +                              }
       2171 +                              return false;
       2172 +                          });
       2173 +                          return queue.isEmpty();
       2174 +                      });
       2175 +                      
       2176 +                  } catch (Exception e) {
       2177 +                      System.err.println("锁清理异常: " + e.getMessage());
       2178 +                  }
       2179 +              }, 10, 10, TimeUnit.SECONDS);  // 每10秒清理一次
       2180 +          }
       2181 +          
       2182 +          // 获取锁统计信息
       2183 +          public LockStatistics getStatistics() {
       2184 +              int totalLocks = locks.size();
       2185 +              int totalWaiters = waitQueues.values().stream()
       2186 +                  .mapToInt(ConcurrentLinkedQueue::size)
       2187 +                  .sum();
       2188 +              
       2189 +              return new LockStatistics(totalLocks, totalWaiters);
       2190 +          }
       2191 +          
       2192 +          public void shutdown() {
       2193 +              cleanupService.shutdown();
       2194 +          }
       2195 +      }
       2196 +      
       2197 +      // 锁统计信息
       2198 +      public static class LockStatistics {
       2199 +          public final int activeLocks;
       2200 +          public final int waitingThreads;
       2201 +          
       2202 +          LockStatistics(int activeLocks, int waitingThreads) {
       2203 +              this.activeLocks = activeLocks;
       2204 +              this.waitingThreads = waitingThreads;
       2205 +          }
       2206 +          
       2207 +          @Override
       2208 +          public String toString() {
       2209 +              return String.format("LockStats{activeLocks=%d, waitingThreads=%d}", 
       2210 +                  activeLocks, waitingThreads);
       2211 +          }
       2212 +      }
       2213 +      
       2214 +      // TODO: 学生实现综合测试
       2215 +      public static void main(String[] args) throws InterruptedException {
       2216 +          System.out.println("=== 分布式锁系统综合测试 ===");
       2217 +          
       2218 +          DistributedLock distributedLock = new DistributedLock();
       2219 +          
       2220 +          // 测试1: 基本功能测试
       2221 +          testBasicLockingBehavior(distributedLock);
       2222 +          
       2223 +          Thread.sleep(1000);
       2224 +          
       2225 +          // 测试2: 重入锁测试
       2226 +          testReentrantLocking(distributedLock);
       2227 +          
       2228 +          Thread.sleep(1000);
       2229 +          
       2230 +          // 测试3: 并发竞争测试
       2231 +          testConcurrentCompetition(distributedLock);
       2232 +          
       2233 +          Thread.sleep(1000);
       2234 +          
       2235 +          // 测试4: 超时和过期测试
       2236 +          testTimeoutAndExpiration(distributedLock);
       2237 +          
       2238 +          Thread.sleep(1000);
       2239 +          
       2240 +          // 测试5: 高并发压力测试
       2241 +          performStressTest(distributedLock);
       2242 +          
       2243 +          distributedLock.shutdown();
       2244 +          System.out.println("所有测试完成!");
       2245 +      }
       2246 +      
       2247 +      private static void testBasicLockingBehavior(DistributedLock lock) {
       2248 +          System.out.println("\n--- 测试1: 基本锁功能 ---");
       2249 +          
       2250 +          String lockKey = "test_lock_1";
       2251 +          String owner1 = "thread_1";
       2252 +          String owner2 = "thread_2";
       2253 +          
       2254 +          // 获取锁
       2255 +          boolean acquired = lock.tryLock(lockKey, owner1, 5000);
       2256 +          System.out.println("线程1获取锁: " + acquired);
       2257 +          
       2258 +          // 其他线程尝试获取同一个锁
       2259 +          boolean acquired2 = lock.tryLock(lockKey, owner2, 5000);
       2260 +          System.out.println("线程2获取锁: " + acquired2);
       2261 +          
       2262 +          // 释放锁
       2263 +          boolean released = lock.unlock(lockKey, owner1);
       2264 +          System.out.println("线程1释放锁: " + released);
       2265 +          
       2266 +          // 线程2现在应该能获取锁
       2267 +          boolean acquired3 = lock.tryLock(lockKey, owner2, 5000);
       2268 +          System.out.println("线程2重新获取锁: " + acquired3);
       2269 +          
       2270 +          lock.unlock(lockKey, owner2);
       2271 +      }
       2272 +      
       2273 +      private static void testReentrantLocking(DistributedLock lock) {
       2274 +          System.out.println("\n--- 测试2: 重入锁功能 ---");
       2275 +          
       2276 +          String lockKey = "reentrant_lock";
       2277 +          String owner = "reentrant_thread";
       2278 +          
       2279 +          // 多次获取同一个锁
       2280 +          System.out.println("第1次获取: " + lock.tryLock(lockKey, owner, 5000));
       2281 +          System.out.println("第2次获取: " + lock.tryLock(lockKey, owner, 5000));
       2282 +          System.out.println("第3次获取: " + lock.tryLock(lockKey, owner, 5000));
       2283 +          
       2284 +          // 需要对应次数的释放
       2285 +          System.out.println("第1次释放: " + lock.unlock(lockKey, owner));
       2286 +          System.out.println("第2次释放: " + lock.unlock(lockKey, owner));
       2287 +          
       2288 +          // 其他线程仍然无法获取
       2289 +          System.out.println("其他线程获取: " + lock.tryLock(lockKey, "other", 5000));
       2290 +          
       2291 +          // 最后一次释放
       2292 +          System.out.println("第3次释放: " + lock.unlock(lockKey, owner));
       2293 +          
       2294 +          // 现在其他线程可以获取了
       2295 +          System.out.println("其他线程获取: " + lock.tryLock(lockKey, "other", 5000));
       2296 +          lock.unlock(lockKey, "other");
       2297 +      }
       2298 +      
       2299 +      private static void testConcurrentCompetition(DistributedLock lock) throws InterruptedException 
     {
       2300 +          System.out.println("\n--- 测试3: 并发竞争测试 ---");
       2301 +          
       2302 +          String lockKey = "concurrent_lock";
       2303 +          final int THREAD_COUNT = 10;
       2304 +          final int OPERATIONS = 5;
       2305 +          CountDownLatch startLatch = new CountDownLatch(1);
       2306 +          CountDownLatch completeLatch = new CountDownLatch(THREAD_COUNT);
       2307 +          AtomicReference<String> currentHolder = new AtomicReference<>();
       2308 +          
       2309 +          for (int i = 0; i < THREAD_COUNT; i++) {
       2310 +              final String threadId = "Thread-" + i;
       2311 +              
       2312 +              new Thread(() -> {
       2313 +                  try {
       2314 +                      startLatch.await();  // 等待同时开始
       2315 +                      
       2316 +                      for (int j = 0; j < OPERATIONS; j++) {
       2317 +                          try {
       2318 +                              if (lock.lock(lockKey, threadId, 2000, 1000)) {  // 1秒超时
       2319 +                                  currentHolder.set(threadId);
       2320 +                                  System.out.println(threadId + " 获得锁，执行操作 " + (j + 1));
       2321 +                                  
       2322 +                                  // 模拟业务逻辑
       2323 +                                  Thread.sleep(100);
       2324 +                                  
       2325 +                                  lock.unlock(lockKey, threadId);
       2326 +                                  System.out.println(threadId + " 释放锁");
       2327 +                              } else {
       2328 +                                  System.out.println(threadId + " 获取锁超时");
       2329 +                              }
       2330 +                          } catch (InterruptedException e) {
       2331 +                              Thread.currentThread().interrupt();
       2332 +                              break;
       2333 +                          }
       2334 +                      }
       2335 +                  } catch (InterruptedException e) {
       2336 +                      Thread.currentThread().interrupt();
       2337 +                  } finally {
       2338 +                      completeLatch.countDown();
       2339 +                  }
       2340 +              }, threadId).start();
       2341 +          }
       2342 +          
       2343 +          startLatch.countDown();  // 开始竞争
       2344 +          completeLatch.await();   // 等待所有线程完成
       2345 +          
       2346 +          System.out.println("并发竞争测试完成，统计: " + lock.getStatistics());
       2347 +      }
       2348 +      
       2349 +      private static void testTimeoutAndExpiration(DistributedLock lock) throws InterruptedException {
       2350 +          System.out.println("\n--- 测试4: 超时和过期测试 ---");
       2351 +          
       2352 +          String lockKey = "timeout_lock";
       2353 +          String owner1 = "timeout_thread_1";
       2354 +          String owner2 = "timeout_thread_2";
       2355 +          
       2356 +          // 测试锁超时
       2357 +          System.out.println("获取短TTL锁: " + lock.tryLock(lockKey, owner1, 500));  // 0.5秒TTL
       2358 +          
       2359 +          Thread.sleep(600);  // 等待锁过期
       2360 +          
       2361 +          // 现在其他线程应该能获取锁
       2362 +          System.out.println("过期后获取锁: " + lock.tryLock(lockKey, owner2, 5000));
       2363 +          
       2364 +          // 测试等待超时
       2365 +          Thread waitingThread = new Thread(() -> {
       2366 +              try {
       2367 +                  long startTime = System.currentTimeMillis();
       2368 +                  boolean acquired = lock.lock("waiting_lock", "waiter", 5000, 1000);  // 1秒超时
       2369 +                  long endTime = System.currentTimeMillis();
       2370 +                  
       2371 +                  System.out.println("等待线程结果: " + acquired + ", 等待时间: " + (endTime - 
            + startTime) + "ms");
       2372 +              } catch (InterruptedException e) {
       2373 +                  Thread.currentThread().interrupt();
       2374 +              }
       2375 +          });
       2376 +          
       2377 +          // 先让主线程获取锁
       2378 +          lock.tryLock("waiting_lock", "main", 5000);
       2379 +          waitingThread.start();
       2380 +          
       2381 +          Thread.sleep(1500);  // 让等待线程超时
       2382 +          
       2383 +          lock.unlock("waiting_lock", "main");
       2384 +          waitingThread.join();
       2385 +          
       2386 +          lock.unlock(lockKey, owner2);
       2387 +      }
       2388 +      
       2389 +      private static void performStressTest(DistributedLock lock) throws InterruptedException {
       2390 +          System.out.println("\n--- 测试5: 高并发压力测试 ---");
       2391 +          
       2392 +          final int THREAD_COUNT = 50;
       2393 +          final int OPERATIONS_PER_THREAD = 20;
       2394 +          final String LOCK_KEY = "stress_test_lock";
       2395 +          
       2396 +          CountDownLatch startLatch = new CountDownLatch(1);
       2397 +          CountDownLatch completeLatch = new CountDownLatch(THREAD_COUNT);
       2398 +          AtomicLong successCount = new AtomicLong(0);
       2399 +          AtomicLong timeoutCount = new AtomicLong(0);
       2400 +          
       2401 +          long testStartTime = System.currentTimeMillis();
       2402 +          
       2403 +          for (int i = 0; i < THREAD_COUNT; i++) {
       2404 +              final String threadId = "StressThread-" + i;
       2405 +              
       2406 +              new Thread(() -> {
       2407 +                  try {
       2408 +                      startLatch.await();
       2409 +                      
       2410 +                      for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
       2411 +                          try {
       2412 +                              if (lock.lock(LOCK_KEY, threadId, 1000, 500)) {  // 0.5秒超时
       2413 +                                  successCount.incrementAndGet();
       2414 +                                  
       2415 +                                  // 快速业务逻辑
       2416 +                                  Thread.sleep(10);
       2417 +                                  
       2418 +                                  lock.unlock(LOCK_KEY, threadId);
       2419 +                              } else {
       2420 +                                  timeoutCount.incrementAndGet();
       2421 +                              }
       2422 +                          } catch (InterruptedException e) {
       2423 +                              Thread.currentThread().interrupt();
       2424 +                              break;
       2425 +                          }
       2426 +                      }
       2427 +                  } catch (InterruptedException e) {
       2428 +                      Thread.currentThread().interrupt();
       2429 +                  } finally {
       2430 +                      completeLatch.countDown();
       2431 +                  }
       2432 +              }, threadId).start();
       2433 +          }
       2434 +          
       2435 +          startLatch.countDown();
       2436 +          completeLatch.await();
       2437 +          
       2438 +          long testEndTime = System.currentTimeMillis();
       2439 +          long totalTime = testEndTime - testStartTime;
       2440 +          
       2441 +          System.out.println("压力测试结果:");
       2442 +          System.out.println("  总线程数: " + THREAD_COUNT);
       2443 +          System.out.println("  每线程操作数: " + OPERATIONS_PER_THREAD);
       2444 +          System.out.println("  总操作数: " + (THREAD_COUNT * OPERATIONS_PER_THREAD));
       2445 +          System.out.println("  成功获取锁: " + successCount.get());
       2446 +          System.out.println("  获取锁超时: " + timeoutCount.get());
       2447 +          System.out.println("  总耗时: " + totalTime + "ms");
       2448 +          System.out.println("  平均吞吐量: " + (successCount.get() * 1000 / totalTime) + " 
            + locks/sec");
       2449 +          System.out.println("  成功率: " + (successCount.get() * 100.0 / (THREAD_COUNT * 
            + OPERATIONS_PER_THREAD)) + "%");
       2450 +          System.out.println("  最终统计: " + lock.getStatistics());
       2451 +      }
       2452 +  }
       2453 +  ```
       2454 +  
       2455 +  **📝 编程任务检查点**:
       2456 +  - [ ] **分布式系统设计**: 理解分布式环境下的同步挑战
       2457 +  - [ ] **原子操作应用**: 正确使用CAS操作保证分布式锁的原子性
       2458 +  - [ ] **超时机制**: 实现锁超时和等待超时，防止死锁
       2459 +  - [ ] **重入锁支持**: 支持同一线程多次获取同一把锁
       2460 +  - [ ] **公平性**: 实现公平锁队列，保证先到先得
       2461 +  - [ ] **高可用性**: 过期锁清理、异常处理、资源管理
       2462 +  - [ ] **性能优化**: 在正确性基础上优化并发性能
       2463 +  - [ ] **监控统计**: 提供锁使用统计和监控能力
       2464 +  
       2465 +  **🏆 综合项目完成标准**:
       2466 +  - [ ] **功能完整**: 所有核心功能正确实现并通过测试
       2467 +  - [ ] **性能达标**: 高并发场景下的良好性能表现
       2468 +  - [ ] **代码质量**: 清晰的架构设计、完善的错误处理
       2469 +  - [ ] **面试就绪**: 能够详细解释设计思路和技术选择
       2470 +  
       2471 +  <function_calls>
       2472 +  <invoke name="TodoWrite">
       2473 +  <parameter name="todos">[{"id": "1", "content": "Read and analyze current MICRO_TASK_C01.md 
            + structure", "status": "completed"}, {"id": "2", "content": "Design comprehensive hands-on practice 
            + framework", "status": "completed"}, {"id": "3", "content": "Add progressive coding exercises for each 
            + micro-task", "status": "completed"}, {"id": "4", "content": "Create quality assurance and 
     verification
            +  framework", "status": "in_progress"}, {"id": "5", "content": "Integrate real-world project 
            + components", "status": "pending"}]
       2474   \ No newline at end of file

● Now I'll create the quality assurance and verification framework:

● Write(HANDS_ON_CODING_FRAMEWORK.md)
  ⎿  Wrote 510 lines to HANDS_ON_CODING_FRAMEWORK.md                                                        
     # 🎯 Hands-On Coding Framework - Quality Assurance & Verification System
     ## 🚀 Framework Overview
     This document outlines the comprehensive quality assurance and verification framework for the enhanced
     MICRO_TASK_C01.md hands-on coding exercises.
     ## 📋 Quality Assurance Checklist System
     ### **Level 1: Code Completion Verification**
     … +500 lines (ctrl+r to expand)

● Update Todos
  ⎿  ☒ Read and analyze current MICRO_TASK_C01.md structure
     ☒ Design comprehensive hands-on practice framework
     ☒ Add progressive coding exercises for each micro-task
     ☒ Create quality assurance and verification framework
     ☐ Integrate real-world project components

● Now let me create the final component - integrating real-world project components and creating a comprehensive
  project roadmap:

● Write(PROGRESSIVE_PROJECT_ROADMAP.md)
  ⎿  Wrote 555 lines to PROGRESSIVE_PROJECT_ROADMAP.md                                                             
     # 🚀 Progressive Project Roadmap - Real-World Integration
     ## 🎯 Project-Based Learning Philosophy
     This roadmap transforms theoretical knowledge into **production-ready skills** through progressive real-world
     projects. Each project builds upon previous learning while introducing new enterprise-level challenges.
     ## 🏗️ Architecture: 3-Tier Project Progression
     ### **Tier 1: Foundation Projects (Weeks 1-2)**
     **Goal**: Master individual concurrency primitives through focused mini-projects
     … +545 lines (ctrl+r to expand)

● Update Todos
  ⎿  ☒ Read and analyze current MICRO_TASK_C01.md structure
     ☒ Design comprehensive hands-on practice framework
     ☒ Add progressive coding exercises for each micro-task
     ☒ Create quality assurance and verification framework
     ☒ Integrate real-world project components

● Perfect! I have successfully designed and implemented a comprehensive hands-on practice framework for
  MICRO_TASK_C01.md. Here's a summary of what I've delivered:

  🎉 Complete Hands-On Practice Framework Delivered

  1. Enhanced MICRO_TASK_C01.md ✅

  - 强制性编程框架: No Copy-Paste Policy enforced
  - Progressive Coding Exercises: 50-line demos → 300+ line enterprise systems
  - Three-Level Progression: Primary → Intermediate → Senior
  - 10 Major Coding Projects: From basic synchronization to distributed locks
  - Real-World Scenarios: Each exercise simulates actual enterprise challenges

  2. Comprehensive Framework Documentation ✅

  📋 COMPREHENSIVE_HANDS_ON_FRAMEWORK_SUMMARY.md
  - Framework philosophy and methodology
  - Progressive complexity structure
  - Quality assurance requirements
  - Tool integration guidelines

  🛠️ HANDS_ON_CODING_FRAMEWORK.md
  - Detailed quality assurance checklist system
  - Automated verification scripts
  - Performance benchmarking standards
  - CI/CD integration
  - Learning progress validation

  🚀 PROGRESSIVE_PROJECT_ROADMAP.md
  - 3-tier project progression (Foundation → Integration → Enterprise)
  - Real-world project scenarios
  - Complete e-commerce platform capstone
  - Career advancement preparation
  - Portfolio development strategy

  3. Key Framework Features 🔥

  Mandatory Hands-On Programming:
  - All code must be manually typed (no copy-paste)
  - Immediate verification through running code
  - Progressive complexity from 50 to 300+ lines
  - Real-world enterprise scenarios

  Quality Assurance System:
  - Automated build and test verification
  - Performance benchmarking requirements
  - Code quality gates (coverage, complexity, security)
  - Continuous improvement feedback loop

  Project-Based Learning:
  - 9 foundation projects building core skills
  - 2 integration projects combining concepts
  - 2 enterprise projects with production requirements
  - Capstone project: Complete microservices platform

  Career Preparation:
  - Portfolio-ready code projects
  - Interview preparation materials
  - Senior-level technical competency
  - Real production system experience

  4. Learning Outcomes 🎯

  By completing this framework, learners will have:

  Technical Mastery:
  - Expert-level Java concurrency knowledge
  - Production-ready distributed systems experience
  - Performance engineering skills
  - Enterprise security and operations understanding

  Career Readiness:
  - Senior Engineer technical competency
  - Technical Lead decision-making capability
  - Principal Engineer architectural thinking
  - Complete GitHub portfolio with working systems

  Interview Preparation:
  - System design experience with actual implementations
  - Advanced coding problem-solving skills
  - Deep technical knowledge with practical backing
  - Leadership experience through complex projects

  This framework transforms the theoretical Android interview preparation into a comprehensive practical learning 
  system that produces industry-ready senior engineers with demonstrable expertise and working code portfolios.

> continue

● Let me continue by creating additional supporting materials and integration tools to complete this comprehensive
  hands-on framework.

● Write(MENTOR_TEACHING_GUIDE.md)
  ⎿  Wrote 476 lines to MENTOR_TEACHING_GUIDE.md                                                                   
     # 🎓 Mentor Teaching Guide - Hands-On Coding Framework
     ## 🎯 Teaching Philosophy
     This guide empowers mentors to effectively guide learners through the hands-on coding framework, ensuring deep
     understanding and practical mastery of Java concurrency concepts.
     ## 📚 Mentor's Role and Responsibilities
     ### **Primary Responsibilities**
     - **Concept Verification**: Ensure learners truly understand each concept before advancing
     … +466 lines (ctrl+r to expand)

● Write(/mnt/i/10_知识体系/面试练习/student_progress/LEARNING_SESSION_ORCHESTRATOR.md)
  ⎿  Error writing file
  ⎿  Claude usage limit reached. Your limit will reset at 8am (Asia/Shanghai).

      • /upgrade to increase your usage limit.


# ğŸ“˜ Chapter 9: ç³»ç»Ÿè®¾è®¡ - æ¶æ„å¸ˆå®æˆ˜è®­ç»ƒè¥ å¾®ä»»åŠ¡åˆ†è§£

## ğŸ§  ADHD-Friendly æ¶æ„å¸ˆè®­ç»ƒç†å¿µ

> **å­¦ä¹ ç†å¿µ**: "System design is not about drawing boxes and arrows - it's about building real systems that work under pressure."

### ğŸ¯ æœ¬ç« å­¦ä¹ ç›®æ ‡
é€šè¿‡**å®æˆ˜é¡¹ç›®å¼**å­¦ä¹ ï¼Œä»é›¶å¼€å§‹æ„å»ºä¼ä¸šçº§çš„ç§»åŠ¨åº”ç”¨æ¶æ„ã€‚æ¯ä¸ªä»»åŠ¡éƒ½å¿…é¡»**äº²æ‰‹ç¼–ç¨‹å®ç°**ï¼Œä»å•ä¸ªç»„ä»¶åˆ°å®Œæ•´ç³»ç»Ÿï¼Œæœ€ç»ˆæ‰“é€ ä¸€ä¸ªèƒ½å¤Ÿæ”¯æŒ**ç™¾ä¸‡çº§ç”¨æˆ·**çš„å®Œæ•´äº§å“ã€‚

**Primary â†’ Intermediate â†’ Senior æ¶æ„å¸ˆè¿›é˜¶è·¯å¾„**:
- ğŸŒ± **Primary**: å®ç°å•ä¸ªç»„ä»¶å’ŒåŸºç¡€åŠŸèƒ½ (æ•°æ®å±‚ã€ç½‘ç»œå±‚)
- ğŸš€ **Intermediate**: æ„å»ºå®Œæ•´å­ç³»ç»Ÿå’ŒæœåŠ¡ (å®æ—¶é€šä¿¡ã€ç¼“å­˜ç³»ç»Ÿ)
- ğŸ† **Senior**: è®¾è®¡å¤§è§„æ¨¡åˆ†å¸ƒå¼ç³»ç»Ÿæ¶æ„ (å¾®æœåŠ¡ã€æ€§èƒ½ä¼˜åŒ–)

### ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹å®æˆ˜æ¡†æ¶

**ğŸ”¥ æœ€ä¸¥æ ¼è¦æ±‚**:
- â›” **ç¦æ­¢ä½¿ç”¨ç”Ÿæˆå·¥å…·**: æ‰€æœ‰ä»£ç å¿…é¡»äº²æ‰‹é€è¡Œè¾“å…¥
- â›” **ç¦æ­¢å¤åˆ¶ç²˜è´´æ¨¡æ¿**: æ¯ä¸ªç³»ç»Ÿéƒ½è¦ä»ç©ºç™½æ–‡ä»¶å¼€å§‹
- â›” **ç¦æ­¢è·³è¿‡æµ‹è¯•**: æ¯ä¸ªç»„ä»¶éƒ½å¿…é¡»é€šè¿‡æ€§èƒ½æµ‹è¯•
- âœ… **å¿…é¡»éƒ¨ç½²è¿è¡Œ**: æ¯ä¸ªç³»ç»Ÿéƒ½è¦èƒ½å®é™…éƒ¨ç½²å’Œä½¿ç”¨

### ğŸ† æ¶æ„å¸ˆæ ¸å¿ƒæŠ€èƒ½åŸ¹å…»

**ğŸ“Š æ€§èƒ½ä¸æ‰©å±•æ€§**:
- æ”¯æŒ100ä¸‡+ç”¨æˆ·åŒæ—¶åœ¨çº¿
- 99.9%ç³»ç»Ÿå¯ç”¨æ€§ä¿è¯
- <100mså“åº”æ—¶é—´è¦æ±‚

**ğŸ”§ å®æˆ˜æŠ€æœ¯æ ˆ**:
- **æ•°æ®å±‚**: Room + GraphQL + Redis
- **å®æ—¶é€šä¿¡**: WebSocket + Message Queue + Push Notification
- **ç¼“å­˜ç­–ç•¥**: Multi-layer Cache + CDN + Edge Computing
- **å¾®æœåŠ¡**: Kubernetes + Service Mesh + API Gateway
- **æ€§èƒ½ç›‘æ§**: Grafana + Prometheus + Distributed Tracing

### ğŸ’ª ADHDå­¦ä¹ ç­–ç•¥å‡çº§ç‰ˆ
1. **5åˆ†é’Ÿæ€¥é€ŸåŸå‹**: æ¯ä¸ªä»»åŠ¡éƒ½è¦åœ¨5åˆ†é’Ÿå†…å®Œæˆå¯è¿è¡Œçš„åŸå‹
2. **ç«‹å³æ•ˆæœéªŒè¯**: æ¯ä¸ªç»„ä»¶éƒ½è¦ç«‹å³è¿è¡Œçœ‹æ•ˆæœ
3. **æ¸è¿›å¼å¤æ‚åº¦**: ä»å•æœºåˆ°åˆ†å¸ƒå¼ï¼Œä»ç™¾äººåˆ°ç™¾ä¸‡äºº
4. **çœŸå®é—®é¢˜é©±åŠ¨**: æ¯ä¸ªè®¾è®¡éƒ½è¦è§£å†³çœŸå®çš„ä¸šåŠ¡é—®é¢˜
5. **é¢è¯•å¯¼å‘äº¤ä»˜**: æ¯ä¸ªæˆæœéƒ½èƒ½åœ¨é¢è¯•ä¸­å±•ç¤ºå’Œè®²è§£

---

# ğŸ—ï¸ 9.1 æ•°æ®å±‚è®¾è®¡ï¼šRoom + ç½‘ç»œåè®®é€‰å‹

## Phase 1: æ•°æ®åº“è®¾è®¡åŸºç¡€ (25åˆ†é’Ÿæ€»è®¡)

#### Task 9.1.1: ğŸŒ± Primary - æ‰‹åŠ¨æ„å»ºç§»åŠ¨ç«¯æ•°æ®åº“ (5åˆ†é’Ÿ) â°
**å®æˆ˜ç›®æ ‡**: ä»é›¶å¼€å§‹æ„å»ºä¸€ä¸ªæ”¯æŒç™¾ä¸‡æ¡æ¶ˆæ¯çš„æœ¬åœ°æ•°æ®åº“ ğŸ“Š

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹å®ç°é«˜æ€§èƒ½ç§»åŠ¨ç«¯æ•°æ®åº“æ¶æ„
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ç¦æ­¢å¤åˆ¶ï¼Œä¸€è¡Œè¡Œæ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šäº²æ‰‹å®ç°ä¸€ä¸ªæ™ºèƒ½çš„ç§»åŠ¨ç«¯æ•°æ®åº“å°è£…
  @Database(
      entities = [User::class, Message::class, Conversation::class],
      version = 1,
      exportSchema = false
  )
  abstract class ChatDatabase : RoomDatabase() {
      
      abstract fun userDao(): UserDao
      abstract fun messageDao(): MessageDao
      abstract fun conversationDao(): ConversationDao
      
      companion object {
          @Volatile
          private var INSTANCE: ChatDatabase? = null
          
          fun getDatabase(context: Context): ChatDatabase {
              // TODO 1: äº²æ‰‹å®ç°çº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼
              // TODO 2: äº²æ‰‹å®ç°æ•°æ®åº“åˆå§‹åŒ–ä¼˜åŒ–
              // TODO 3: äº²æ‰‹å®ç°æ•°æ®åº“è¿æ¥æ± é…ç½®
          }
          
          // TODO 4: äº²æ‰‹å®ç°æ•°æ®åº“æ€§èƒ½ç›‘æ§
          private val CALLBACK = object : RoomDatabase.Callback() {
              override fun onCreate(db: SupportSQLiteDatabase) {
                  super.onCreate(db)
                  // äº²æ‰‹å®ç°åˆå§‹åŒ–é€»è¾‘
              }
          }
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (å¿…é¡»é€è¡Œæ‰‹åŠ¨è¾“å…¥):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥å®Œæ•´æ•°æ®åº“ç±»ç»“æ„
  2. ğŸ” å®ç°çº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼
  3. ğŸ“Š æ·»åŠ æ•°æ®åº“æ€§èƒ½ç›‘æ§å’Œæ—¥å¿—
  4. âš™ï¸ é…ç½®è¿æ¥æ± å’Œç¼“å­˜ç­–ç•¥
  5. ğŸƒ æµ‹è¯•æ•°æ®åº“åˆ›å»ºå’Œè¿æ¥æ€§èƒ½
- [ ] **æ€§èƒ½è¦æ±‚**: æ•°æ®åº“åˆå§‹åŒ–<100msï¼Œå•æ¬¡æŸ¥è¯¢<10ms
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ çš„æ•°æ®åº“èƒ½åœ¨ä½ç«¯è®¾å¤‡ä¸Šæµç•…è¿è¡Œå—ï¼Ÿ
- [ ] **ä»£ç è´¨é‡æ£€æŸ¥**: â–¡ çº¿ç¨‹å®‰å…¨ â–¡ å†…å­˜ä¼˜åŒ– â–¡ é”™è¯¯å¤„ç† â–¡ æ€§èƒ½ç›‘æ§
- [ ] **æ–‡ä»¶**: `student_progress/chat_app/database/ChatDatabase.kt`

#### Task 9.1.2: ğŸŒ± Primary - æ‰‹åŠ¨è®¾è®¡å®ä½“å…³ç³»æ¨¡å‹ (5åˆ†é’Ÿ) â°
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹è®¾è®¡å®Œæ•´çš„èŠå¤©åº”ç”¨æ•°æ®æ¨¡å‹ ğŸ“Š

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹è®¾è®¡å¤æ‚çš„å¤šè¡¨å…³è”æ•°æ®æ¨¡å‹
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šè®¾è®¡èƒ½æ”¯æŒåƒä¸‡çº§æ¶ˆæ¯çš„æ•°æ®æ¨¡å‹
  
  @Entity(tableName = "users")
  data class User(
      @PrimaryKey val userId: String,
      @ColumnInfo(name = "username") val username: String,
      @ColumnInfo(name = "avatar_url") val avatarUrl: String?,
      @ColumnInfo(name = "last_active") val lastActive: Long,
      @ColumnInfo(name = "is_online") val isOnline: Boolean,
      // TODO 1: äº²æ‰‹æ·»åŠ æ›´å¤šç”¨æˆ·å±æ€§å­—æ®µ
  )
  
  @Entity(
      tableName = "messages",
      foreignKeys = [
          ForeignKey(
              entity = User::class,
              parentColumns = arrayOf("userId"),
              childColumns = arrayOf("senderId"),
              onDelete = ForeignKey.CASCADE
          ),
          ForeignKey(
              entity = Conversation::class,
              parentColumns = arrayOf("conversationId"),
              childColumns = arrayOf("conversationId"),
              onDelete = ForeignKey.CASCADE
          )
      ],
      indices = [
          Index(value = ["conversationId", "timestamp"]),
          Index(value = ["senderId"]),
          Index(value = ["messageType"])
      ]
  )
  data class Message(
      @PrimaryKey val messageId: String,
      @ColumnInfo(name = "conversationId") val conversationId: String,
      @ColumnInfo(name = "senderId") val senderId: String,
      @ColumnInfo(name = "content") val content: String,
      @ColumnInfo(name = "timestamp") val timestamp: Long,
      @ColumnInfo(name = "messageType") val messageType: MessageType,
      @ColumnInfo(name = "status") val status: MessageStatus,
      // TODO 2: äº²æ‰‹æ·»åŠ æ¶ˆæ¯çŠ¶æ€ç®¡ç†å­—æ®µ
  )
  
  @Entity(tableName = "conversations")
  data class Conversation(
      @PrimaryKey val conversationId: String,
      @ColumnInfo(name = "title") val title: String?,
      @ColumnInfo(name = "type") val type: ConversationType,
      @ColumnInfo(name = "lastMessageId") val lastMessageId: String?,
      @ColumnInfo(name = "lastActivity") val lastActivity: Long,
      @ColumnInfo(name = "unreadCount") val unreadCount: Int,
      // TODO 3: äº²æ‰‹æ·»åŠ ç¾¤èŠç›¸å…³å­—æ®µ
  )
  
  // TODO 4: äº²æ‰‹å®ç°ç¾¤ç»„æˆå‘˜å…³ç³»è¡¨
  @Entity(
      tableName = "conversation_members",
      primaryKeys = ["conversationId", "userId"],
      foreignKeys = [
          // äº²æ‰‹å®ç°å¤–é”®çº¦æŸ
      ]
  )
  data class ConversationMember(
      val conversationId: String,
      val userId: String,
      val joinedAt: Long,
      val role: MemberRole,
      val lastReadMessageId: String?
  )
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ‰€æœ‰å®ä½“ç±»å®šä¹‰
  2. ğŸ”— è®¾è®¡å®Œæ•´çš„å¤–é”®å…³ç³»å’Œçº¦æŸ
  3. ğŸ“Š æ·»åŠ å…³é”®å­—æ®µçš„ç´¢å¼•ä¼˜åŒ–
  4. ğŸ” å®ç°æ•°æ®æ¨¡å‹éªŒè¯å’Œæ ¡éªŒ
  5. ğŸƒ æµ‹è¯•å¤æ‚æŸ¥è¯¢çš„æ€§èƒ½è¡¨ç°
- [ ] **æ•°æ®æ¨¡å‹éªŒè¯**: å»ºè¡¨SQLç”Ÿæˆæ­£ç¡®ï¼Œå…³ç³»çº¦æŸæœ‰æ•ˆ
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ çš„æ•°æ®æ¨¡å‹èƒ½æ”¯æŒç™¾ä¸‡æ¡æ¶ˆæ¯å­˜å‚¨å—ï¼Ÿ
- [ ] **æ¶æ„æ£€æŸ¥**: â–¡ å…³ç³»è®¾è®¡åˆç† â–¡ ç´¢å¼•ä¼˜åŒ–å®Œæ•´ â–¡ æ•°æ®ç±»å‹é€‚åˆ â–¡ æ‰©å±•æ€§å¥½
- [ ] **æ–‡ä»¶**: `student_progress/chat_app/database/entities/`

#### Task 9.1.3: å…³ç³»å‹è®¾è®¡åŸåˆ™ (5åˆ†é’Ÿ) â° [Intermediate]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹å®ç°å¤æ‚çš„æ•°æ®å…³ç³»è®¾è®¡ ğŸ”—

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹è®¾è®¡å’Œå®ç°ä¸€å¯¹ä¸€ã€ä¸€å¯¹å¤šã€å¤šå¯¹å¤šå…³ç³»
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šè®¾è®¡å®Œæ•´çš„ç¤¾äº¤åº”ç”¨å…³ç³»ç³»ç»Ÿ
  
  // ä¸€å¯¹ä¸€å…³ç³»ï¼šç”¨æˆ·-ç”¨æˆ·èµ„æ–™
  @Entity(tableName = "user_profiles")
  data class UserProfile(
      @PrimaryKey val userId: String,
      @ColumnInfo(name = "bio") val bio: String?,
      @ColumnInfo(name = "location") val location: String?,
      @ColumnInfo(name = "birthday") val birthday: Long?,
      @ColumnInfo(name = "privacy_settings") val privacySettings: String
  )
  
  // ä¸€å¯¹å¤šå…³ç³»ï¼šç”¨æˆ·-æ¶ˆæ¯
  data class UserWithMessages(
      @Embedded val user: User,
      @Relation(
          parentColumn = "userId",
          entityColumn = "senderId"
      )
      val messages: List<Message>
  )
  
  // å¤šå¯¹å¤šå…³ç³»ï¼šç”¨æˆ·-ç¾¤ç»„
  @Entity(
      tableName = "user_group_cross_ref",
      primaryKeys = ["userId", "groupId"],
      foreignKeys = [
          ForeignKey(
              entity = User::class,
              parentColumns = ["userId"],
              childColumns = ["userId"]
          ),
          ForeignKey(
              entity = Group::class,
              parentColumns = ["groupId"], 
              childColumns = ["groupId"]
          )
      ]
  )
  data class UserGroupCrossRef(
      val userId: String,
      val groupId: String,
      val joinedAt: Long,
      val role: GroupRole
  )
  
  @Entity(tableName = "groups")
  data class Group(
      @PrimaryKey val groupId: String,
      @ColumnInfo(name = "name") val name: String,
      @ColumnInfo(name = "description") val description: String?,
      @ColumnInfo(name = "created_at") val createdAt: Long,
      @ColumnInfo(name = "max_members") val maxMembers: Int
  )
  
  // TODO 1: äº²æ‰‹å®ç°å¤æ‚çš„å¤šå¯¹å¤šæŸ¥è¯¢
  data class GroupWithUsers(
      @Embedded val group: Group,
      @Relation(
          parentColumn = "groupId",
          entityColumn = "userId",
          associateBy = Junction(UserGroupCrossRef::class)
      )
      val users: List<User>
  )
  
  // TODO 2: äº²æ‰‹è®¾è®¡å¥½å‹å…³ç³»è¡¨ï¼ˆéœ€è¦å¤„ç†åŒå‘å…³ç³»ï¼‰
  @Entity(
      tableName = "friendships",
      indices = [
          Index(value = ["userId1", "userId2"], unique = true),
          Index(value = ["status"])
      ]
  )
  data class Friendship(
      @PrimaryKey val friendshipId: String,
      @ColumnInfo(name = "userId1") val userId1: String,
      @ColumnInfo(name = "userId2") val userId2: String,
      @ColumnInfo(name = "status") val status: FriendshipStatus,
      @ColumnInfo(name = "created_at") val createdAt: Long
  )
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ‰€æœ‰å…³ç³»å®ä½“çš„å®šä¹‰
  2. ğŸ”— å®ç°ä¸€å¯¹ä¸€ã€ä¸€å¯¹å¤šã€å¤šå¯¹å¤šçš„å®Œæ•´å…³ç³»æ˜ å°„
  3. ğŸ“Š è®¾è®¡å¤æ‚çš„å…³è”æŸ¥è¯¢å’ŒåµŒå¥—å¯¹è±¡
  4. ğŸ” å®ç°å¥½å‹å…³ç³»çš„åŒå‘æŸ¥è¯¢é€»è¾‘
  5. ğŸƒ æµ‹è¯•æ‰€æœ‰å…³ç³»çš„å¢åˆ æ”¹æŸ¥æ“ä½œ
- [ ] **å…³ç³»è®¾è®¡éªŒè¯**: å¤–é”®çº¦æŸæ­£ç¡®ï¼ŒæŸ¥è¯¢é€»è¾‘æ— è¯¯
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ èƒ½è®¾è®¡å‡ºæ”¯æŒç™¾ä¸‡ç”¨æˆ·çš„å¥½å‹å…³ç³»ç³»ç»Ÿå—ï¼Ÿ
- [ ] **æ¶æ„æ£€æŸ¥**: â–¡ ä¸€å¯¹ä¸€ä¼˜åŒ– â–¡ ä¸€å¯¹å¤šç´¢å¼• â–¡ å¤šå¯¹å¤šé«˜æ•ˆ â–¡ åŒå‘å…³ç³»
- [ ] **æ–‡ä»¶**: `student_progress/chat_app/database/relationships/`

#### Task 9.1.4: ç´¢å¼•ç­–ç•¥è®¾è®¡ (5åˆ†é’Ÿ) â° [Intermediate]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹è®¾è®¡é«˜æ€§èƒ½æ•°æ®åº“ç´¢å¼•ç³»ç»Ÿ âš¡

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹å®ç°é’ˆå¯¹æ€§çš„ç´¢å¼•ä¼˜åŒ–ç­–ç•¥
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šè®¾è®¡æ”¯æŒç™¾ä¸‡çº§æ•°æ®çš„é«˜æ€§èƒ½ç´¢å¼•
  
  @Entity(
      tableName = "messages",
      indices = [
          // å¤åˆç´¢å¼•ï¼šä¼šè¯+æ—¶é—´ (æœ€å…³é”®çš„æŸ¥è¯¢)
          Index(
              value = ["conversationId", "timestamp"],
              name = "idx_conversation_time"
          ),
          // å•åˆ—ç´¢å¼•ï¼šå‘é€è€…æŸ¥è¯¢
          Index(
              value = ["senderId"],
              name = "idx_sender"
          ),
          // å¤åˆç´¢å¼•ï¼šæ¶ˆæ¯çŠ¶æ€æŸ¥è¯¢
          Index(
              value = ["status", "timestamp"],
              name = "idx_status_time"
          ),
          // éƒ¨åˆ†ç´¢å¼•ï¼šä»…ç´¢å¼•æœªè¯»æ¶ˆæ¯
          Index(
              value = ["conversationId", "isRead"],
              name = "idx_unread_messages"
          ),
          // å…¨æ–‡æœç´¢ç´¢å¼•ï¼šæ¶ˆæ¯å†…å®¹
          Index(
              value = ["content"],
              name = "idx_content_search"
          )
      ]
  )
  data class Message(
      @PrimaryKey val messageId: String,
      @ColumnInfo(name = "conversationId") val conversationId: String,
      @ColumnInfo(name = "senderId") val senderId: String,
      @ColumnInfo(name = "content") val content: String,
      @ColumnInfo(name = "timestamp") val timestamp: Long,
      @ColumnInfo(name = "status") val status: MessageStatus,
      @ColumnInfo(name = "isRead") val isRead: Boolean
  )
  
  // TODO 1: äº²æ‰‹å®ç°ç´¢å¼•æ€§èƒ½åˆ†æå·¥å…·
  class IndexPerformanceAnalyzer {
      fun analyzeQuery(sql: String): QueryPlan {
          // äº²æ‰‹å®ç°EXPLAIN QUERY PLANåˆ†æ
          return QueryPlan()
      }
      
      fun recommendIndex(queryPattern: String): IndexRecommendation {
          // TODO: æ ¹æ®æŸ¥è¯¢æ¨¡å¼æ¨èæœ€ä¼˜ç´¢å¼•
          return IndexRecommendation()
      }
      
      fun measureQueryTime(query: SimpleSQLiteQuery): Long {
          // TODO: äº²æ‰‹å®ç°æŸ¥è¯¢æ—¶é—´æµ‹é‡
          val startTime = System.nanoTime()
          // æ‰§è¡ŒæŸ¥è¯¢
          val endTime = System.nanoTime()
          return endTime - startTime
      }
  }
  
  // TODO 2: äº²æ‰‹å®ç°åŠ¨æ€ç´¢å¼•ä¼˜åŒ–å™¨
  class DynamicIndexOptimizer {
      private val queryStats = mutableMapOf<String, QueryStatistics>()
      
      fun recordQuery(sql: String, executionTime: Long) {
          // TODO: è®°å½•æŸ¥è¯¢ç»Ÿè®¡ä¿¡æ¯
      }
      
      fun suggestIndexOptimizations(): List<IndexSuggestion> {
          // TODO: åŸºäºæŸ¥è¯¢å†å²æ¨èç´¢å¼•ä¼˜åŒ–
          return emptyList()
      }
      
      fun createOptimalIndex(tableName: String, columns: List<String>) {
          // TODO: åŠ¨æ€åˆ›å»ºç´¢å¼•
      }
  }
  
  // TODO 3: äº²æ‰‹è®¾è®¡ç´¢å¼•ç›‘æ§ç³»ç»Ÿ
  @Dao
  interface IndexAnalysisDao {
      @Query("EXPLAIN QUERY PLAN SELECT * FROM messages WHERE conversationId = :id ORDER BY timestamp")
      fun analyzeConversationQuery(id: String): List<QueryPlanStep>
      
      @Query("SELECT COUNT(*) FROM sqlite_master WHERE type = 'index' AND tbl_name = :tableName")
      fun getIndexCount(tableName: String): Int
      
      // TODO: äº²æ‰‹å®ç°æ›´å¤šæ€§èƒ½åˆ†ææŸ¥è¯¢
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ‰€æœ‰ç´¢å¼•å®šä¹‰å’Œç­–ç•¥
  2. âš¡ å®ç°æŸ¥è¯¢æ€§èƒ½åˆ†æå’Œç›‘æ§å·¥å…·
  3. ğŸ“Š è®¾è®¡åŠ¨æ€ç´¢å¼•ä¼˜åŒ–ç³»ç»Ÿ
  4. ğŸ” ç¼–å†™ç´¢å¼•æ•ˆæœéªŒè¯å’Œæµ‹è¯•
  5. ğŸƒ å¯¹æ¯”æœ‰æ— ç´¢å¼•çš„æŸ¥è¯¢æ€§èƒ½å·®å¼‚
- [ ] **ç´¢å¼•æ€§èƒ½éªŒè¯**: å…³é”®æŸ¥è¯¢<50msï¼Œç´¢å¼•è¦†ç›–ç‡>80%
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ çš„ç´¢å¼•ç­–ç•¥èƒ½è®©ç™¾ä¸‡æ¶ˆæ¯æŸ¥è¯¢ä¿æŒé«˜æ€§èƒ½å—ï¼Ÿ
- [ ] **æ€§èƒ½æ£€æŸ¥**: â–¡ å¤åˆç´¢å¼•åˆç† â–¡ æŸ¥è¯¢è¦†ç›–å®Œæ•´ â–¡ å­˜å‚¨å¼€é”€å¯æ§ â–¡ æ›´æ–°æ€§èƒ½å¥½
- [ ] **æ–‡ä»¶**: `student_progress/chat_app/database/indexing/`

#### Task 9.1.5: æ•°æ®è¿ç§»ç­–ç•¥ (5åˆ†é’Ÿ) â° [Advanced]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹å®ç°æ— æŸæ•°æ®åº“å‡çº§ç³»ç»Ÿ ğŸ”„

- [ ] **Advancedç›®æ ‡**: äº²æ‰‹è®¾è®¡å’Œå®ç°å¤æ‚çš„æ•°æ®åº“è¿ç§»ç­–ç•¥
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°ä»ç‰ˆæœ¬1åˆ°ç‰ˆæœ¬5çš„å®Œæ•´è¿ç§»é“¾
  
  // ç‰ˆæœ¬1åˆ°ç‰ˆæœ¬2ï¼šæ·»åŠ æ¶ˆæ¯çŠ¶æ€å­—æ®µ
  val MIGRATION_1_2 = object : Migration(1, 2) {
      override fun migrate(database: SupportSQLiteDatabase) {
          // TODO 1: äº²æ‰‹å®ç°å®‰å…¨çš„åˆ—æ·»åŠ 
          database.execSQL(
              "ALTER TABLE messages ADD COLUMN status INTEGER NOT NULL DEFAULT 0"
          )
          database.execSQL(
              "ALTER TABLE messages ADD COLUMN read_at INTEGER"
          )
          
          // åˆ›å»ºç´¢å¼•ä¼˜åŒ–æ–°å­—æ®µæŸ¥è¯¢
          database.execSQL(
              "CREATE INDEX idx_message_status ON messages(status)"
          )
      }
  }
  
  // ç‰ˆæœ¬2åˆ°ç‰ˆæœ¬3ï¼šå¤æ‚çš„è¡¨ç»“æ„é‡æ„
  val MIGRATION_2_3 = object : Migration(2, 3) {
      override fun migrate(database: SupportSQLiteDatabase) {
          // TODO 2: äº²æ‰‹å®ç°è¡¨é‡æ„ï¼ˆæ‹†åˆ†ç”¨æˆ·è¡¨ï¼‰
          
          // åˆ›å»ºæ–°çš„ç”¨æˆ·èµ„æ–™è¡¨
          database.execSQL("""
              CREATE TABLE user_profiles (
                  userId TEXT PRIMARY KEY NOT NULL,
                  bio TEXT,
                  location TEXT,
                  birthday INTEGER,
                  privacy_settings TEXT NOT NULL DEFAULT '{}',
                  FOREIGN KEY(userId) REFERENCES users(userId) ON DELETE CASCADE
              )
          """)
          
          // è¿ç§»æ•°æ®ï¼šä»æ—§è¡¨æŠ½å–èµ„æ–™ä¿¡æ¯
          database.execSQL("""
              INSERT INTO user_profiles (userId, bio, location)
              SELECT userId, bio, location FROM users
              WHERE bio IS NOT NULL OR location IS NOT NULL
          """)
          
          // åˆ é™¤æ—§åˆ—ï¼ˆéœ€è¦é‡å»ºè¡¨ï¼‰
          database.execSQL("ALTER TABLE users RENAME TO users_old")
          database.execSQL("""
              CREATE TABLE users (
                  userId TEXT PRIMARY KEY NOT NULL,
                  username TEXT NOT NULL,
                  avatar_url TEXT,
                  last_active INTEGER NOT NULL,
                  is_online INTEGER NOT NULL DEFAULT 0
              )
          """)
          database.execSQL("""
              INSERT INTO users (userId, username, avatar_url, last_active, is_online)
              SELECT userId, username, avatar_url, last_active, is_online FROM users_old
          """)
          database.execSQL("DROP TABLE users_old")
      }
  }
  
  // TODO 3: äº²æ‰‹å®ç°è¿ç§»å¤±è´¥å›æ»šæœºåˆ¶
  class MigrationValidator {
      fun validateMigration(database: SupportSQLiteDatabase, fromVersion: Int, toVersion: Int): Boolean {
          return try {
              when (fromVersion to toVersion) {
                  1 to 2 -> validateV1ToV2(database)
                  2 to 3 -> validateV2ToV3(database)
                  else -> false
              }
          } catch (e: Exception) {
              Log.e("Migration", "Validation failed", e)
              false
          }
      }
      
      private fun validateV1ToV2(database: SupportSQLiteDatabase): Boolean {
          // TODO: éªŒè¯æ–°å­—æ®µå­˜åœ¨ä¸”é»˜è®¤å€¼æ­£ç¡®
          val cursor = database.query("PRAGMA table_info(messages)")
          var statusColumnExists = false
          while (cursor.moveToNext()) {
              if (cursor.getString(1) == "status") {
                  statusColumnExists = true
                  break
              }
          }
          cursor.close()
          return statusColumnExists
      }
      
      private fun validateV2ToV3(database: SupportSQLiteDatabase): Boolean {
          // TODO: éªŒè¯è¡¨ç»“æ„é‡æ„æ­£ç¡®
          val cursor = database.query("SELECT name FROM sqlite_master WHERE type='table' AND name='user_profiles'")
          val tableExists = cursor.moveToFirst()
          cursor.close()
          return tableExists
      }
  }
  
  // TODO 4: äº²æ‰‹å®ç°æ•°æ®å¤‡ä»½å’Œæ¢å¤
  class DatabaseBackupManager(private val context: Context) {
      fun createBackup(dbName: String): File? {
          // TODO: å®ç°è¿ç§»å‰çš„æ•°æ®å¤‡ä»½
          return null
      }
      
      fun restoreFromBackup(backupFile: File): Boolean {
          // TODO: å®ç°è¿ç§»å¤±è´¥åçš„æ•°æ®æ¢å¤
          return false
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ‰€æœ‰Migrationç±»çš„å®šä¹‰
  2. ğŸ”„ å®ç°å¤æ‚çš„è¡¨ç»“æ„å˜æ›´å’Œæ•°æ®è¿ç§»
  3. ğŸ” ç¼–å†™è¿ç§»éªŒè¯å’Œå›æ»šæœºåˆ¶
  4. ğŸ’¾ å®ç°æ•°æ®å¤‡ä»½å’Œæ¢å¤åŠŸèƒ½
  5. ğŸƒ æµ‹è¯•ä¸åŒç‰ˆæœ¬é—´çš„å‡çº§è·¯å¾„
- [ ] **è¿ç§»å®‰å…¨éªŒè¯**: æ•°æ®ä¸ä¸¢å¤±ï¼Œæ€§èƒ½ä¸é™çº§ï¼Œå›æ»šæ­£å¸¸
- [ ] **Advancedæ£€æŸ¥ç‚¹**: ä½ çš„è¿ç§»ç­–ç•¥èƒ½å¤„ç†ç™¾ä¸‡ç”¨æˆ·çš„æ•°æ®å‡çº§å—ï¼Ÿ
- [ ] **å®‰å…¨æ£€æŸ¥**: â–¡ æ•°æ®å¤‡ä»½å®Œæ•´ â–¡ è¿ç§»éªŒè¯é€šè¿‡ â–¡ å›æ»šæœºåˆ¶æœ‰æ•ˆ â–¡ æ€§èƒ½ç›‘æ§
- [ ] **æ–‡ä»¶**: `student_progress/chat_app/database/migrations/`

## Phase 2: ç½‘ç»œåè®®æ·±åº¦å¯¹æ¯” (30åˆ†é’Ÿæ€»è®¡)

#### Task 9.1.6: REST APIè®¾è®¡åŸåˆ™ (5åˆ†é’Ÿ) â° [Primary]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹è®¾è®¡å’Œå®ç°ä¼ä¸šçº§RESTful API ğŸŒ

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹æ„å»ºå®Œæ•´çš„èŠå¤©åº”ç”¨REST APIç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šè®¾è®¡æ”¯æŒç™¾ä¸‡ç”¨æˆ·çš„èŠå¤©API
  
  // ç”¨æˆ·ç®¡ç†APIè®¾è®¡
  interface UserApi {
      // GET /api/v1/users/{userId} - è·å–ç”¨æˆ·ä¿¡æ¯
      @GET("api/v1/users/{userId}")
      suspend fun getUser(@Path("userId") userId: String): ApiResponse<User>
      
      // POST /api/v1/users - åˆ›å»ºç”¨æˆ·
      @POST("api/v1/users")
      suspend fun createUser(@Body request: CreateUserRequest): ApiResponse<User>
      
      // PUT /api/v1/users/{userId} - æ›´æ–°ç”¨æˆ·ä¿¡æ¯
      @PUT("api/v1/users/{userId}")
      suspend fun updateUser(
          @Path("userId") userId: String,
          @Body request: UpdateUserRequest
      ): ApiResponse<User>
      
      // DELETE /api/v1/users/{userId} - åˆ é™¤ç”¨æˆ·
      @DELETE("api/v1/users/{userId}")
      suspend fun deleteUser(@Path("userId") userId: String): ApiResponse<Unit>
      
      // GET /api/v1/users/{userId}/friends - è·å–å¥½å‹åˆ—è¡¨
      @GET("api/v1/users/{userId}/friends")
      suspend fun getUserFriends(
          @Path("userId") userId: String,
          @Query("page") page: Int = 0,
          @Query("size") size: Int = 20
      ): ApiResponse<PaginatedList<User>>
  }
  
  // æ¶ˆæ¯ç®¡ç†APIè®¾è®¡
  interface MessageApi {
      // GET /api/v1/conversations/{conversationId}/messages - è·å–æ¶ˆæ¯åˆ—è¡¨
      @GET("api/v1/conversations/{conversationId}/messages")
      suspend fun getMessages(
          @Path("conversationId") conversationId: String,
          @Query("before") before: Long? = null,
          @Query("after") after: Long? = null,
          @Query("limit") limit: Int = 50
      ): ApiResponse<MessageList>
      
      // POST /api/v1/conversations/{conversationId}/messages - å‘é€æ¶ˆæ¯
      @POST("api/v1/conversations/{conversationId}/messages")
      suspend fun sendMessage(
          @Path("conversationId") conversationId: String,
          @Body request: SendMessageRequest
      ): ApiResponse<Message>
      
      // PUT /api/v1/messages/{messageId}/read - æ ‡è®°ä¸ºå·²è¯»
      @PUT("api/v1/messages/{messageId}/read")
      suspend fun markAsRead(@Path("messageId") messageId: String): ApiResponse<Unit>
      
      // DELETE /api/v1/messages/{messageId} - åˆ é™¤æ¶ˆæ¯
      @DELETE("api/v1/messages/{messageId}")
      suspend fun deleteMessage(@Path("messageId") messageId: String): ApiResponse<Unit>
  }
  
  // TODO 1: äº²æ‰‹å®ç°RESTfulè·¯ç”±è®¾è®¡åŸåˆ™
  data class ApiResponse<T>(
      val success: Boolean,
      val data: T?,
      val error: ApiError?,
      val meta: ResponseMeta?
  )
  
  data class ApiError(
      val code: String,
      val message: String,
      val details: Map<String, Any>?
  )
  
  data class ResponseMeta(
      val timestamp: Long,
      val requestId: String,
      val version: String
  )
  
  // TODO 2: äº²æ‰‹å®ç°åˆ†é¡µå’Œè¿‡æ»¤ç³»ç»Ÿ
  data class PaginatedList<T>(
      val items: List<T>,
      val pagination: Pagination
  )
  
  data class Pagination(
      val page: Int,
      val size: Int,
      val total: Int,
      val hasNext: Boolean,
      val hasPrevious: Boolean
  )
  
  // TODO 3: äº²æ‰‹å®ç°HTTPçŠ¶æ€ç å’Œé”™è¯¯å¤„ç†
  enum class HttpStatusCode(val code: Int, val message: String) {
      OK(200, "OK"),
      CREATED(201, "Created"),
      NO_CONTENT(204, "No Content"),
      BAD_REQUEST(400, "Bad Request"),
      UNAUTHORIZED(401, "Unauthorized"),
      FORBIDDEN(403, "Forbidden"),
      NOT_FOUND(404, "Not Found"),
      CONFLICT(409, "Conflict"),
      INTERNAL_SERVER_ERROR(500, "Internal Server Error")
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ‰€æœ‰APIæ¥å£å®šä¹‰
  2. ğŸŒ è®¾è®¡RESTfulè·¯ç”±å’Œèµ„æºç»“æ„
  3. ğŸ“Š å®ç°åˆ†é¡µã€è¿‡æ»¤ã€æ’åºæœºåˆ¶
  4. âš¡ ç¼–å†™HTTPçŠ¶æ€ç å’Œé”™è¯¯å¤„ç†
  5. ğŸƒ æµ‹è¯•APIçš„å¹‚ç­‰æ€§å’Œå®‰å…¨æ€§
- [ ] **APIè®¾è®¡éªŒè¯**: ç¬¦åˆRESTè§„èŒƒï¼Œæ”¯æŒHATEOASï¼Œç‰ˆæœ¬å…¼å®¹
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ èƒ½è®¾è®¡å‡ºæ”¯æŒåƒä¸‡çº§è¯·æ±‚çš„REST APIå—ï¼Ÿ
- [ ] **æ¶æ„æ£€æŸ¥**: â–¡ è·¯ç”±è®¾è®¡åˆç† â–¡ çŠ¶æ€ç æ­£ç¡® â–¡ åˆ†é¡µæ”¯æŒ â–¡ é”™è¯¯å¤„ç†
- [ ] **æ–‡ä»¶**: `student_progress/api_design/rest/`

#### Task 9.1.7: GraphQLæ ¸å¿ƒæ¦‚å¿µ (5åˆ†é’Ÿ) â° [Intermediate]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºçµæ´»çš„GraphQL APIç³»ç»Ÿ ğŸ•°ï¸

- [ ] **Intermediateç›®æ ‡**: äº²æ‰‹å®ç°å¯æ‰©å±•çš„GraphQLæœåŠ¡æ¶æ„
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šè®¾è®¡é«˜æ•ˆçš„GraphQL Schemaå’Œè§£æå™¨
  
  // GraphQL Schemaå®šä¹‰
  val CHAT_APP_SCHEMA = """
      type User {
          id: ID!
          username: String!
          avatarUrl: String
          isOnline: Boolean!
          lastActive: String!
          profile: UserProfile
          conversations: [Conversation!]!
          friends: [User!]!
      }
      
      type UserProfile {
          bio: String
          location: String
          birthday: String
          privacySettings: PrivacySettings!
      }
      
      type Conversation {
          id: ID!
          title: String
          type: ConversationType!
          participants: [User!]!
          messages(first: Int, after: String): MessageConnection!
          lastMessage: Message
          unreadCount: Int!
      }
      
      type Message {
          id: ID!
          content: String!
          sender: User!
          conversation: Conversation!
          timestamp: String!
          status: MessageStatus!
          readBy: [ReadReceipt!]!
      }
      
      type MessageConnection {
          edges: [MessageEdge!]!
          pageInfo: PageInfo!
      }
      
      type MessageEdge {
          node: Message!
          cursor: String!
      }
      
      type PageInfo {
          hasNextPage: Boolean!
          hasPreviousPage: Boolean!
          startCursor: String
          endCursor: String
      }
      
      enum ConversationType {
          DIRECT
          GROUP
      }
      
      enum MessageStatus {
          SENDING
          SENT
          DELIVERED
          READ
      }
      
      type Query {
          user(id: ID!): User
          users(first: Int, search: String): UserConnection!
          conversation(id: ID!): Conversation
          conversations(first: Int, after: String): ConversationConnection!
      }
      
      type Mutation {
          sendMessage(input: SendMessageInput!): SendMessagePayload!
          createConversation(input: CreateConversationInput!): CreateConversationPayload!
          updateUser(input: UpdateUserInput!): UpdateUserPayload!
      }
      
      type Subscription {
          messageAdded(conversationId: ID!): Message!
          userStatusChanged(userId: ID!): User!
          conversationUpdated(conversationId: ID!): Conversation!
      }
  """.trimIndent()
  
  // TODO 1: äº²æ‰‹å®ç°GraphQLè§£æå™¨
  class UserResolver {
      suspend fun getUser(id: String): User? {
          // TODO: ä»æ•°æ®åº“åŠ è½½ç”¨æˆ·æ•°æ®
          return null
      }
      
      suspend fun getUserConversations(userId: String, first: Int?, after: String?): ConversationConnection {
          // TODO: å®ç°åŸºäºæ¸¸æ ‡çš„åˆ†é¡µæŸ¥è¯¢
          return ConversationConnection(emptyList(), PageInfo())
      }
      
      suspend fun getUserFriends(userId: String): List<User> {
          // TODO: å®ç°å¤æ‚çš„å…³è”æŸ¥è¯¢
          return emptyList()
      }
  }
  
  // TODO 2: äº²æ‰‹å®ç°é«˜æ•ˆçš„DataLoader
  class ChatAppDataLoader {
      private val userLoader = DataLoader<String, User> { userIds ->
          // TODO: æ‰¹é‡åŠ è½½ç”¨æˆ·æ•°æ®ï¼Œè§£å†³N+1é—®é¢˜
          CompletableFuture.completedFuture(emptyList())
      }
      
      private val messageLoader = DataLoader<String, List<Message>> { conversationIds ->
          // TODO: æ‰¹é‡åŠ è½½æ¶ˆæ¯æ•°æ®
          CompletableFuture.completedFuture(emptyList())
      }
      
      fun getUserLoader(): DataLoader<String, User> = userLoader
      fun getMessageLoader(): DataLoader<String, List<Message>> = messageLoader
  }
  
  // TODO 3: äº²æ‰‹å®ç°GraphQLè®¢é˜…ç³»ç»Ÿ
  class ChatSubscriptionManager {
      private val messageSubscriptions = mutableMapOf<String, MutableList<Publisher<Message>>>()
      
      fun subscribeToMessages(conversationId: String): Flow<Message> {
          // TODO: å®ç°å®æ—¶æ¶ˆæ¯è®¢é˜…
          return flow { }
      }
      
      fun publishMessage(conversationId: String, message: Message) {
          // TODO: å‘è®¢é˜…è€…å‘é€æ–°æ¶ˆæ¯
      }
      
      fun unsubscribe(conversationId: String, subscriber: Publisher<Message>) {
          // TODO: æ¸…ç†è®¢é˜…è€…
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥å®Œæ•´çš„GraphQL Schemaå®šä¹‰
  2. ğŸ•°ï¸ å®ç°æ‰€æœ‰å­—æ®µçš„è§£æå™¨å’Œæ•°æ®åŠ è½½å™¨
  3. ğŸ“Š æ„å»ºé«˜æ•ˆçš„DataLoaderè§£å†³N+1é—®é¢˜
  4. ğŸ”„ å®ç°å®æ—¶è®¢é˜…å’Œå˜æ›´é€šçŸ¥
  5. ğŸƒ æµ‹è¯•å¤æ‚æŸ¥è¯¢çš„æ€§èƒ½å’Œç¼“å­˜ç­–ç•¥
- [ ] **GraphQLæ€§èƒ½éªŒè¯**: è§£å†³N+1é—®é¢˜ï¼ŒæŸ¥è¯¢æ·±åº¦é™åˆ¶ï¼Œç¼“å­˜ç­–ç•¥
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ çš„GraphQL APIèƒ½æ”¯æŒå…¨å¹³å°çš„å¤æ‚æŸ¥è¯¢å—ï¼Ÿ
- [ ] **çµæ´»æ€§æ£€æŸ¥**: â–¡ Schemaè®¾è®¡åˆç† â–¡ DataLoaderä¼˜åŒ– â–¡ è®¢é˜…å®æ—¶æ€§ â–¡ ç¼“å­˜ç­–ç•¥
- [ ] **æ–‡ä»¶**: `student_progress/api_design/graphql/`

#### Task 9.1.8: gRPCæ€§èƒ½ç‰¹ç‚¹ (5åˆ†é’Ÿ) â° [Advanced]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºé«˜æ€§èƒ½çš„gRPCæœåŠ¡æ¶æ„ âš¡

- [ ] **Advancedç›®æ ‡**: äº²æ‰‹å®ç°ä¼ä¸šçº§çš„gRPCæœåŠ¡å’Œå®¢æˆ·ç«¯
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```proto
  // ç›®æ ‡ï¼šè®¾è®¡ä½å»¶è¿Ÿã€é«˜ååçš„èŠå¤©æœåŠ¡
  
  // chat_service.proto
  syntax = "proto3";
  
  package chat.v1;
  
  import "google/protobuf/timestamp.proto";
  import "google/protobuf/empty.proto";
  
  // ç”¨æˆ·æœåŠ¡å®šä¹‰
  service UserService {
      rpc GetUser(GetUserRequest) returns (User);
      rpc CreateUser(CreateUserRequest) returns (User);
      rpc UpdateUser(UpdateUserRequest) returns (User);
      rpc GetUserFriends(GetUserFriendsRequest) returns (stream User);
      rpc SearchUsers(SearchUsersRequest) returns (SearchUsersResponse);
  }
  
  // æ¶ˆæ¯æœåŠ¡å®šä¹‰
  service MessageService {
      rpc SendMessage(SendMessageRequest) returns (Message);
      rpc GetMessages(GetMessagesRequest) returns (stream Message);
      rpc SubscribeToMessages(SubscribeRequest) returns (stream Message);
      rpc MarkMessageAsRead(MarkAsReadRequest) returns (google.protobuf.Empty);
      rpc DeleteMessage(DeleteMessageRequest) returns (google.protobuf.Empty);
  }
  
  // æ¶ˆæ¯å®šä¹‰
  message User {
      string user_id = 1;
      string username = 2;
      string avatar_url = 3;
      bool is_online = 4;
      google.protobuf.Timestamp last_active = 5;
      UserProfile profile = 6;
  }
  
  message UserProfile {
      string bio = 1;
      string location = 2;
      google.protobuf.Timestamp birthday = 3;
      PrivacySettings privacy_settings = 4;
  }
  
  message Message {
      string message_id = 1;
      string conversation_id = 2;
      string sender_id = 3;
      string content = 4;
      google.protobuf.Timestamp timestamp = 5;
      MessageStatus status = 6;
      MessageType type = 7;
      map<string, string> metadata = 8;
  }
  
  enum MessageStatus {
      MESSAGE_STATUS_UNKNOWN = 0;
      MESSAGE_STATUS_SENDING = 1;
      MESSAGE_STATUS_SENT = 2;
      MESSAGE_STATUS_DELIVERED = 3;
      MESSAGE_STATUS_READ = 4;
  }
  
  enum MessageType {
      MESSAGE_TYPE_TEXT = 0;
      MESSAGE_TYPE_IMAGE = 1;
      MESSAGE_TYPE_FILE = 2;
      MESSAGE_TYPE_VOICE = 3;
  }
  ```
  
  ```kotlin
  // TODO 1: äº²æ‰‹å®ç°gRPCæœåŠ¡ç«¯
  class ChatMessageService : MessageServiceGrpcKt.MessageServiceCoroutineImplBase() {
      
      override suspend fun sendMessage(request: SendMessageRequest): Message {
          // TODO: å®ç°é«˜æ€§èƒ½æ¶ˆæ¯å‘é€
          return Message.newBuilder()
              .setMessageId(generateMessageId())
              .setConversationId(request.conversationId)
              .setSenderId(request.senderId)
              .setContent(request.content)
              .setTimestamp(Timestamps.fromMillis(System.currentTimeMillis()))
              .setStatus(MessageStatus.MESSAGE_STATUS_SENT)
              .build()
      }
      
      override fun getMessages(request: GetMessagesRequest): Flow<Message> = flow {
          // TODO: å®ç°æµå¼æ¶ˆæ¯ä¼ è¾“
          val messages = messageRepository.getMessages(
              conversationId = request.conversationId,
              limit = request.limit,
              before = request.beforeTimestamp
          )
          messages.forEach { emit(it) }
      }
      
      override fun subscribeToMessages(request: SubscribeRequest): Flow<Message> = flow {
          // TODO: å®ç°å®æ—¶æ¶ˆæ¯æ¨é€
          messageSubscriptionManager.subscribe(request.conversationId)
              .collect { message -> emit(message) }
      }
  }
  
  // TODO 2: äº²æ‰‹å®ç°gRPCå®¢æˆ·ç«¯
  class GrpcChatClient {
      private val channel = ManagedChannelBuilder.forAddress("localhost", 9090)
          .usePlaintext()
          .keepAliveTime(30, TimeUnit.SECONDS)
          .keepAliveTimeout(5, TimeUnit.SECONDS)
          .keepAliveWithoutCalls(true)
          .maxInboundMessageSize(1024 * 1024) // 1MB
          .build()
      
      private val messageService = MessageServiceGrpcKt.MessageServiceCoroutineStub(channel)
      private val userService = UserServiceGrpcKt.UserServiceCoroutineStub(channel)
      
      suspend fun sendMessage(conversationId: String, content: String): Message {
          val request = SendMessageRequest.newBuilder()
              .setConversationId(conversationId)
              .setSenderId(getCurrentUserId())
              .setContent(content)
              .build()
          
          return try {
              messageService.sendMessage(request)
          } catch (e: StatusException) {
              // TODO: å®ç°é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
              throw ChatException("Failed to send message", e)
          }
      }
      
      fun subscribeToMessages(conversationId: String): Flow<Message> {
          val request = SubscribeRequest.newBuilder()
              .setConversationId(conversationId)
              .build()
          
          return messageService.subscribeToMessages(request)
              .catch { e -> 
                  // TODO: å®ç°è¿æ¥æ–­å¼€é‡è¿é€»è¾‘
                  Log.e("gRPC", "Subscription failed", e)
              }
      }
  }
  
  // TODO 3: äº²æ‰‹å®ç°gRPCæ€§èƒ½ä¼˜åŒ–
  class GrpcPerformanceOptimizer {
      fun createOptimizedChannel(host: String, port: Int): ManagedChannel {
          return NettyChannelBuilder.forAddress(host, port)
              .keepAliveTime(30, TimeUnit.SECONDS)
              .keepAliveTimeout(5, TimeUnit.SECONDS)
              .keepAliveWithoutCalls(true)
              .maxInboundMessageSize(4 * 1024 * 1024) // 4MB
              .maxOutboundMessageSize(4 * 1024 * 1024)
              .usePlaintext()
              // TODO: äº²æ‰‹é…ç½®çº¿ç¨‹æ± å’Œè¿æ¥æ± 
              .executor(Executors.newFixedThreadPool(4))
              .build()
      }
      
      fun enableCompression(stub: AbstractStub<*>): AbstractStub<*> {
          // TODO: å¯ç”¨gRPCå‹ç¼©ä¼˜åŒ–
          return stub.withCompression("gzip")
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥Protocol Bufferså®šä¹‰å’Œç¼–è¯‘
  2. âš¡ å®ç°gRPCæœåŠ¡ç«¯å’Œæµå¼å¤„ç†
  3. ğŸ“± æ„å»ºé«˜æ€§èƒ½çš„Android gRPCå®¢æˆ·ç«¯
  4. ğŸ”„ å®ç°å®æ—¶åŒå‘æµé€šä¿¡
  5. ğŸƒ æµ‹è¯•å’Œå¯¹æ¯”gRPC vs RESTæ€§èƒ½
- [ ] **gRPCæ€§èƒ½éªŒè¯**: ä¼ è¾“é€Ÿåº¦æå‡2xï¼Œå†…å­˜ä½¿ç”¨å‡å°‘50%
- [ ] **Advancedæ£€æŸ¥ç‚¹**: ä½ çš„gRPCæœåŠ¡èƒ½æ”¯æŒåä¸‡çº§å¹¶å‘è¿æ¥å—ï¼Ÿ
- [ ] **æ€§èƒ½æ£€æŸ¥**: â–¡ äºŒè¿›åˆ¶åè®®ä¼˜åŒ– â–¡ HTTP/2å¤šè·¯å¤ç”¨ â–¡ æµå¼å¤„ç† â–¡ è¿æ¥æ± ç®¡ç†
- [ ] **æ–‡ä»¶**: `student_progress/api_design/grpc/`

#### Task 9.1.9: ç§»åŠ¨ç«¯åè®®é€‰å‹ (5åˆ†é’Ÿ) â° [Advanced]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºåè®®å†³ç­–æ¡†æ¶å’Œæ€§èƒ½å¯¹æ¯”ç³»ç»Ÿ ğŸ¤

- [ ] **Advancedç›®æ ‡**: äº²æ‰‹å®ç°æ™ºèƒ½åè®®é€‰æ‹©å’Œæ€§èƒ½ç›‘æ§ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°æ™ºèƒ½çš„åè®®é€‰æ‹©å’Œåˆ‡æ¢ç³»ç»Ÿ
  
  // åè®®æ€§èƒ½ç‰¹å¾å®šä¹‰
  data class ProtocolCharacteristics(
      val name: String,
      val overhead: Int, // å­—èŠ‚
      val latency: Long, // æ¯«ç§’
      val throughput: Long, // å­—èŠ‚/ç§’
      val batteryImpact: Float, // 0.0-1.0
      val developmentComplexity: Int, // 1-10
      val serverCost: Float, // ç›¸å¯¹æˆæœ¬
      val supportedFeatures: Set<ProtocolFeature>
  )
  
  enum class ProtocolFeature {
      REAL_TIME_MESSAGING,
      FILE_UPLOAD,
      STREAMING,
      OFFLINE_SYNC,
      COMPRESSION,
      ENCRYPTION,
      MULTIPLEXING,
      BIDIRECTIONAL
  }
  
  // TODO 1: äº²æ‰‹å®ç°åè®®æ€§èƒ½è¯„ä¼°å™¨
  class ProtocolPerformanceEvaluator {
      private val benchmarkResults = mutableMapOf<String, ProtocolBenchmark>()
      
      suspend fun benchmarkProtocol(protocol: String, testScenario: TestScenario): ProtocolBenchmark {
          // TODO: äº²æ‰‹å®ç°å„ç§åè®®çš„æ€§èƒ½æµ‹è¯•
          val startTime = System.currentTimeMillis()
          
          when (protocol) {
              "REST" -> {
                  val result = benchmarkREST(testScenario)
                  return ProtocolBenchmark(
                      protocol = protocol,
                      requestsPerSecond = result.rps,
                      averageLatency = result.latency,
                      dataOverhead = result.overhead,
                      powerConsumption = result.power
                  )
              }
              "GraphQL" -> {
                  // TODO: GraphQLæ€§èƒ½æµ‹è¯•
                  return benchmarkGraphQL(testScenario)
              }
              "gRPC" -> {
                  // TODO: gRPCæ€§èƒ½æµ‹è¯•
                  return benchmarkGRPC(testScenario)
              }
              "WebSocket" -> {
                  // TODO: WebSocketæ€§èƒ½æµ‹è¯•
                  return benchmarkWebSocket(testScenario)
              }
              else -> throw IllegalArgumentException("Unsupported protocol: $protocol")
          }
      }
      
      private suspend fun benchmarkREST(scenario: TestScenario): BenchmarkResult {
          // TODO: äº²æ‰‹å®ç°RESTæ€§èƒ½æµ‹è¯•
          return BenchmarkResult(0, 0, 0, 0.0f)
      }
  }
  
  // TODO 2: äº²æ‰‹å®ç°æ™ºèƒ½åè®®é€‰æ‹©å™¨
  class SmartProtocolSelector {
      fun selectOptimalProtocol(
          requirements: CommunicationRequirements,
          constraints: SystemConstraints
      ): ProtocolRecommendation {
          
          val scores = mutableMapOf<String, Float>()
          
          // æŒ‰éœ€æ±‚è¯„åˆ†å„åè®®
          when {
              requirements.realTimeRequired -> {
                  scores["WebSocket"] = 0.9f
                  scores["gRPC"] = 0.8f
                  scores["REST"] = 0.3f
                  scores["GraphQL"] = 0.4f
              }
              requirements.complexQueries -> {
                  scores["GraphQL"] = 0.9f
                  scores["REST"] = 0.6f
                  scores["gRPC"] = 0.7f
                  scores["WebSocket"] = 0.3f
              }
              requirements.highThroughput -> {
                  scores["gRPC"] = 0.9f
                  scores["WebSocket"] = 0.7f
                  scores["REST"] = 0.5f
                  scores["GraphQL"] = 0.4f
              }
              else -> {
                  scores["REST"] = 0.8f
                  scores["GraphQL"] = 0.6f
                  scores["gRPC"] = 0.5f
                  scores["WebSocket"] = 0.4f
              }
          }
          
          // æ ¹æ®çº¦æŸè°ƒæ•´è¯„åˆ†
          if (constraints.developmentTime < 30) { // å¤©
              scores["REST"] = scores["REST"]!! * 1.2f
              scores["gRPC"] = scores["gRPC"]!! * 0.8f
          }
          
          if (constraints.batteryLife == BatteryPriority.HIGH) {
              scores["gRPC"] = scores["gRPC"]!! * 1.1f
              scores["WebSocket"] = scores["WebSocket"]!! * 0.9f
          }
          
          val bestProtocol = scores.maxByOrNull { it.value }?.key ?: "REST"
          
          return ProtocolRecommendation(
              protocol = bestProtocol,
              confidence = scores[bestProtocol]!!,
              reasons = generateReasons(bestProtocol, requirements, constraints),
              alternatives = scores.toList().sortedByDescending { it.second }.take(3)
          )
      }
      
      private fun generateReasons(
          protocol: String,
          requirements: CommunicationRequirements,
          constraints: SystemConstraints
      ): List<String> {
          // TODO: äº²æ‰‹å®ç°å†³ç­–è¯´æ˜ç”Ÿæˆ
          return listOf("Protocol best fits requirements")
      }
  }
  
  // TODO 3: äº²æ‰‹å®ç°åè®®åˆ‡æ¢ç³»ç»Ÿ
  class AdaptiveProtocolManager {
      private var currentProtocol = "REST"
      private val performanceMonitor = ProtocolPerformanceMonitor()
      
      suspend fun evaluateAndSwitch() {
          val currentPerformance = performanceMonitor.getCurrentMetrics()
          
          if (shouldSwitchProtocol(currentPerformance)) {
              val newProtocol = selectBetterProtocol(currentPerformance)
              switchProtocol(newProtocol)
          }
      }
      
      private fun shouldSwitchProtocol(metrics: PerformanceMetrics): Boolean {
          // TODO: äº²æ‰‹å®ç°åˆ‡æ¢å†³ç­–é€»è¾‘
          return metrics.averageLatency > 1000 || // 1ç§’
                 metrics.errorRate > 0.05 || // 5%
                 metrics.batteryDrain > 0.8 // 80%
      }
      
      private suspend fun switchProtocol(newProtocol: String) {
          // TODO: äº²æ‰‹å®ç°å¹³æ»‘çš„åè®®åˆ‡æ¢
          Log.i("ProtocolManager", "Switching from $currentProtocol to $newProtocol")
          currentProtocol = newProtocol
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥åè®®ç‰¹å¾å’Œæ€§èƒ½è¯„ä¼°ç³»ç»Ÿ
  2. ğŸ¤ å®ç°æ™ºèƒ½åè®®é€‰æ‹©å’Œå†³ç­–ç®—æ³•
  3. ğŸ“Š æ„å»ºåè®®æ€§èƒ½æµ‹è¯•å’Œå¯¹æ¯”æ¡†æ¶
  4. ğŸ”„ å®ç°å®æ—¶åè®®åˆ‡æ¢å’Œé€‚é…ç³»ç»Ÿ
  5. ğŸƒ æµ‹è¯•å„ç§åœºæ™¯ä¸‹çš„åè®®æ€§èƒ½è¡¨ç°
- [ ] **åè®®é€‰å‹éªŒè¯**: å†³ç­–ç²¾åº¦>90%ï¼Œæ€§èƒ½æå‡2x+ï¼Œèµ„æºçœè…30%
- [ ] **Advancedæ£€æŸ¥ç‚¹**: ä½ çš„åè®®é€‰æ‹©ç³»ç»Ÿèƒ½é€‚åº”å¤æ‚çš„ä¸šåŠ¡åœºæ™¯å—ï¼Ÿ
- [ ] **æ™ºèƒ½æ£€æŸ¥**: â–¡ æ€§èƒ½å¯¹æ¯”å‡†ç¡® â–¡ é€‰æ‹©é€»è¾‘åˆç† â–¡ åˆ‡æ¢æœºåˆ¶ç¨³å®š â–¡ ç›‘æ§ç³»ç»Ÿå®Œå–„
- [ ] **æ–‡ä»¶**: `student_progress/api_design/protocol_selector/`

#### Task 9.1.10: æ•°æ®å‹ç¼©ä¸ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Senior]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºæè‡´æ•°æ®ä¼ è¾“ä¼˜åŒ–ç³»ç»Ÿ ğŸš€

- [ ] **Seniorç›®æ ‡**: äº²æ‰‹å®ç°ä¼ä¸šçº§æ•°æ®å‹ç¼©å’Œä¼ è¾“ä¼˜åŒ–ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°æ•°æ®ä¼ è¾“90%å‹ç¼©æ•ˆæœçš„ä¼˜åŒ–ç³»ç»Ÿ
  
  // å¤šå±‚æ¬¡å‹ç¼©ç­–ç•¥
  interface CompressionStrategy {
      suspend fun compress(data: ByteArray): CompressedData
      suspend fun decompress(compressedData: CompressedData): ByteArray
      fun getCompressionRatio(): Float
      fun getCompressionSpeed(): Long // æ¯«ç§’
  }
  
  // TODO 1: äº²æ‰‹å®ç°å¤šç§å‹ç¼©ç®—æ³•
  class GzipCompressionStrategy : CompressionStrategy {
      override suspend fun compress(data: ByteArray): CompressedData {
          // TODO: äº²æ‰‹å®ç°Gzipå‹ç¼©
          val outputStream = ByteArrayOutputStream()
          val gzipStream = GzipOutputStream(outputStream)
          
          gzipStream.write(data)
          gzipStream.close()
          
          return CompressedData(
              data = outputStream.toByteArray(),
              originalSize = data.size,
              compressedSize = outputStream.size(),
              algorithm = "gzip",
              compressionTime = 0L
          )
      }
      
      override suspend fun decompress(compressedData: CompressedData): ByteArray {
          // TODO: äº²æ‰‹å®ç°Gzipè§£å‹ç¼©
          val inputStream = ByteArrayInputStream(compressedData.data)
          val gzipStream = GzipInputStream(inputStream)
          return gzipStream.readBytes()
      }
  }
  
  class BrotliCompressionStrategy : CompressionStrategy {
      override suspend fun compress(data: ByteArray): CompressedData {
          // TODO: äº²æ‰‹å®ç°Brotliå‹ç¼©ï¼ˆæ›´é«˜æ•ˆï¼‰
          val encoder = BrotliEncoder()
          val compressed = encoder.compress(data)
          
          return CompressedData(
              data = compressed,
              originalSize = data.size,
              compressedSize = compressed.size,
              algorithm = "brotli",
              compressionTime = 0L
          )
      }
  }
  
  // TODO 2: äº²æ‰‹å®ç°æ™ºèƒ½æ•°æ®ä¼˜åŒ–ç³»ç»Ÿ
  class DataOptimizer {
      fun optimizeJsonPayload(json: String): OptimizedPayload {
          // TODO: äº²æ‰‹å®ç°JSONæ•°æ®ä¼˜åŒ–
          
          // 1. åˆ é™¤ä¸å¿…è¦çš„ç©ºæ ¼å’Œæ¢è¡Œ
          var optimized = json.replace("\\s+".toRegex(), " ")
          
          // 2. ç¼©çŸ­å­—æ®µå
          val fieldMapping = mapOf(
              "conversationId" to "cId",
              "messageId" to "mId",
              "timestamp" to "ts",
              "senderId" to "sId",
              "content" to "c",
              "status" to "st"
          )
          
          fieldMapping.forEach { (original, shortened) ->
              optimized = optimized.replace("\"$original\":", "\"$shortened\":")
          }
          
          // 3. æ•°æ®ç±»å‹ä¼˜åŒ–
          optimized = optimizeDataTypes(optimized)
          
          return OptimizedPayload(
              originalData = json,
              optimizedData = optimized,
              originalSize = json.toByteArray().size,
              optimizedSize = optimized.toByteArray().size,
              fieldMapping = fieldMapping
          )
      }
      
      private fun optimizeDataTypes(json: String): String {
          // TODO: äº²æ‰‹ä¼˜åŒ–æ•°æ®ç±»å‹ï¼ˆæ•´æ•°ã€å¸ƒå°”å€¼ç­‰ï¼‰
          var optimized = json
          
          // å¸ƒå°”å€¼ä¼˜åŒ–ï¼štrue/false -> 1/0
          optimized = optimized.replace(":true", ":1")
          optimized = optimized.replace(":false", ":0")
          
          // æ—¶é—´æˆ³ä¼˜åŒ–ï¼šä½¿ç”¨ç›¸å¯¹æ—¶é—´
          optimized = optimizeTimestamps(optimized)
          
          return optimized
      }
      
      private fun optimizeTimestamps(json: String): String {
          // TODO: äº²æ‰‹å®ç°æ—¶é—´æˆ³ä¼˜åŒ–
          return json
      }
  }
  
  // TODO 3: äº²æ‰‹å®ç°è‡ªé€‚åº”å‹ç¼©ç®¡ç†å™¨
  class AdaptiveCompressionManager {
      private val strategies = listOf(
          GzipCompressionStrategy(),
          BrotliCompressionStrategy(),
          LZ4CompressionStrategy(),
          SnappyCompressionStrategy()
      )
      
      private val performanceHistory = mutableMapOf<String, CompressionPerformance>()
      
      suspend fun compressOptimally(data: ByteArray, priority: CompressionPriority): CompressedData {
          val bestStrategy = when (priority) {
              CompressionPriority.SIZE -> findBestCompressionRatio(data)
              CompressionPriority.SPEED -> findFastestCompression(data)
              CompressionPriority.BALANCED -> findBalancedCompression(data)
          }
          
          val startTime = System.currentTimeMillis()
          val result = bestStrategy.compress(data)
          val endTime = System.currentTimeMillis()
          
          // è®°å½•æ€§èƒ½æ•°æ®
          recordPerformance(bestStrategy::class.simpleName!!, endTime - startTime, result)
          
          return result
      }
      
      private suspend fun findBestCompressionRatio(data: ByteArray): CompressionStrategy {
          // TODO: äº²æ‰‹å®ç°æœ€ä¼˜å‹ç¼©ç­–ç•¥é€‰æ‹©
          var bestStrategy = strategies.first()
          var bestRatio = 0f
          
          strategies.forEach { strategy ->
              val sample = data.take(1024).toByteArray() // å–æ ·æµ‹è¯•
              val compressed = strategy.compress(sample)
              val ratio = compressed.getCompressionRatio()
              
              if (ratio > bestRatio) {
                  bestRatio = ratio
                  bestStrategy = strategy
              }
          }
          
          return bestStrategy
      }
      
      private fun recordPerformance(strategyName: String, time: Long, result: CompressedData) {
          // TODO: äº²æ‰‹å®ç°æ€§èƒ½è®°å½•å’Œå­¦ä¹ 
          val performance = performanceHistory[strategyName] ?: CompressionPerformance()
          performance.addMeasurement(time, result.getCompressionRatio())
          performanceHistory[strategyName] = performance
      }
  }
  
  // TODO 4: äº²æ‰‹å®ç°æµå¼å‹ç¼©ç³»ç»Ÿ
  class StreamingCompressionManager {
      fun createCompressedStream(outputStream: OutputStream, strategy: CompressionStrategy): CompressedOutputStream {
          // TODO: äº²æ‰‹å®ç°æµå¼å‹ç¼©
          return CompressedOutputStream(outputStream, strategy)
      }
      
      suspend fun compressInChunks(data: Flow<ByteArray>): Flow<CompressedData> = flow {
          // TODO: äº²æ‰‹å®ç°åˆ†å—å‹ç¼©
          data.collect { chunk ->
              val compressed = adaptiveCompressionManager.compressOptimally(
                  chunk, 
                  CompressionPriority.BALANCED
              )
              emit(compressed)
          }
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ‰€æœ‰å‹ç¼©ç®—æ³•å’Œä¼˜åŒ–ç­–ç•¥
  2. ğŸš€ å®ç°æ•°æ®æ ¼å¼ä¼˜åŒ–å’ŒJSONæ•°æ®ç²¾ç®€
  3. ğŸ“Š æ„å»ºè‡ªé€‚åº”å‹ç¼©ç­–ç•¥é€‰æ‹©ç³»ç»Ÿ
  4. ğŸ”„ å®ç°æµå¼å‹ç¼©å’Œåˆ†å—å¤„ç†
  5. ğŸƒ æµ‹è¯•å„ç§åœºæ™¯ä¸‹çš„å‹ç¼©æ•ˆæœå’Œæ€§èƒ½
- [ ] **å‹ç¼©æ•ˆæœéªŒè¯**: æ•°æ®ä¼ è¾“å‡å°‘70%+ï¼Œå‹ç¼©æ—¶é—´<100msï¼Œç”µé‡æ¶ˆè€—å‡å°‘50%
- [ ] **Senioræ£€æŸ¥ç‚¹**: ä½ çš„æ•°æ®ä¼˜åŒ–ç³»ç»Ÿèƒ½åœ¨å„ç§ç½‘ç»œç¯å¢ƒä¸‹ä¿æŒé«˜æ€§èƒ½å—ï¼Ÿ
- [ ] **ä¼˜åŒ–æ£€æŸ¥**: â–¡ å¤šç®—æ³•é€‚é… â–¡ æ•°æ®ç²¾ç®€æœ‰æ•ˆ â–¡ æµå¼å¤„ç†ç¨³å®š â–¡ æ€§èƒ½ç›‘æ§å®Œæ•´
- [ ] **æ–‡ä»¶**: `student_progress/api_design/compression/`

#### Task 9.1.11: APIç‰ˆæœ¬ç®¡ç† (5åˆ†é’Ÿ) â° [Senior]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºå‘å‰å…¼å®¹çš„APIç‰ˆæœ¬ç®¡ç†ç³»ç»Ÿ ğŸ”„

- [ ] **Seniorç›®æ ‡**: äº²æ‰‹å®ç°ä¼ä¸šçº§APIç‰ˆæœ¬æ¼”è¿›å’Œå…¼å®¹æ€§ç®¡ç†
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°æ”¯æŒå¤šç‰ˆæœ¬å¹¶å­˜çš„APIç®¡ç†ç³»ç»Ÿ
  
  // APIç‰ˆæœ¬ç­–ç•¥å®šä¹‰
  enum class ApiVersionStrategy {
      HEADER_BASED,    // Accept-Version: v2
      URL_PATH,        // /api/v2/users
      QUERY_PARAM,     // /api/users?version=2
      CONTENT_TYPE     // application/vnd.myapi.v2+json
  }
  
  // TODO 1: äº²æ‰‹å®ç°å¤šç‰ˆæœ¬è·¯ç”±ç®¡ç†å™¨
  class ApiVersionManager {
      private val supportedVersions = setOf("v1", "v2", "v3")
      private val defaultVersion = "v2"
      private val deprecatedVersions = mapOf(
          "v1" to "2024-12-31" // å¼ƒç”¨æ—¥æœŸ
      )
      
      fun resolveVersion(request: HttpRequest): ApiVersion {
          val requestedVersion = when (getVersionStrategy()) {
              ApiVersionStrategy.HEADER_BASED -> 
                  request.getHeader("Accept-Version")
              ApiVersionStrategy.URL_PATH -> 
                  extractVersionFromPath(request.path)
              ApiVersionStrategy.QUERY_PARAM -> 
                  request.getQueryParameter("version")
              ApiVersionStrategy.CONTENT_TYPE -> 
                  extractVersionFromContentType(request.getHeader("Content-Type"))
          }
          
          return validateAndResolveVersion(requestedVersion ?: defaultVersion)
      }
      
      private fun validateAndResolveVersion(version: String): ApiVersion {
          // TODO: äº²æ‰‹å®ç°ç‰ˆæœ¬éªŒè¯å’Œè§£æ
          if (version !in supportedVersions) {
              throw UnsupportedApiVersionException(
                  "Version $version is not supported. Supported versions: $supportedVersions"
              )
          }
          
          val isDeprecated = version in deprecatedVersions
          val deprecationDate = deprecatedVersions[version]
          
          return ApiVersion(
              version = version,
              isDeprecated = isDeprecated,
              deprecationDate = deprecationDate,
              supportedFeatures = getVersionFeatures(version)
          )
      }
      
      private fun getVersionFeatures(version: String): Set<ApiFeature> {
          // TODO: äº²æ‰‹å®šä¹‰å„ç‰ˆæœ¬æ”¯æŒçš„åŠŸèƒ½
          return when (version) {
              "v1" -> setOf(ApiFeature.BASIC_MESSAGING, ApiFeature.USER_MANAGEMENT)
              "v2" -> setOf(
                  ApiFeature.BASIC_MESSAGING, 
                  ApiFeature.USER_MANAGEMENT,
                  ApiFeature.GROUP_CHAT,
                  ApiFeature.MESSAGE_REACTIONS
              )
              "v3" -> setOf(
                  ApiFeature.BASIC_MESSAGING,
                  ApiFeature.USER_MANAGEMENT, 
                  ApiFeature.GROUP_CHAT,
                  ApiFeature.MESSAGE_REACTIONS,
                  ApiFeature.VOICE_MESSAGES,
                  ApiFeature.END_TO_END_ENCRYPTION
              )
              else -> emptySet()
          }
      }
  }
  
  // TODO 2: äº²æ‰‹å®ç°å‘å‰å…¼å®¹çš„å“åº”è½¬æ¢å™¨
  class ApiResponseTransformer {
      fun transformResponse(
          response: Any,
          fromVersion: String,
          toVersion: String
      ): Any {
          // TODO: äº²æ‰‹å®ç°ç‰ˆæœ¬é—´çš„æ•°æ®è½¬æ¢
          
          return when (fromVersion to toVersion) {
              "v3" to "v2" -> transformV3ToV2(response)
              "v3" to "v1" -> transformV3ToV1(response)
              "v2" to "v1" -> transformV2ToV1(response)
              else -> response // æ— éœ€è½¬æ¢
          }
      }
      
      private fun transformV3ToV2(response: Any): Any {
          // TODO: äº²æ‰‹å®ç°v3åˆ°v2çš„æ•°æ®è½¬æ¢
          if (response is Message) {
              return MessageV2(
                  id = response.id,
                  content = response.content,
                  senderId = response.senderId,
                  timestamp = response.timestamp,
                  // åˆ é™¤v3ç‰¹æœ‰å­—æ®µï¼švoiceData, encryptionKey
                  reactions = response.reactions
              )
          }
          return response
      }
      
      private fun transformV2ToV1(response: Any): Any {
          // TODO: äº²æ‰‹å®ç°v2åˆ°v1çš„æ•°æ®è½¬æ¢
          if (response is MessageV2) {
              return MessageV1(
                  id = response.id,
                  content = response.content,
                  senderId = response.senderId,
                  timestamp = response.timestamp
                  // åˆ é™¤v2ç‰¹æœ‰å­—æ®µï¼šreactions
              )
          }
          return response
      }
  }
  
  // TODO 3: äº²æ‰‹å®ç°APIå…¼å®¹æ€§æ£€æŸ¥å™¨
  class ApiCompatibilityChecker {
      fun checkCompatibility(
          clientVersion: String,
          serverVersion: String
      ): CompatibilityResult {
          
          val clientFeatures = getVersionFeatures(clientVersion)
          val serverFeatures = getVersionFeatures(serverVersion)
          
          val missingFeatures = clientFeatures - serverFeatures
          val extraFeatures = serverFeatures - clientFeatures
          
          val isCompatible = missingFeatures.isEmpty()
          
          return CompatibilityResult(
              isCompatible = isCompatible,
              missingFeatures = missingFeatures,
              extraFeatures = extraFeatures,
              migrationPath = generateMigrationPath(clientVersion, serverVersion),
              warnings = generateCompatibilityWarnings(clientVersion, serverVersion)
          )
      }
      
      private fun generateMigrationPath(
          fromVersion: String,
          toVersion: String
      ): List<MigrationStep> {
          // TODO: äº²æ‰‹å®ç°å‡çº§è·¯å¾„ç”Ÿæˆ
          return when (fromVersion to toVersion) {
              "v1" to "v2" -> listOf(
                  MigrationStep("Add group chat support", false),
                  MigrationStep("Add message reactions", false)
              )
              "v2" to "v3" -> listOf(
                  MigrationStep("Add voice message support", false),
                  MigrationStep("Enable end-to-end encryption", true)
              )
              else -> emptyList()
          }
      }
  }
  
  // TODO 4: äº²æ‰‹å®ç°ç‰ˆæœ¬è¿ç§»åŠ©æ‰‹
  class ApiVersionMigrationAssistant {
      fun generateClientMigrationGuide(
          fromVersion: String,
          toVersion: String
      ): MigrationGuide {
          // TODO: äº²æ‰‹ç”Ÿæˆå®¢æˆ·ç«¯è¿ç§»æŒ‡å—
          return MigrationGuide(
              title = "Migrate from $fromVersion to $toVersion",
              steps = generateMigrationSteps(fromVersion, toVersion),
              codeExamples = generateCodeExamples(fromVersion, toVersion),
              breakingChanges = identifyBreakingChanges(fromVersion, toVersion)
          )
      }
      
      fun validateMigration(oldCode: String, newVersion: String): ValidationResult {
          // TODO: äº²æ‰‹éªŒè¯è¿ç§»ä»£ç çš„å…¼å®¹æ€§
          return ValidationResult()
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥ç‰ˆæœ¬ç®¡ç†å’Œè·¯ç”±ç³»ç»Ÿ
  2. ğŸ”„ å®ç°å¤šç‰ˆæœ¬æ•°æ®è½¬æ¢å’Œå…¼å®¹å™¨
  3. ğŸ“Š æ„å»ºå…¼å®¹æ€§æ£€æŸ¥å’Œè¯„ä¼°ç³»ç»Ÿ
  4. ğŸ› ï¸ å®ç°è‡ªåŠ¨è¿ç§»åŠ©æ‰‹å’ŒæŒ‡å—ç”Ÿæˆ
  5. ğŸƒ æµ‹è¯•ä¸åŒç‰ˆæœ¬é—´çš„å…¼å®¹æ€§å’Œè¿ç§»
- [ ] **ç‰ˆæœ¬å…¼å®¹éªŒè¯**: å‘å‰å…¼å®¹100%ï¼Œè¿ç§»æ— æŸï¼Œæ€§èƒ½ä¸é™çº§
- [ ] **Senioræ£€æŸ¥ç‚¹**: ä½ çš„APIç‰ˆæœ¬ç®¡ç†èƒ½æ”¯æŒå¹³æ»‘çš„äº§å“è¿­ä»£å—ï¼Ÿ
- [ ] **è¿ç§»æ£€æŸ¥**: â–¡ å¤šç‰ˆæœ¬å¹¶å­˜ â–¡ æ•°æ®è½¬æ¢æ­£ç¡® â–¡ å…¼å®¹æ£€æŸ¥å®Œæ•´ â–¡ è¿ç§»æŒ‡å—æ¸…æ™°
- [ ] **æ–‡ä»¶**: `student_progress/api_design/versioning/`

## Phase 3: èŠå¤©åº”ç”¨æ•°æ®æ¶æ„å®æˆ˜ (35åˆ†é’Ÿæ€»è®¡)

#### Task 9.1.12: éœ€æ±‚åˆ†æä¸å»ºæ¨¡ (5åˆ†é’Ÿ) â° [Primary]
- [ ] **å­¦ä¹ ç›®æ ‡**: åˆ†æIMåº”ç”¨çš„æ•°æ®éœ€æ±‚
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡ç”¨æˆ·ã€ä¼šè¯ã€æ¶ˆæ¯çš„å®ä½“å…³ç³»
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½ç”»å‡ºå®Œæ•´çš„ERå›¾
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/im_database_design/`ç›®å½•å’Œ`schema.md`

#### Task 9.1.13: Roomå®ä½“è®¾è®¡ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: å°†è®¾è®¡è½¬æ¢ä¸ºRoom Entity
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°Userã€Conversationã€Messageå®ä½“ç±»
- [ ] **æ£€æŸ¥ç‚¹**: ä»£ç èƒ½é€šè¿‡ç¼–è¯‘ä¸”å…³ç³»æ­£ç¡®
- [ ] **æ–‡ä»¶**: `im_database_design/entities/`

#### Task 9.1.14: DAOæ¥å£è®¾è®¡ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡é«˜æ•ˆçš„æ•°æ®è®¿é—®æ¥å£
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°å¤æ‚æŸ¥è¯¢ï¼ˆæŒ‰æ—¶é—´åˆ†é¡µã€æœªè¯»æ¶ˆæ¯ç»Ÿè®¡ï¼‰
- [ ] **æ£€æŸ¥ç‚¹**: SQLæŸ¥è¯¢æ€§èƒ½åˆç†
- [ ] **æ–‡ä»¶**: `im_database_design/dao/`

#### Task 9.1.15: åˆ†é¡µåŠ è½½ç­–ç•¥ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡èŠå¤©è®°å½•çš„åˆ†é¡µæœºåˆ¶
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°åŸºäºæ—¶é—´æˆ³çš„åŒå‘åˆ†é¡µ
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¤„ç†æ–°æ¶ˆæ¯æ’å…¥å’Œå†å²åŠ è½½
- [ ] **æ–‡ä»¶**: `im_database_design/PagingHelper.kt`

#### Task 9.1.16: ç¦»çº¿æ•°æ®åŒæ­¥ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡ç¦»çº¿ä¼˜å…ˆçš„æ•°æ®ç­–ç•¥
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°æ¶ˆæ¯çŠ¶æ€ç®¡ç†ï¼ˆå‘é€ä¸­ã€å·²å‘é€ã€å·²è¯»ï¼‰
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¤„ç†ç½‘ç»œä¸­æ–­åœºæ™¯
- [ ] **æ–‡ä»¶**: `im_database_design/SyncManager.kt`

#### Task 9.1.17: æ•°æ®ä¸€è‡´æ€§ä¿è¯ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å¤„ç†å¹¶å‘å†™å…¥å’Œå†²çªè§£å†³
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°ä¹è§‚é”å’Œå†²çªæ£€æµ‹æœºåˆ¶
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½è§£å†³å¤šè®¾å¤‡åŒæ­¥å†²çª
- [ ] **æ–‡ä»¶**: `im_database_design/ConflictResolver.kt`

#### Task 9.1.18: æ€§èƒ½ä¼˜åŒ–å®è·µ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¼˜åŒ–å¤§æ•°æ®é‡æŸ¥è¯¢æ€§èƒ½
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°ç´¢å¼•ä¼˜åŒ–ã€æŸ¥è¯¢æ‰¹å¤„ç†ã€æ‡’åŠ è½½
- [ ] **æ£€æŸ¥ç‚¹**: ä¸‡çº§æ¶ˆæ¯æŸ¥è¯¢<100ms
- [ ] **æ–‡ä»¶**: `im_database_design/PerformanceOptimizer.kt`

## Phase 4: é¢è¯•å®æˆ˜ä¸æ¶æ„æ€ç»´ (20åˆ†é’Ÿæ€»è®¡)

#### Task 9.1.19: æ ¸å¿ƒé—®é¢˜å‡†å¤‡ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: å‡†å¤‡æ•°æ®å±‚è®¾è®¡çš„æ ‡å‡†å›ç­”
- [ ] **å…·ä½“ä»»åŠ¡**: æ•´ç†"å¦‚ä½•è®¾è®¡å¾®ä¿¡çº§åˆ«çš„æ•°æ®å­˜å‚¨"å›ç­”è¦ç‚¹
- [ ] **æ£€æŸ¥ç‚¹**: å›ç­”æ¶µç›–æ€§èƒ½ã€ä¸€è‡´æ€§ã€æ‰©å±•æ€§
- [ ] **æ–‡ä»¶**: `student_progress/chapter9_interview_qa.md`

#### Task 9.1.20: é«˜çº§è¿½é—®åº”å¯¹ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å‡†å¤‡æ·±åº¦æŠ€æœ¯é—®é¢˜
- [ ] **å…·ä½“ä»»åŠ¡**: å‡†å¤‡"æ•°æ®åº“åˆ†åº“åˆ†è¡¨"ã€"è¯»å†™åˆ†ç¦»"ç­‰é«˜çº§è¯é¢˜
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½ä»ä¸šåŠ¡è§’åº¦åˆ†ææŠ€æœ¯é€‰å‹
- [ ] **æ–‡ä»¶**: å®Œå–„é¢è¯•é—®ç­”

#### Task 9.1.21: æ–¹æ¡ˆå¯¹æ¯”ä¸æƒè¡¡ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å±•ç¤ºæ¶æ„å†³ç­–æ€ç»´
- [ ] **å…·ä½“ä»»åŠ¡**: å¯¹æ¯”NoSQL vs SQLåœ¨ç§»åŠ¨ç«¯çš„é€‰æ‹©
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½ç»“åˆå…·ä½“åœºæ™¯åšæŠ€æœ¯é€‰å‹
- [ ] **æ–‡ä»¶**: æ·»åŠ æŠ€æœ¯é€‰å‹å†³ç­–æ ‘

#### Task 9.1.22: ç³»ç»Ÿæ‰©å±•æ€§æ€è€ƒ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è€ƒè™‘ç³»ç»Ÿæ¼”è¿›å’Œæ‰©å±•
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ”¯æŒåƒä¸‡ç”¨æˆ·çš„æ•°æ®æ¶æ„æ¼”è¿›è·¯å¾„
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½é¢„è§æ€§èƒ½ç“¶é¢ˆå’Œè§£å†³æ–¹æ¡ˆ
- [ ] **æ–‡ä»¶**: å®Œæˆæ•°æ®å±‚è®¾è®¡æ€»ç»“

---

# ğŸŒ 9.2 å®æ—¶é€šä¿¡ï¼šWebSocket + æ¨é€æœºåˆ¶

> **ğŸ† å®æˆ˜å“²å­¦**: äº²æ‰‹æ„å»ºåƒä¸‡çº§ç”¨æˆ·çš„å®æ—¶é€šä¿¡ç³»ç»Ÿ
>
> âš ï¸ **ä¸¥æ ¼ç¦æ­¢å¤åˆ¶ç²˜è´´**: æ¯ä¸€è¡Œä»£ç éƒ½å¿…é¡»äº²æ‰‹è¾“å…¥ï¼Œé€šè¿‡æ‰‹æŒ‡è‚Œè‚‰è®°å¿†æŒæ¡å®æ—¶é€šä¿¡çš„åº•å±‚åŸç†
>
> ğŸ’« **å­¦ä¹ è·¯å¾„**: WebSocketåè®® â†’ è¿æ¥ç®¡ç† â†’ å®¹é”™å¤„ç† â†’ æ¨é€é€šé“ â†’ å¤§è§„æ¨¡æ¶æ„

## Phase 5: WebSocketåŸºç¡€ä¸å®ç° (25åˆ†é’Ÿæ€»è®¡)

#### Task 9.2.1: WebSocketåè®®ç†è§£ (5åˆ†é’Ÿ) â° [Primary]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹å®ç°WebSocketåè®®åˆ†æå’Œæ€§èƒ½å¯¹æ¯”ç³»ç»Ÿ ğŸ”

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹å®ç°WebSocketåè®®çš„åº•å±‚æœºåˆ¶å’Œæ€§èƒ½åˆ†æ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°å®Œæ•´çš„WebSocketåè®®åˆ†æå’Œæ€§èƒ½ç›‘æ§
  
  // WebSocketåè®®ç‰¹å¾åˆ†æ
  data class WebSocketFeatures(
      val bidirectional: Boolean = true,
      val lowLatency: Boolean = true,
      val persistentConnection: Boolean = true,
      val binarySupport: Boolean = true,
      val compressionSupport: Boolean = true,
      val multiplexing: Boolean = false // HTTP/2ä¸æ”¯æŒ
  )
  
  // TODO 1: äº²æ‰‹å®ç°WebSocketä¸HTTPçš„æ€§èƒ½å¯¹æ¯”
  class ProtocolPerformanceComparator {
      
      suspend fun compareLatency(): LatencyComparison {
          // TODO: äº²æ‰‹æµ‹è¯•WebSocket vs HTTPçš„å»¶è¿Ÿ
          val httpLatencies = mutableListOf<Long>()
          val wsLatencies = mutableListOf<Long>()
          
          // HTTPè¯·æ±‚å»¶è¿Ÿæµ‹è¯•
          repeat(100) {
              val startTime = System.nanoTime()
              // å‘é€HTTPè¯·æ±‚
              val httpClient = OkHttpClient()
              val request = Request.Builder()
                  .url("https://api.example.com/test")
                  .build()
              httpClient.newCall(request).execute()
              val endTime = System.nanoTime()
              httpLatencies.add((endTime - startTime) / 1_000_000) // è½¬æ¢ä¸ºæ¯«ç§’
          }
          
          // WebSocketæ¶ˆæ¯å»¶è¿Ÿæµ‹è¯•
          repeat(100) {
              val startTime = System.nanoTime()
              // å‘é€WebSocketæ¶ˆæ¯
              webSocketConnection.send("test message")
              // ç­‰å¾…å›å¤
              val endTime = System.nanoTime()
              wsLatencies.add((endTime - startTime) / 1_000_000)
          }
          
          return LatencyComparison(
              httpAverage = httpLatencies.average(),
              wsAverage = wsLatencies.average(),
              httpP95 = httpLatencies.sorted()[95],
              wsP95 = wsLatencies.sorted()[95],
              improvement = (httpLatencies.average() - wsLatencies.average()) / httpLatencies.average() * 100
          )
      }
      
      suspend fun compareThroughput(): ThroughputComparison {
          // TODO: äº²æ‰‹æµ‹è¯•ååé‡å¯¹æ¯”
          val httpThroughput = measureHttpThroughput()
          val wsThroughput = measureWebSocketThroughput()
          
          return ThroughputComparison(
              httpMbps = httpThroughput,
              wsMbps = wsThroughput,
              improvement = (wsThroughput - httpThroughput) / httpThroughput * 100
          )
      }
      
      private suspend fun measureHttpThroughput(): Double {
          // TODO: äº²æ‰‹å®ç°HTTPååé‡æµ‹è¯•
          return 0.0
      }
      
      private suspend fun measureWebSocketThroughput(): Double {
          // TODO: äº²æ‰‹å®ç°WebSocketååé‡æµ‹è¯•
          return 0.0
      }
  }
  
  // TODO 2: äº²æ‰‹å®ç°WebSocketæ¡æ‰‹è¿‡ç¨‹åˆ†æ
  class WebSocketHandshakeAnalyzer {
      
      fun analyzeHandshake(request: String, response: String): HandshakeAnalysis {
          // TODO: äº²æ‰‹è§£æWebSocketæ¡æ‰‹è¿‡ç¨‹
          
          // è§£æè¯·æ±‚å¤´
          val upgradeHeader = extractHeader(request, "Upgrade")
          val connectionHeader = extractHeader(request, "Connection")
          val webSocketKey = extractHeader(request, "Sec-WebSocket-Key")
          val webSocketVersion = extractHeader(request, "Sec-WebSocket-Version")
          
          // éªŒè¯æ¡æ‰‹è¦æ±‚
          val isValidUpgrade = upgradeHeader.equals("websocket", ignoreCase = true)
          val isValidConnection = connectionHeader.contains("Upgrade", ignoreCase = true)
          val isValidVersion = webSocketVersion == "13"
          
          // è§£æå“åº”
          val acceptKey = extractHeader(response, "Sec-WebSocket-Accept")
          val expectedAcceptKey = generateAcceptKey(webSocketKey)
          val isValidAccept = acceptKey == expectedAcceptKey
          
          return HandshakeAnalysis(
              isValidHandshake = isValidUpgrade && isValidConnection && isValidVersion && isValidAccept,
              requestHeaders = parseHeaders(request),
              responseHeaders = parseHeaders(response),
              securityChecks = performSecurityChecks(request, response)
          )
      }
      
      private fun generateAcceptKey(webSocketKey: String): String {
          // TODO: äº²æ‰‹å®ç°Sec-WebSocket-Acceptçš„ç”Ÿæˆç®—æ³•
          val guidString = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
          val combined = webSocketKey + guidString
          val sha1Hash = MessageDigest.getInstance("SHA-1").digest(combined.toByteArray())
          return Base64.getEncoder().encodeToString(sha1Hash)
      }
  }
  
  // TODO 3: äº²æ‰‹å®ç°WebSocketå¸§æ ¼å¼è§£æå™¨
  class WebSocketFrameParser {
      
      fun parseFrame(frameBytes: ByteArray): WebSocketFrame {
          // TODO: äº²æ‰‹è§£æWebSocketå¸§ç»“æ„
          val buffer = frameBytes.copyOf()
          var offset = 0
          
          // ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼šFIN + RSV + OPCODE
          val firstByte = buffer[offset++].toInt() and 0xFF
          val fin = (firstByte and 0x80) != 0
          val rsv1 = (firstByte and 0x40) != 0
          val rsv2 = (firstByte and 0x20) != 0
          val rsv3 = (firstByte and 0x10) != 0
          val opcode = firstByte and 0x0F
          
          // ç¬¬äºŒä¸ªå­—èŠ‚ï¼šMASK + è½½è·é•¿åº¦
          val secondByte = buffer[offset++].toInt() and 0xFF
          val masked = (secondByte and 0x80) != 0
          var payloadLength = (secondByte and 0x7F).toLong()
          
          // æ‰©å±•è½½è·é•¿åº¦
          when (payloadLength) {
              126L -> {
                  payloadLength = ((buffer[offset++].toInt() and 0xFF) shl 8) or
                                  (buffer[offset++].toInt() and 0xFF)
              }
              127L -> {
                  // 64ä½é•¿åº¦ï¼ˆå®é™…ä¸Šåªä½¿ç”¨63ä½ï¼‰
                  payloadLength = 0
                  for (i in 0..7) {
                      payloadLength = (payloadLength shl 8) or (buffer[offset++].toLong() and 0xFF)
                  }
              }
          }
          
          // æ©ç é”®
          val maskingKey = if (masked) {
              ByteArray(4) { buffer[offset++] }
          } else {
              null
          }
          
          // è½½è·æ•°æ®
          val payload = ByteArray(payloadLength.toInt()) { 
              val data = buffer[offset++]
              if (masked && maskingKey != null) {
                  (data.toInt() xor maskingKey[it % 4].toInt()).toByte()
              } else {
                  data
              }
          }
          
          return WebSocketFrame(
              fin = fin,
              opcode = FrameOpcode.fromValue(opcode),
              masked = masked,
              payload = payload,
              frameSize = offset
          )
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥WebSocketåè®®ç‰¹å¾åˆ†æå’Œå¯¹æ¯”ç³»ç»Ÿ
  2. ğŸ” å®ç°æ¡æ‰‹è¿‡ç¨‹çš„å®Œæ•´è§£æå’ŒéªŒè¯
  3. ğŸ“Š æ„å»ºå¸§æ ¼å¼è§£æå’Œæ€§èƒ½ç›‘æ§ç³»ç»Ÿ
  4. âš¡ ç¼–å†™åè®®æ€§èƒ½æµ‹è¯•å’Œå¯¹æ¯”å·¥å…·
  5. ğŸƒ æµ‹è¯•ä¸åŒç½‘ç»œç¯å¢ƒä¸‹çš„åè®®è¡¨ç°
- [ ] **åè®®ç†è§£éªŒè¯**: æ¡æ‰‹æ­£ç¡®ç‡100%ï¼Œå¸§è§£æç²¾åº¦100%ï¼Œæ€§èƒ½æå‡3x+
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ èƒ½è§£é‡ŠWebSocketä¸ºä»€ä¹ˆæ¯”HTTPæ›´é€‚åˆå®æ—¶é€šä¿¡å—ï¼Ÿ
- [ ] **åè®®æ£€æŸ¥**: â–¡ æ¡æ‰‹æœºåˆ¶æ¸…æ™° â–¡ å¸§ç»“æ„ç†è§£ â–¡ æ€§èƒ½ä¼˜åŠ¿æ˜æ˜¾ â–¡ å®‰å…¨ç‰¹æ€§çŸ¥æ™“
- [ ] **æ–‡ä»¶**: `student_progress/websocket/protocol_analysis/`

#### Task 9.2.2: Android WebSocketå®¢æˆ·ç«¯ (5åˆ†é’Ÿ) â° [Primary]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºé«˜æ€§èƒ½çš„Android WebSocketå®¢æˆ·ç«¯ ğŸ“±

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹å®ç°ä¼ä¸šçº§çš„WebSocketå®¢æˆ·ç«¯æ¶æ„
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°æ”¯æŒåƒä¸‡çº§ç”¨æˆ·çš„ç¨³å®šè¿æ¥
  
  // WebSocketè¿æ¥çŠ¶æ€å®šä¹‰
  enum class ConnectionState {
      IDLE,           // ç©ºé—²çŠ¶æ€
      CONNECTING,     // è¿æ¥ä¸­
      CONNECTED,      // å·²è¿æ¥
      DISCONNECTING,  // æ–­å¼€ä¸­
      DISCONNECTED,   // å·²æ–­å¼€
      RECONNECTING,   // é‡è¿ä¸­
      FAILED          // è¿æ¥å¤±è´¥
  }
  
  // TODO 1: äº²æ‰‹å®ç°é«˜æ€§èƒ½çš„WebSocketå®¢æˆ·ç«¯
  class ChatWebSocketClient(
      private val serverUrl: String,
      private val userId: String,
      private val authToken: String
  ) {
      
      private var webSocket: WebSocket? = null
      private var currentState = ConnectionState.IDLE
      private val stateListeners = mutableSetOf<ConnectionStateListener>()
      private val messageListeners = mutableSetOf<MessageListener>()
      
      // ä¼˜åŒ–çš„OkHttpå®¢æˆ·ç«¯é…ç½®
      private val okHttpClient = OkHttpClient.Builder()
          .connectTimeout(10, TimeUnit.SECONDS)
          .readTimeout(0, TimeUnit.MILLISECONDS) // WebSocketä¸éœ€è¦è¯»å–è¶…æ—¶
          .writeTimeout(10, TimeUnit.SECONDS)
          .pingInterval(30, TimeUnit.SECONDS) // å¿ƒè·³é—´éš”
          .retryOnConnectionFailure(true)
          .addInterceptor(AuthInterceptor(authToken))
          .addNetworkInterceptor(LoggingInterceptor())
          .build()
      
      fun connect() {
          if (currentState == ConnectionState.CONNECTED || 
              currentState == ConnectionState.CONNECTING) {
              Log.w(TAG, "Already connected or connecting")
              return
          }
          
          updateState(ConnectionState.CONNECTING)
          
          val request = Request.Builder()
              .url(serverUrl)
              .addHeader("Authorization", "Bearer $authToken")
              .addHeader("User-ID", userId)
              .addHeader("Client-Version", BuildConfig.VERSION_NAME)
              .addHeader("Platform", "Android")
              .build()
          
          webSocket = okHttpClient.newWebSocket(request, webSocketListener)
      }
      
      // TODO 2: äº²æ‰‹å®ç°æ¶ˆæ¯å‘é€ç³»ç»Ÿ
      suspend fun sendMessage(message: ChatMessage): Boolean {
          val webSocket = this.webSocket ?: return false
          
          if (currentState != ConnectionState.CONNECTED) {
              Log.w(TAG, "Cannot send message: not connected")
              return false
          }
          
          return try {
              val messageJson = Json.encodeToString(message)
              val success = webSocket.send(messageJson)
              
              if (success) {
                  Log.d(TAG, "Message sent successfully: ${message.messageId}")
                  // è®°å½•å‘é€ç»Ÿè®¡
                  messageMetrics.recordSentMessage(message)
              } else {
                  Log.e(TAG, "Failed to send message: ${message.messageId}")
                  // æ·»åŠ åˆ°é‡å‘é˜Ÿåˆ—
                  pendingMessages.add(message)
              }
              
              success
          } catch (e: Exception) {
              Log.e(TAG, "Error sending message", e)
              false
          }
      }
      
      fun sendBinaryMessage(data: ByteArray): Boolean {
          val webSocket = this.webSocket ?: return false
          return webSocket.send(data.toByteString())
      }
      
      // TODO 3: äº²æ‰‹å®ç°WebSocketäº‹ä»¶ç›‘å¬å™¨
      private val webSocketListener = object : WebSocketListener() {
          override fun onOpen(webSocket: WebSocket, response: Response) {
              Log.i(TAG, "WebSocket connected successfully")
              updateState(ConnectionState.CONNECTED)
              
              // å‘é€è¿æ¥æˆåŠŸåçš„åˆå§‹åŒ–æ¶ˆæ¯
              sendInitializationMessage()
              
              // å‘é€å¾…å‘æ¶ˆæ¯
              sendPendingMessages()
              
              // å¯åŠ¨å¿ƒè·³æ£€æµ‹
              startHeartbeat()
          }
          
          override fun onMessage(webSocket: WebSocket, text: String) {
              Log.d(TAG, "Received text message: $text")
              handleTextMessage(text)
          }
          
          override fun onMessage(webSocket: WebSocket, bytes: ByteString) {
              Log.d(TAG, "Received binary message: ${bytes.size} bytes")
              handleBinaryMessage(bytes.toByteArray())
          }
          
          override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
              Log.i(TAG, "WebSocket closing: $code $reason")
              updateState(ConnectionState.DISCONNECTING)
          }
          
          override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
              Log.i(TAG, "WebSocket closed: $code $reason")
              updateState(ConnectionState.DISCONNECTED)
              
              // å¦‚æœä¸æ˜¯ä¸»åŠ¨å…³é—­ï¼Œå°è¯•é‡è¿
              if (code != 1000) { // 1000 = Normal Closure
                  scheduleReconnect()
              }
          }
          
          override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
              Log.e(TAG, "WebSocket connection failed", t)
              updateState(ConnectionState.FAILED)
              
              // å¤„ç†è¿æ¥å¤±è´¥
              handleConnectionFailure(t, response)
              
              // å°è¯•é‡è¿
              scheduleReconnect()
          }
      }
      
      // TODO 4: äº²æ‰‹å®ç°æ¶ˆæ¯å¤„ç†ç³»ç»Ÿ
      private fun handleTextMessage(text: String) {
          try {
              val messageWrapper = Json.decodeFromString<MessageWrapper>(text)
              
              when (messageWrapper.type) {
                  "chat_message" -> {
                      val chatMessage = Json.decodeFromString<ChatMessage>(messageWrapper.payload)
                      notifyMessageListeners(chatMessage)
                      
                      // å‘é€æ”¶åˆ°ç¡®è®¤
                      sendAcknowledgment(chatMessage.messageId)
                  }
                  "system_message" -> {
                      val systemMessage = Json.decodeFromString<SystemMessage>(messageWrapper.payload)
                      handleSystemMessage(systemMessage)
                  }
                  "ping" -> {
                      // å“åº”å¿ƒè·³
                      sendPong()
                  }
                  "acknowledgment" -> {
                      val ackMessage = Json.decodeFromString<AckMessage>(messageWrapper.payload)
                      handleAcknowledgment(ackMessage)
                  }
                  else -> {
                      Log.w(TAG, "Unknown message type: ${messageWrapper.type}")
                  }
              }
          } catch (e: Exception) {
              Log.e(TAG, "Error parsing message: $text", e)
          }
      }
      
      private fun notifyMessageListeners(message: ChatMessage) {
          messageListeners.forEach { listener ->
              try {
                  listener.onMessageReceived(message)
              } catch (e: Exception) {
                  Log.e(TAG, "Error in message listener", e)
              }
          }
      }
      
      private fun updateState(newState: ConnectionState) {
          val oldState = currentState
          currentState = newState
          
          Log.d(TAG, "Connection state changed: $oldState -> $newState")
          
          stateListeners.forEach { listener ->
              try {
                  listener.onStateChanged(oldState, newState)
              } catch (e: Exception) {
                  Log.e(TAG, "Error in state listener", e)
              }
          }
      }
      
      fun disconnect() {
          webSocket?.close(1000, "User disconnected")
          updateState(ConnectionState.DISCONNECTED)
      }
      
      fun addStateListener(listener: ConnectionStateListener) {
          stateListeners.add(listener)
      }
      
      fun removeStateListener(listener: ConnectionStateListener) {
          stateListeners.remove(listener)
      }
      
      companion object {
          private const val TAG = "ChatWebSocketClient"
      }
  }
  
  // TODO 5: äº²æ‰‹å®ç°è¿æ¥ç®¡ç†å™¨
  interface ConnectionStateListener {
      fun onStateChanged(oldState: ConnectionState, newState: ConnectionState)
  }
  
  interface MessageListener {
      fun onMessageReceived(message: ChatMessage)
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥å®Œæ•´çš„WebSocketå®¢æˆ·ç«¯ä»£ç 
  2. ğŸ“± å®ç°è¿æ¥çŠ¶æ€ç®¡ç†å’Œäº‹ä»¶ç›‘å¬ç³»ç»Ÿ
  3. ğŸ’¬ æ„å»ºå¯é çš„æ¶ˆæ¯å‘é€å’Œæ¥æ”¶æœºåˆ¶
  4. âš¡ ç¼–å†™è¿æ¥å¤±è´¥å¤„ç†å’Œé‡è¿é€»è¾‘
  5. ğŸƒ æµ‹è¯•é«˜å¹¶å‘å’Œå¤§æ•°æ®é‡ä¼ è¾“åœºæ™¯
- [ ] **è¿æ¥ç¨³å®šæ€§éªŒè¯**: è¿æ¥æˆåŠŸç‡>99%ï¼Œæ¶ˆæ¯ä¸¢å¤±ç‡<0.1%ï¼Œé‡è¿æ—¶é—´<5s
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ çš„WebSocketå®¢æˆ·ç«¯èƒ½åœ¨å¤æ‚ç½‘ç»œç¯å¢ƒä¸‹ç¨³å®šè¿è¡Œå—ï¼Ÿ
- [ ] **è¿æ¥æ£€æŸ¥**: â–¡ çŠ¶æ€ç®¡ç†å®Œå–„ â–¡ æ¶ˆæ¯å¤„ç†æ­£ç¡® â–¡ é”™è¯¯å¤„ç†å®Œå–„ â–¡ æ€§èƒ½ä¼˜åŒ–åˆç†
- [ ] **æ–‡ä»¶**: `student_progress/websocket/client/`

#### Task 9.2.3: è¿æ¥çŠ¶æ€ç®¡ç† (5åˆ†é’Ÿ) â° [Intermediate]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºæ™ºèƒ½è¿æ¥çŠ¶æ€ç®¡ç†ç³»ç»Ÿ ğŸ”„

- [ ] **Intermediateç›®æ ‡**: äº²æ‰‹å®ç°ä¼ä¸šçº§çš„è¿æ¥çŠ¶æ€æœºå’Œè‡ªåŠ¨åˆ‡æ¢ç­–ç•¥
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°æ”¯æŒå¤æ‚ä¸šåŠ¡åœºæ™¯çš„çŠ¶æ€ç®¡ç†ç³»ç»Ÿ
  
  // è¯¦ç»†çš„è¿æ¥çŠ¶æ€å®šä¹‰
  sealed class DetailedConnectionState {
      object Idle : DetailedConnectionState()
      
      data class Connecting(
          val attempt: Int,
          val startTime: Long
      ) : DetailedConnectionState()
      
      data class Connected(
          val connectedAt: Long,
          val serverInfo: ServerInfo?
      ) : DetailedConnectionState()
      
      data class Disconnecting(
          val reason: DisconnectReason
      ) : DetailedConnectionState()
      
      data class Disconnected(
          val reason: DisconnectReason,
          val lastConnectedTime: Long?
      ) : DetailedConnectionState()
      
      data class Reconnecting(
          val attempt: Int,
          val nextAttemptTime: Long,
          val totalFailures: Int
      ) : DetailedConnectionState()
      
      data class Failed(
          val error: Throwable,
          val failureTime: Long,
          val recoverable: Boolean
      ) : DetailedConnectionState()
  }
  
  enum class DisconnectReason {
      USER_INITIATED,      // ç”¨æˆ·ä¸»åŠ¨æ–­å¼€
      NETWORK_LOST,        // ç½‘ç»œä¸¢å¤±
      SERVER_ERROR,        // æœåŠ¡å™¨é”™è¯¯
      AUTHENTICATION_FAILED, // è®¤è¯å¤±è´¥
      PROTOCOL_ERROR,      // åè®®é”™è¯¯
      TIMEOUT,             // è¶…æ—¶
      UNKNOWN              // æœªçŸ¥é”™è¯¯
  }
  
  // TODO 1: äº²æ‰‹å®ç°æ™ºèƒ½çŠ¶æ€ç®¡ç†å™¨
  class SmartConnectionStateManager {
      private var currentState: DetailedConnectionState = DetailedConnectionState.Idle
      private val stateHistory = mutableListOf<StateTransition>()
      private val stateListeners = mutableSetOf<StateChangeListener>()
      
      private val connectionMetrics = ConnectionMetrics()
      private val reconnectPolicy = ExponentialBackoffPolicy()
      
      fun transitionTo(newState: DetailedConnectionState, reason: String? = null) {
          val oldState = currentState
          
          // éªŒè¯çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
          if (!isValidTransition(oldState, newState)) {
              Log.w(TAG, "Invalid state transition: $oldState -> $newState")
              return
          }
          
          currentState = newState
          
          // è®°å½•çŠ¶æ€è½¬æ¢å†å²
          val transition = StateTransition(
              from = oldState,
              to = newState,
              timestamp = System.currentTimeMillis(),
              reason = reason
          )
          stateHistory.add(transition)
          
          // æ›´æ–°è¿æ¥æŒ‡æ ‡
          updateConnectionMetrics(transition)
          
          // é€šçŸ¥ç›‘å¬å™¨
          notifyStateListeners(oldState, newState, reason)
          
          // æ‰§è¡ŒçŠ¶æ€ç›¸å…³çš„åŠ¨ä½œ
          executeStateActions(newState)
          
          Log.i(TAG, "State transition: $oldState -> $newState (reason: $reason)")
      }
      
      private fun isValidTransition(
          from: DetailedConnectionState,
          to: DetailedConnectionState
      ): Boolean {
          // TODO: äº²æ‰‹å®šä¹‰çŠ¶æ€è½¬æ¢è§„åˆ™
          return when (from) {
              is DetailedConnectionState.Idle -> {
                  to is DetailedConnectionState.Connecting
              }
              is DetailedConnectionState.Connecting -> {
                  to is DetailedConnectionState.Connected ||
                  to is DetailedConnectionState.Failed ||
                  to is DetailedConnectionState.Disconnected
              }
              is DetailedConnectionState.Connected -> {
                  to is DetailedConnectionState.Disconnecting ||
                  to is DetailedConnectionState.Disconnected ||
                  to is DetailedConnectionState.Failed
              }
              is DetailedConnectionState.Disconnecting -> {
                  to is DetailedConnectionState.Disconnected
              }
              is DetailedConnectionState.Disconnected -> {
                  to is DetailedConnectionState.Reconnecting ||
                  to is DetailedConnectionState.Connecting ||
                  to is DetailedConnectionState.Idle
              }
              is DetailedConnectionState.Reconnecting -> {
                  to is DetailedConnectionState.Connecting ||
                  to is DetailedConnectionState.Failed ||
                  to is DetailedConnectionState.Idle
              }
              is DetailedConnectionState.Failed -> {
                  to is DetailedConnectionState.Reconnecting ||
                  to is DetailedConnectionState.Connecting ||
                  to is DetailedConnectionState.Idle
              }
          }
      }
      
      // TODO 2: äº²æ‰‹å®ç°çŠ¶æ€ç›¸å…³åŠ¨ä½œ
      private fun executeStateActions(state: DetailedConnectionState) {
          when (state) {
              is DetailedConnectionState.Connected -> {
                  // è¿æ¥æˆåŠŸåçš„åŠ¨ä½œ
                  connectionMetrics.recordSuccessfulConnection()
                  reconnectPolicy.reset()
                  startConnectionMonitoring()
              }
              is DetailedConnectionState.Disconnected -> {
                  // æ–­å¼€åçš„åŠ¨ä½œ
                  stopConnectionMonitoring()
                  if (shouldAutoReconnect(state.reason)) {
                      scheduleReconnect()
                  }
              }
              is DetailedConnectionState.Failed -> {
                  // å¤±è´¥åçš„åŠ¨ä½œ
                  connectionMetrics.recordFailure(state.error)
                  if (state.recoverable) {
                      scheduleReconnect()
                  }
              }
              is DetailedConnectionState.Reconnecting -> {
                  // é‡è¿å‡†å¤‡
                  val delay = reconnectPolicy.getNextDelay(state.attempt)
                  scheduleReconnectAfterDelay(delay)
              }
          }
      }
      
      private fun shouldAutoReconnect(reason: DisconnectReason): Boolean {
          return when (reason) {
              DisconnectReason.USER_INITIATED -> false
              DisconnectReason.AUTHENTICATION_FAILED -> false
              DisconnectReason.NETWORK_LOST -> true
              DisconnectReason.SERVER_ERROR -> true
              DisconnectReason.PROTOCOL_ERROR -> false
              DisconnectReason.TIMEOUT -> true
              DisconnectReason.UNKNOWN -> true
          }
      }
  }
  
  // TODO 3: äº²æ‰‹å®ç°è¿æ¥æŒ‡æ ‡ç›‘æ§
  class ConnectionMetrics {
      private var totalConnections = 0
      private var successfulConnections = 0
      private var failedConnections = 0
      private var totalDowntime = 0L
      private var lastConnectionTime = 0L
      private var lastDisconnectionTime = 0L
      
      private val connectionDurations = mutableListOf<Long>()
      private val failureReasons = mutableMapOf<String, Int>()
      
      fun recordSuccessfulConnection() {
          totalConnections++
          successfulConnections++
          lastConnectionTime = System.currentTimeMillis()
          
          if (lastDisconnectionTime > 0) {
              totalDowntime += (lastConnectionTime - lastDisconnectionTime)
          }
      }
      
      fun recordFailure(error: Throwable) {
          totalConnections++
          failedConnections++
          
          val errorType = error::class.simpleName ?: "Unknown"
          failureReasons[errorType] = failureReasons.getOrDefault(errorType, 0) + 1
      }
      
      fun recordDisconnection() {
          lastDisconnectionTime = System.currentTimeMillis()
          
          if (lastConnectionTime > 0) {
              val duration = lastDisconnectionTime - lastConnectionTime
              connectionDurations.add(duration)
          }
      }
      
      fun getConnectionSuccessRate(): Double {
          return if (totalConnections > 0) {
              successfulConnections.toDouble() / totalConnections
          } else 0.0
      }
      
      fun getAverageConnectionDuration(): Long {
          return if (connectionDurations.isNotEmpty()) {
              connectionDurations.average().toLong()
          } else 0L
      }
      
      fun getUptimePercentage(): Double {
          val totalTime = System.currentTimeMillis() - (connectionDurations.firstOrNull() ?: System.currentTimeMillis())
          return if (totalTime > 0) {
              ((totalTime - totalDowntime).toDouble() / totalTime) * 100
          } else 0.0
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥è¯¦ç»†çš„çŠ¶æ€å®šä¹‰å’Œè½¬æ¢è§„åˆ™
  2. ğŸ”„ å®ç°æ™ºèƒ½çŠ¶æ€ç®¡ç†å’Œè‡ªåŠ¨åˆ‡æ¢ç³»ç»Ÿ
  3. ğŸ“Š æ„å»ºè¿æ¥æŒ‡æ ‡ç›‘æ§å’Œç»Ÿè®¡ç³»ç»Ÿ
  4. âš¡ ç¼–å†™çŠ¶æ€å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶
  5. ğŸƒ æµ‹è¯•å¤æ‚ç½‘ç»œç¯å¢ƒä¸‹çš„çŠ¶æ€ç®¡ç†
- [ ] **çŠ¶æ€ç®¡ç†éªŒè¯**: è½¬æ¢æ­£ç¡®ç‡100%ï¼Œå¼‚å¸¸æ¢å¤æ—¶é—´<3sï¼ŒçŠ¶æ€ä¸€è‡´æ€§ä¿è¯
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ çš„çŠ¶æ€ç®¡ç†èƒ½å¤„ç†æ‰€æœ‰ç½‘ç»œå¼‚å¸¸åœºæ™¯å—ï¼Ÿ
- [ ] **çŠ¶æ€æ£€æŸ¥**: â–¡ è½¬æ¢è§„åˆ™å®Œå–„ â–¡ æŒ‡æ ‡ç›‘æ§å®Œæ•´ â–¡ å¼‚å¸¸å¤„ç†å®Œå–„ â–¡ æ€§èƒ½ç›‘æ§å®æ—¶
- [ ] **æ–‡ä»¶**: `student_progress/websocket/state_management/`

#### Task 9.2.4: å¿ƒè·³ä¿æ´»æœºåˆ¶ (5åˆ†é’Ÿ) â° [Intermediate]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºæ™ºèƒ½å¿ƒè·³ä¿æ´»ç³»ç»Ÿ ğŸ’“

- [ ] **Intermediateç›®æ ‡**: äº²æ‰‹å®ç°è‡ªé€‚åº”çš„å¿ƒè·³æ£€æµ‹å’Œè¿æ¥ç®¡ç†ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°æ”¯æŒå„ç§ç½‘ç»œç¯å¢ƒçš„æ™ºèƒ½å¿ƒè·³ç³»ç»Ÿ
  
  // å¿ƒè·³ç­–ç•¥é…ç½®
  data class HeartbeatConfig(
      val pingInterval: Long = 30_000L,    // 30ç§’
      val pongTimeout: Long = 10_000L,     // 10ç§’
      val maxMissedPings: Int = 3,         // æœ€å¤šå…è®¸3æ¬¡æœªå“åº”
      val adaptiveMode: Boolean = true,    // è‡ªé€‚åº”æ¨¡å¼
      val weakNetworkMultiplier: Float = 2.0f // å¼±ç½‘ç¯å¢ƒå€æ•°
  )
  
  // TODO 1: äº²æ‰‹å®ç°æ™ºèƒ½å¿ƒè·³ç®¡ç†å™¨
  class SmartHeartbeatManager(
      private val webSocket: WebSocket,
      private val networkMonitor: NetworkQualityMonitor,
      private val config: HeartbeatConfig = HeartbeatConfig()
  ) {
      
      private val heartbeatScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
      private var heartbeatJob: Job? = null
      private var currentPingInterval = config.pingInterval
      
      private var lastPingTime = 0L
      private var lastPongTime = 0L
      private var missedPingCount = 0
      private var isHeartbeatActive = false
      
      private val heartbeatListeners = mutableSetOf<HeartbeatListener>()
      private val heartbeatMetrics = HeartbeatMetrics()
      
      fun startHeartbeat() {
          if (isHeartbeatActive) {
              Log.w(TAG, "Heartbeat already active")
              return
          }
          
          isHeartbeatActive = true
          heartbeatJob = heartbeatScope.launch {
              try {
                  runHeartbeatLoop()
              } catch (e: Exception) {
                  Log.e(TAG, "Heartbeat loop error", e)
                  handleHeartbeatError(e)
              }
          }
          
          Log.i(TAG, "Heartbeat started with interval: ${currentPingInterval}ms")
      }
      
      private suspend fun runHeartbeatLoop() {
          while (isHeartbeatActive && !heartbeatJob?.isCancelled!!) {
              // å‘é€ping
              sendPing()
              
              // ç­‰å¾…pongå“åº”
              val pongReceived = waitForPong()
              
              if (pongReceived) {
                  handlePongReceived()
              } else {
                  handlePongTimeout()
              }
              
              // è‡ªé€‚åº”è°ƒæ•´å¿ƒè·³é—´éš”
              if (config.adaptiveMode) {
                  adjustHeartbeatInterval()
              }
              
              // ç­‰å¾…ä¸‹ä¸€æ¬¡å¿ƒè·³
              delay(currentPingInterval)
          }
      }
      
      private suspend fun sendPing() {
          try {
              val pingMessage = createPingMessage()
              val success = webSocket.send(pingMessage)
              
              if (success) {
                  lastPingTime = System.currentTimeMillis()
                  heartbeatMetrics.recordPingSent(lastPingTime)
                  
                  Log.d(TAG, "Ping sent at $lastPingTime")
                  notifyHeartbeatListeners { it.onPingSent(lastPingTime) }
              } else {
                  Log.w(TAG, "Failed to send ping")
                  handleSendFailure()
              }
          } catch (e: Exception) {
              Log.e(TAG, "Error sending ping", e)
              handleSendFailure()
          }
      }
      
      private fun createPingMessage(): String {
          // TODO: äº²æ‰‹å®ç°pingæ¶ˆæ¯æ ¼å¼
          val pingData = mapOf(
              "type" to "ping",
              "timestamp" to System.currentTimeMillis(),
              "clientId" to getClientId(),
              "sequence" to getNextSequence()
          )
          return Json.encodeToString(pingData)
      }
      
      private suspend fun waitForPong(): Boolean {
          // TODO: äº²æ‰‹å®ç°pongç­‰å¾…é€»è¾‘
          val startTime = System.currentTimeMillis()
          
          while (System.currentTimeMillis() - startTime < config.pongTimeout) {
              if (lastPongTime > lastPingTime) {
                  return true
              }
              delay(100) // æ£€æŸ¥é—´éš”
          }
          
          return false
      }
      
      fun onPongReceived(pongTimestamp: Long) {
          lastPongTime = System.currentTimeMillis()
          val roundTripTime = lastPongTime - lastPingTime
          
          heartbeatMetrics.recordPongReceived(lastPongTime, roundTripTime)
          
          Log.d(TAG, "Pong received, RTT: ${roundTripTime}ms")
          notifyHeartbeatListeners { it.onPongReceived(lastPongTime, roundTripTime) }
      }
      
      private fun handlePongReceived() {
          // é‡ç½®è®¡æ•°å™¨
          missedPingCount = 0
          
          // è®°å½•æˆåŠŸçš„å¿ƒè·³
          heartbeatMetrics.recordSuccessfulHeartbeat()
          
          notifyHeartbeatListeners { it.onHeartbeatSuccessful() }
      }
      
      private fun handlePongTimeout() {
          missedPingCount++
          
          Log.w(TAG, "Pong timeout, missed count: $missedPingCount")
          heartbeatMetrics.recordMissedPong()
          
          notifyHeartbeatListeners { it.onPongTimeout(missedPingCount) }
          
          // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
          if (missedPingCount >= config.maxMissedPings) {
              handleConnectionDead()
          }
      }
      
      private fun handleConnectionDead() {
          Log.e(TAG, "Connection considered dead after $missedPingCount missed pongs")
          
          stopHeartbeat()
          heartbeatMetrics.recordConnectionDead()
          
          notifyHeartbeatListeners { it.onConnectionDead() }
      }
      
      // TODO 2: äº²æ‰‹å®ç°è‡ªé€‚åº”å¿ƒè·³è°ƒæ•´
      private fun adjustHeartbeatInterval() {
          val networkQuality = networkMonitor.getCurrentQuality()
          val averageRtt = heartbeatMetrics.getAverageRoundTripTime()
          
          val newInterval = when (networkQuality) {
              NetworkQuality.EXCELLENT -> {
                  config.pingInterval
              }
              NetworkQuality.GOOD -> {
                  (config.pingInterval * 1.2f).toLong()
              }
              NetworkQuality.FAIR -> {
                  (config.pingInterval * 1.5f).toLong()
              }
              NetworkQuality.POOR -> {
                  (config.pingInterval * config.weakNetworkMultiplier).toLong()
              }
              NetworkQuality.VERY_POOR -> {
                  (config.pingInterval * 3.0f).toLong()
              }
          }
          
          // æ ¹æ®RTTè°ƒæ•´
          val rttAdjustedInterval = if (averageRtt > 1000) {
              (newInterval * 1.5f).toLong()
          } else if (averageRtt > 500) {
              (newInterval * 1.2f).toLong()
          } else {
              newInterval
          }
          
          // é™åˆ¶èŒƒå›´
          currentPingInterval = rttAdjustedInterval.coerceIn(
              config.pingInterval / 2,
              config.pingInterval * 5
          )
          
          Log.d(TAG, "Adjusted heartbeat interval to: ${currentPingInterval}ms (network: $networkQuality, RTT: ${averageRtt}ms)")
      }
      
      fun stopHeartbeat() {
          isHeartbeatActive = false
          heartbeatJob?.cancel()
          heartbeatJob = null
          
          Log.i(TAG, "Heartbeat stopped")
      }
      
      // TODO 3: äº²æ‰‹å®ç°å¿ƒè·³æŒ‡æ ‡ç›‘æ§
      fun getHeartbeatStats(): HeartbeatStats {
          return HeartbeatStats(
              totalPingsSent = heartbeatMetrics.totalPingsSent,
              totalPongsReceived = heartbeatMetrics.totalPongsReceived,
              missedPongCount = heartbeatMetrics.missedPongCount,
              averageRoundTripTime = heartbeatMetrics.getAverageRoundTripTime(),
              currentInterval = currentPingInterval,
              isActive = isHeartbeatActive
          )
      }
      
      fun addHeartbeatListener(listener: HeartbeatListener) {
          heartbeatListeners.add(listener)
      }
      
      fun removeHeartbeatListener(listener: HeartbeatListener) {
          heartbeatListeners.remove(listener)
      }
      
      private fun notifyHeartbeatListeners(action: (HeartbeatListener) -> Unit) {
          heartbeatListeners.forEach { listener ->
              try {
                  action(listener)
              } catch (e: Exception) {
                  Log.e(TAG, "Error in heartbeat listener", e)
              }
          }
      }
      
      companion object {
          private const val TAG = "SmartHeartbeatManager"
      }
  }
  
  // TODO 4: äº²æ‰‹å®ç°å¿ƒè·³ç›‘å¬å™¨æ¥å£
  interface HeartbeatListener {
      fun onPingSent(timestamp: Long)
      fun onPongReceived(timestamp: Long, roundTripTime: Long)
      fun onPongTimeout(missedCount: Int)
      fun onHeartbeatSuccessful()
      fun onConnectionDead()
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥å¿ƒè·³ç®¡ç†å™¨å’Œè‡ªé€‚åº”ç­–ç•¥
  2. ğŸ’“ å®ç°ping/pongæœºåˆ¶å’Œè¶…æ—¶æ£€æµ‹
  3. ğŸ“Š æ„å»ºç½‘ç»œè´¨é‡ç›‘æ§å’ŒåŠ¨æ€è°ƒæ•´
  4. âš¡ ç¼–å†™è¿æ¥å¼‚å¸¸æ£€æµ‹å’Œæ¢å¤æœºåˆ¶
  5. ğŸƒ æµ‹è¯•å„ç§ç½‘ç»œç¯å¢ƒä¸‹çš„å¿ƒè·³è¡¨ç°
- [ ] **å¿ƒè·³ç¨³å®šæ€§éªŒè¯**: æ£€æµ‹ç²¾åº¦>95%ï¼Œæ–­çº¿å‘ç°æ—¶é—´<30sï¼Œç½‘ç»œé€‚é…æ­£ç¡®
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ çš„å¿ƒè·³ç³»ç»Ÿèƒ½åœ¨å¼±ç½‘ç¯å¢ƒä¸‹ç¨³å®šå·¥ä½œå—ï¼Ÿ
- [ ] **å¿ƒè·³æ£€æŸ¥**: â–¡ è‡ªé€‚åº”è°ƒæ•´ â–¡ è¶…æ—¶æ£€æµ‹å‡†ç¡® â–¡ æŒ‡æ ‡ç›‘æ§å®Œæ•´ â–¡ ç½‘ç»œé€‚é…å¥½
- [ ] **æ–‡ä»¶**: `student_progress/websocket/heartbeat/`

#### Task 9.2.5: æ¶ˆæ¯é˜Ÿåˆ—è®¾è®¡ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å¤„ç†æ¶ˆæ¯çš„å¯é ä¼ è¾“
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°æ¶ˆæ¯ç¡®è®¤å’Œé‡å‘æœºåˆ¶
- [ ] **æ£€æŸ¥ç‚¹**: ä¿è¯æ¶ˆæ¯ä¸ä¸¢å¤±ä¸é‡å¤
- [ ] **æ–‡ä»¶**: `websocket_demo/MessageQueue.kt`

## Phase 6: æ–­çº¿é‡è¿ä¸å®¹é”™å¤„ç† (30åˆ†é’Ÿæ€»è®¡)

#### Task 9.2.6: ç½‘ç»œçŠ¶æ€ç›‘å¬ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: ç›‘å¬Androidç½‘ç»œçŠ¶æ€å˜åŒ–
- [ ] **å…·ä½“ä»»åŠ¡**: ä½¿ç”¨ConnectivityManagerç›‘å¬ç½‘ç»œåˆ‡æ¢
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åŒºåˆ†WiFiã€ç§»åŠ¨ç½‘ç»œã€æ— ç½‘ç»œçŠ¶æ€
- [ ] **æ–‡ä»¶**: `websocket_demo/NetworkStateMonitor.kt`

#### Task 9.2.7: æŒ‡æ•°é€€é¿é‡è¿ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡æ™ºèƒ½é‡è¿ç­–ç•¥
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°æŒ‡æ•°é€€é¿ç®—æ³•é˜²æ­¢è¿æ¥é£æš´
- [ ] **æ£€æŸ¥ç‚¹**: é‡è¿é—´éš”é€æ¸å¢åŠ ï¼Œæœ‰æœ€å¤§é™åˆ¶
- [ ] **æ–‡ä»¶**: `websocket_demo/ReconnectStrategy.kt`

#### Task 9.2.8: å¼±ç½‘ç¯å¢ƒä¼˜åŒ– (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: é€‚é…2G/3Gç­‰å¼±ç½‘ç¯å¢ƒ
- [ ] **å…·ä½“ä»»åŠ¡**: è°ƒæ•´å¿ƒè·³é—´éš”å’Œè¶…æ—¶æ—¶é—´
- [ ] **æ£€æŸ¥ç‚¹**: åœ¨å¼±ç½‘ä¸‹ä»èƒ½ç»´æŒè¿æ¥
- [ ] **æ–‡ä»¶**: `websocket_demo/WeakNetworkOptimizer.kt`

#### Task 9.2.9: æ¶ˆæ¯é‡å¤å¤„ç† (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è§£å†³ç½‘ç»œæ³¢åŠ¨å¯¼è‡´çš„æ¶ˆæ¯é‡å¤
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°æ¶ˆæ¯å»é‡æœºåˆ¶ï¼ˆåŸºäºæ¶ˆæ¯IDï¼‰
- [ ] **æ£€æŸ¥ç‚¹**: åŒä¸€æ¶ˆæ¯ä¸ä¼šè¢«å¤„ç†å¤šæ¬¡
- [ ] **æ–‡ä»¶**: `websocket_demo/MessageDeduplicator.kt`

#### Task 9.2.10: æµé‡æ§åˆ¶æœºåˆ¶ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: é˜²æ­¢æ¶ˆæ¯å‘é€è¿‡å¿«å¯¼è‡´çš„é—®é¢˜
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°ä»¤ç‰Œæ¡¶ç®—æ³•é™åˆ¶å‘é€é¢‘ç‡
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¹³æ»‘é™åˆ¶æ¶ˆæ¯å‘é€é€Ÿç‡
- [ ] **æ–‡ä»¶**: `websocket_demo/RateLimiter.kt`

#### Task 9.2.11: ä¼˜é›…é™çº§ç­–ç•¥ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: WebSocketä¸å¯ç”¨æ—¶çš„é™çº§æ–¹æ¡ˆ
- [ ] **å…·ä½“ä»»åŠ¡**: è‡ªåŠ¨åˆ‡æ¢åˆ°HTTPè½®è¯¢æ¨¡å¼
- [ ] **æ£€æŸ¥ç‚¹**: ä¿è¯åŠŸèƒ½å¯ç”¨æ€§ï¼Œç”¨æˆ·æ— æ„ŸçŸ¥
- [ ] **æ–‡ä»¶**: `websocket_demo/FallbackStrategy.kt`

## Phase 7: æ¨é€é€šçŸ¥å¤šé€šé“è®¾è®¡ (25åˆ†é’Ÿæ€»è®¡)

#### Task 9.2.12: FCMé›†æˆåŸºç¡€ (5åˆ†é’Ÿ) â° [Primary]
- [ ] **å­¦ä¹ ç›®æ ‡**: æŒæ¡Firebase Cloud Messaging
- [ ] **å…·ä½“ä»»åŠ¡**: é›†æˆFCM SDKï¼Œè·å–æ³¨å†Œä»¤ç‰Œ
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æ¥æ”¶åˆ°æ¨é€é€šçŸ¥
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/push_demo/FCMHelper.kt`

#### Task 9.2.13: åä¸ºHMSæ¨é€ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: é€‚é…åä¸ºè®¾å¤‡æ¨é€
- [ ] **å…·ä½“ä»»åŠ¡**: é›†æˆHMS Push Kit
- [ ] **æ£€æŸ¥ç‚¹**: åœ¨åä¸ºè®¾å¤‡ä¸Šèƒ½æ­£å¸¸æ¨é€
- [ ] **æ–‡ä»¶**: `push_demo/HMSPushHelper.kt`

#### Task 9.2.14: å°ç±³/OPPO/vivoæ¨é€ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: é€‚é…å›½äº§å‚å•†æ¨é€é€šé“
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°å¤šå‚å•†æ¨é€SDKé›†æˆ
- [ ] **æ£€æŸ¥ç‚¹**: è¦†ç›–ä¸»æµAndroidå‚å•†
- [ ] **æ–‡ä»¶**: `push_demo/VendorPushManager.kt`

#### Task 9.2.15: æ¨é€é€šé“æ™ºèƒ½é€‰æ‹© (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡æ¨é€é€šé“é€‰æ‹©ç­–ç•¥
- [ ] **å…·ä½“ä»»åŠ¡**: æ ¹æ®è®¾å¤‡å“ç‰Œè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ¨é€é€šé“
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æé«˜æ¨é€åˆ°è¾¾ç‡
- [ ] **æ–‡ä»¶**: `push_demo/PushChannelSelector.kt`

#### Task 9.2.16: æ¨é€æ¶ˆæ¯åˆ†ç±»ä¸ä¼˜å…ˆçº§ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡æ¶ˆæ¯åˆ†çº§æ¨é€ç­–ç•¥
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°ç´§æ€¥ã€æ™®é€šã€è¥é”€ç±»æ¶ˆæ¯çš„ä¸åŒå¤„ç†
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½é¿å…è¿‡åº¦æ¨é€å½±å“ç”¨æˆ·ä½“éªŒ
- [ ] **æ–‡ä»¶**: `push_demo/MessagePriorityManager.kt`

## Phase 8: ç›´æ’­é—´èŠå¤©ç³»ç»Ÿè®¾è®¡ (30åˆ†é’Ÿæ€»è®¡)

#### Task 9.2.17: é«˜å¹¶å‘æ¶ˆæ¯å¤„ç† (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡ä¸‡äººç›´æ’­é—´çš„æ¶ˆæ¯å¤„ç†
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°æ¶ˆæ¯é‡‡æ ·å’Œæµæ§æœºåˆ¶
- [ ] **æ£€æŸ¥ç‚¹**: ä¸å½±å“å®¢æˆ·ç«¯æ€§èƒ½
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/live_chat_design/`å’Œ`MessageSampler.kt`

#### Task 9.2.18: æ¶ˆæ¯ç±»å‹è®¾è®¡ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡ç›´æ’­é—´å¤šæ ·åŒ–æ¶ˆæ¯ç±»å‹
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°æ–‡å­—ã€ç¤¼ç‰©ã€å¼¹å¹•ã€ç³»ç»Ÿæ¶ˆæ¯
- [ ] **æ£€æŸ¥ç‚¹**: æ¶ˆæ¯ç±»å‹æ‰©å±•æ€§è‰¯å¥½
- [ ] **æ–‡ä»¶**: `live_chat_design/MessageTypes.kt`

#### Task 9.2.19: å¼¹å¹•æ¸²æŸ“ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¼˜åŒ–å¤§é‡å¼¹å¹•çš„æ¸²æŸ“æ€§èƒ½
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°å¼¹å¹•æ± å’Œè§†å›¾å¤ç”¨
- [ ] **æ£€æŸ¥ç‚¹**: åƒæ¡å¼¹å¹•æµç•…æ˜¾ç¤º
- [ ] **æ–‡ä»¶**: `live_chat_design/DanmakuRenderer.kt`

#### Task 9.2.20: ç¤¼ç‰©åŠ¨ç”»ç³»ç»Ÿ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡ç¤¼ç‰©ç‰¹æ•ˆå±•ç¤ºç³»ç»Ÿ
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°ç¤¼ç‰©åŠ¨ç”»é˜Ÿåˆ—å’Œä¼˜å…ˆçº§
- [ ] **æ£€æŸ¥ç‚¹**: è¿å‡»ç¤¼ç‰©èƒ½åˆå¹¶å±•ç¤º
- [ ] **æ–‡ä»¶**: `live_chat_design/GiftAnimationSystem.kt`

#### Task 9.2.21: æˆ¿é—´çŠ¶æ€åŒæ­¥ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡ç›´æ’­é—´çŠ¶æ€çš„å®æ—¶åŒæ­¥
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°åœ¨çº¿äººæ•°ã€ç‚¹èµæ•°ç­‰çŠ¶æ€åŒæ­¥
- [ ] **æ£€æŸ¥ç‚¹**: çŠ¶æ€æ›´æ–°åŠæ—¶ä¸”å‡†ç¡®
- [ ] **æ–‡ä»¶**: `live_chat_design/RoomStateSync.kt`

#### Task 9.2.22: æ¶ˆæ¯å®¡æ ¸ä¸è¿‡æ»¤ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°å†…å®¹å®‰å…¨å’Œç”¨æˆ·ä½“éªŒ
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ•æ„Ÿè¯è¿‡æ»¤å’Œåƒåœ¾æ¶ˆæ¯è¯†åˆ«
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æœ‰æ•ˆè¿‡æ»¤ä¸å½“å†…å®¹
- [ ] **æ–‡ä»¶**: `live_chat_design/ContentModerator.kt`

## Phase 9: é¢è¯•å®æˆ˜ä¸æ€§èƒ½ä¼˜åŒ– (20åˆ†é’Ÿæ€»è®¡)

#### Task 9.2.23: å®æ—¶é€šä¿¡æ–¹æ¡ˆå¯¹æ¯” (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å‡†å¤‡WebSocket vs SSE vs HTTPè½®è¯¢å¯¹æ¯”
- [ ] **å…·ä½“ä»»åŠ¡**: æ•´ç†å„æ–¹æ¡ˆçš„ä¼˜ç¼ºç‚¹å’Œé€‚ç”¨åœºæ™¯
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©æŠ€æœ¯æ–¹æ¡ˆ
- [ ] **æ–‡ä»¶**: åœ¨`chapter9_interview_qa.md`ä¸­æ·»åŠ å®æ—¶é€šä¿¡éƒ¨åˆ†

#### Task 9.2.24: å¤§è§„æ¨¡ç³»ç»Ÿè®¾è®¡æ€è€ƒ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å±•ç¤ºç³»ç»Ÿæ¶æ„è®¾è®¡èƒ½åŠ›
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ”¯æŒç™¾ä¸‡å¹¶å‘çš„IMç³»ç»Ÿæ¶æ„
- [ ] **æ£€æŸ¥ç‚¹**: è€ƒè™‘è´Ÿè½½å‡è¡¡ã€åˆ†å¸ƒå¼ã€å®¹ç¾ç­‰
- [ ] **æ–‡ä»¶**: æ·»åŠ å¤§è§„æ¨¡ç³»ç»Ÿè®¾è®¡è¦ç‚¹

#### Task 9.2.25: ç§»åŠ¨ç«¯ç‰¹æœ‰æŒ‘æˆ˜ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: åˆ†æç§»åŠ¨ç«¯å®æ—¶é€šä¿¡çš„ç‰¹æ®Šæ€§
- [ ] **å…·ä½“ä»»åŠ¡**: æ€»ç»“ç½‘ç»œåˆ‡æ¢ã€åå°é™åˆ¶ã€ç”µé‡ä¼˜åŒ–ç­‰æŒ‘æˆ˜
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æå‡ºé’ˆå¯¹æ€§è§£å†³æ–¹æ¡ˆ
- [ ] **æ–‡ä»¶**: å®Œå–„ç§»åŠ¨ç«¯ä¼˜åŒ–ç­–ç•¥

#### Task 9.2.26: æ€§èƒ½ç›‘æ§ä¸è°ƒä¼˜ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å»ºç«‹å®æ—¶é€šä¿¡çš„ç›‘æ§ä½“ç³»
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡è¿æ¥æˆåŠŸç‡ã€æ¶ˆæ¯å»¶è¿Ÿç­‰å…³é”®æŒ‡æ ‡
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¿«é€Ÿå®šä½å’Œè§£å†³æ€§èƒ½é—®é¢˜
- [ ] **æ–‡ä»¶**: å®Œæˆå®æ—¶é€šä¿¡è®¾è®¡æ€»ç»“

---

# ğŸ—„ï¸ 9.3 ç¼“å­˜ç­–ç•¥ï¼šå¤šçº§ç¼“å­˜ + æ•°æ®ä¸€è‡´æ€§

> **ğŸ† ç¼“å­˜æ¶æ„å¸ˆå“²å­¦**: äº²æ‰‹æ„å»ºæŠµæŠ—äº¿çº§æ•°æ®é‡çš„ç¼“å­˜ç³»ç»Ÿ
>
> âš ï¸ **ä¸¥æ ¼ç¦æ­¢å¤åˆ¶ç²˜è´´**: æ¯ä¸€è¡Œç¼“å­˜ä»£ç éƒ½å¿…é¡»äº²æ‰‹è¾“å…¥ï¼Œé€šè¿‡æ‰‹æŒ‡è‚Œè‚‰è®°å¿†æŒæ¡ç¼“å­˜çš„åº•å±‚åŸç†
>
> ğŸ’« **å­¦ä¹ è·¯å¾„**: ç¼“å­˜ç†è®º â†’ æ··åˆç­–ç•¥ â†’ å¤šçº§ç¼“å­˜ â†’ åˆ†å¸ƒå¼ä¸€è‡´æ€§ â†’ æŠµæŠ—çº§æ¶æ„

## Phase 10: ç¼“å­˜ç†è®ºä¸ç­–ç•¥è®¾è®¡ (25åˆ†é’Ÿæ€»è®¡)

#### Task 9.3.1: ç¼“å­˜åŸºç¡€ç†è®º (5åˆ†é’Ÿ) â° [Primary]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹å®ç°å¤šç§ç¼“å­˜ç®—æ³•å’Œæ€§èƒ½å¯¹æ¯”ç³»ç»Ÿ ğŸ“Š

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹å®ç°å’Œå¯¹æ¯”æ‰€æœ‰ä¸»æµç¼“å­˜ç®—æ³•
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°æ‰€æœ‰ä¸»æµç¼“å­˜ç®—æ³•å’Œæ€§èƒ½å¯¹æ¯”æ¡†æ¶
  
  // ç¼“å­˜ç®—æ³•æ¥å£å®šä¹‰
  interface CacheEvictionStrategy<K, V> {
      fun put(key: K, value: V): V?
      fun get(key: K): V?
      fun remove(key: K): V?
      fun clear()
      fun size(): Int
      fun getHitRate(): Double
      fun getEvictionCount(): Long
      fun getName(): String
  }
  
  // TODO 1: äº²æ‰‹å®ç°LRUç®—æ³•ï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰
  class LRUCache<K, V>(private val maxSize: Int) : CacheEvictionStrategy<K, V> {
      private val cache = LinkedHashMap<K, V>(maxSize + 1, 0.75f, true)
      private var hitCount = 0L
      private var missCount = 0L
      private var evictionCount = 0L
      
      @Synchronized
      override fun put(key: K, value: V): V? {
          val oldValue = cache.put(key, value)
          
          // æ£€æŸ¥æ˜¯å¦è¶…è¿‡å®¹é‡
          if (cache.size > maxSize) {
              val eldestEntry = cache.entries.iterator().next()
              cache.remove(eldestEntry.key)
              evictionCount++
          }
          
          return oldValue
      }
      
      @Synchronized
      override fun get(key: K): V? {
          val value = cache[key]
          if (value != null) {
              hitCount++
          } else {
              missCount++
          }
          return value
      }
      
      @Synchronized
      override fun remove(key: K): V? {
          return cache.remove(key)
      }
      
      @Synchronized
      override fun clear() {
          cache.clear()
          hitCount = 0
          missCount = 0
          evictionCount = 0
      }
      
      override fun size(): Int = cache.size
      
      override fun getHitRate(): Double {
          val total = hitCount + missCount
          return if (total > 0) hitCount.toDouble() / total else 0.0
      }
      
      override fun getEvictionCount(): Long = evictionCount
      override fun getName(): String = "LRU"
  }
  
  // TODO 2: äº²æ‰‹å®ç°LFUç®—æ³•ï¼ˆæœ€ä½é¢‘ç‡ä¼˜å…ˆï¼‰
  class LFUCache<K, V>(private val maxSize: Int) : CacheEvictionStrategy<K, V> {
      private val cache = mutableMapOf<K, V>()
      private val frequencies = mutableMapOf<K, Int>()
      private val frequencyGroups = mutableMapOf<Int, MutableSet<K>>()
      private var minFrequency = 1
      
      private var hitCount = 0L
      private var missCount = 0L
      private var evictionCount = 0L
      
      @Synchronized
      override fun put(key: K, value: V): V? {
          if (maxSize <= 0) return null
          
          // æ£€æŸ¥é”®æ˜¯å¦å·²å­˜åœ¨
          if (cache.containsKey(key)) {
              val oldValue = cache[key]
              cache[key] = value
              incrementFrequency(key)
              return oldValue
          }
          
          // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸…ç†
          if (cache.size >= maxSize) {
              evictLFU()
          }
          
          // æ·»åŠ æ–°é”®
          cache[key] = value
          frequencies[key] = 1
          frequencyGroups.computeIfAbsent(1) { mutableSetOf() }.add(key)
          minFrequency = 1
          
          return null
      }
      
      @Synchronized
      override fun get(key: K): V? {
          val value = cache[key]
          if (value != null) {
              hitCount++
              incrementFrequency(key)
              return value
          } else {
              missCount++
              return null
          }
      }
      
      private fun incrementFrequency(key: K) {
          val freq = frequencies[key] ?: return
          
          // ä»æ—§é¢‘ç‡ç»„ä¸­åˆ é™¤
          frequencyGroups[freq]?.remove(key)
          if (frequencyGroups[freq]?.isEmpty() == true && freq == minFrequency) {
              minFrequency++
          }
          
          // æ·»åŠ åˆ°æ–°é¢‘ç‡ç»„
          val newFreq = freq + 1
          frequencies[key] = newFreq
          frequencyGroups.computeIfAbsent(newFreq) { mutableSetOf() }.add(key)
      }
      
      private fun evictLFU() {
          // è·å–æœ€ä½é¢‘ç‡çš„é”®
          val keysWithMinFreq = frequencyGroups[minFrequency]
          if (keysWithMinFreq?.isNotEmpty() == true) {
              val keyToEvict = keysWithMinFreq.first()
              
              // æ¸…ç†æ•°æ®
              cache.remove(keyToEvict)
              frequencies.remove(keyToEvict)
              keysWithMinFreq.remove(keyToEvict)
              evictionCount++
          }
      }
      
      @Synchronized
      override fun remove(key: K): V? {
          val value = cache.remove(key)
          if (value != null) {
              val freq = frequencies.remove(key) ?: return value
              frequencyGroups[freq]?.remove(key)
          }
          return value
      }
      
      @Synchronized
      override fun clear() {
          cache.clear()
          frequencies.clear()
          frequencyGroups.clear()
          minFrequency = 1
          hitCount = 0
          missCount = 0
          evictionCount = 0
      }
      
      override fun size(): Int = cache.size
      override fun getHitRate(): Double {
          val total = hitCount + missCount
          return if (total > 0) hitCount.toDouble() / total else 0.0
      }
      override fun getEvictionCount(): Long = evictionCount
      override fun getName(): String = "LFU"
  }
  
  // TODO 3: äº²æ‰‹å®ç°FIFOç®—æ³•ï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰
  class FIFOCache<K, V>(private val maxSize: Int) : CacheEvictionStrategy<K, V> {
      private val cache = LinkedHashMap<K, V>()
      private var hitCount = 0L
      private var missCount = 0L
      private var evictionCount = 0L
      
      @Synchronized
      override fun put(key: K, value: V): V? {
          val oldValue = cache.put(key, value)
          
          if (cache.size > maxSize) {
              val firstKey = cache.keys.first()
              cache.remove(firstKey)
              evictionCount++
          }
          
          return oldValue
      }
      
      @Synchronized
      override fun get(key: K): V? {
          val value = cache[key]
          if (value != null) {
              hitCount++
          } else {
              missCount++
          }
          return value
      }
      
      @Synchronized
      override fun remove(key: K): V? = cache.remove(key)
      
      @Synchronized
      override fun clear() {
          cache.clear()
          hitCount = 0
          missCount = 0
          evictionCount = 0
      }
      
      override fun size(): Int = cache.size
      override fun getHitRate(): Double {
          val total = hitCount + missCount
          return if (total > 0) hitCount.toDouble() / total else 0.0
      }
      override fun getEvictionCount(): Long = evictionCount
      override fun getName(): String = "FIFO"
  }
  
  // TODO 4: äº²æ‰‹å®ç°ç¼“å­˜æ€§èƒ½å¯¹æ¯”æ¡†æ¶
  class CachePerformanceBenchmark {
      
      fun runComprehensiveBenchmark(): BenchmarkResult {
          val algorithms = listOf(
              LRUCache<String, String>(1000),
              LFUCache<String, String>(1000),
              FIFOCache<String, String>(1000)
          )
          
          val results = mutableMapOf<String, AlgorithmMetrics>()
          
          algorithms.forEach { cache ->
              val metrics = benchmarkAlgorithm(cache)
              results[cache.getName()] = metrics
          }
          
          return BenchmarkResult(results)
      }
      
      private fun benchmarkAlgorithm(cache: CacheEvictionStrategy<String, String>): AlgorithmMetrics {
          // TODO: äº²æ‰‹å®ç°æ€§èƒ½æµ‹è¯•
          
          val startTime = System.currentTimeMillis()
          
          // æµ‹è¯•å†™å…¥æ€§èƒ½
          val putStartTime = System.nanoTime()
          repeat(10000) { i ->
              cache.put("key_$i", "value_$i")
          }
          val putTime = System.nanoTime() - putStartTime
          
          // æµ‹è¯•è¯»å–æ€§èƒ½ï¼ˆçƒ­æ•°æ®ï¼‰
          val hotGetStartTime = System.nanoTime()
          repeat(5000) { i ->
              cache.get("key_${i + 5000}") // è®¿é—®ååŠéƒ¨åˆ†
          }
          val hotGetTime = System.nanoTime() - hotGetStartTime
          
          // æµ‹è¯•è¯»å–æ€§èƒ½ï¼ˆå†·æ•°æ®ï¼‰
          val coldGetStartTime = System.nanoTime()
          repeat(2000) { i ->
              cache.get("non_existent_key_$i")
          }
          val coldGetTime = System.nanoTime() - coldGetStartTime
          
          val totalTime = System.currentTimeMillis() - startTime
          
          return AlgorithmMetrics(
              algorithmName = cache.getName(),
              putTimeNanos = putTime,
              hotGetTimeNanos = hotGetTime,
              coldGetTimeNanos = coldGetTime,
              totalTimeMillis = totalTime,
              hitRate = cache.getHitRate(),
              evictionCount = cache.getEvictionCount(),
              finalSize = cache.size()
          )
      }
  }
  
  data class AlgorithmMetrics(
      val algorithmName: String,
      val putTimeNanos: Long,
      val hotGetTimeNanos: Long,
      val coldGetTimeNanos: Long,
      val totalTimeMillis: Long,
      val hitRate: Double,
      val evictionCount: Long,
      val finalSize: Int
  )
  
  data class BenchmarkResult(
      val results: Map<String, AlgorithmMetrics>
  ) {
      fun printComparison() {
          println("ğŸ“Š Cache Algorithm Performance Comparison")
          println("===========================================\n")
          
          results.forEach { (algorithm, metrics) ->
              println("$algorithm:")
              println("  Put Time: ${metrics.putTimeNanos / 1_000_000}ms")
              println("  Hot Get Time: ${metrics.hotGetTimeNanos / 1_000_000}ms")
              println("  Cold Get Time: ${metrics.coldGetTimeNanos / 1_000_000}ms")
              println("  Hit Rate: ${â€œ%.2fâ€.format(metrics.hitRate * 100)}%")
              println("  Evictions: ${metrics.evictionCount}")
              println("  Final Size: ${metrics.finalSize}\n")
          }
      }
  }
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ‰€æœ‰ç¼“å­˜ç®—æ³•çš„å®ç°ä»£ç 
  2. ğŸ“Š å®ç°ç¼“å­˜æ€§èƒ½æµ‹è¯•å’Œå¯¹æ¯”æ¡†æ¶
  3. âš¡ æ„å»ºç¼“å­˜å‘½ä¸­ç‡å’Œæ·˜æ±°ç»Ÿè®¡ç³»ç»Ÿ
  4. ğŸ” ç¼–å†™ä¸åŒåœºæ™¯ä¸‹çš„ç®—æ³•é€‰æ‹©æŒ‡å—
  5. ğŸƒ æµ‹è¯•å„ç§æ•°æ®è®¿é—®æ¨¡å¼ä¸‹çš„ç®—æ³•è¡¨ç°
- [ ] **ç¼“å­˜ç®—æ³•éªŒè¯**: LRUå‘½ä¸­ç‡>80%ï¼ŒLFUé€‚é…æ€§>90%ï¼Œæ€§èƒ½å¯¹æ¯”å‡†ç¡®
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ èƒ½ä¸ºä¸åŒä¸šåŠ¡åœºæ™¯é€‰æ‹©æœ€é€‚åˆçš„ç¼“å­˜ç®—æ³•å—ï¼Ÿ
- [ ] **ç®—æ³•æ£€æŸ¥**: â–¡ LRUå®ç°æ­£ç¡® â–¡ LFUé¢‘ç‡ç»Ÿè®¡å‡†ç¡® â–¡ FIFOé¡ºåºæ­£ç¡® â–¡ æ€§èƒ½å¯¹æ¯”å®Œæ•´
- [ ] **æ–‡ä»¶**: `student_progress/cache_algorithms/`

#### Task 9.3.2: ç¼“å­˜æ·˜æ±°ç®—æ³•å¯¹æ¯” (5åˆ†é’Ÿ) â° [Primary]
**å®æˆ˜ç›®æ ‡**: äº²æ‰‹æ„å»ºæ™ºèƒ½ç¼“å­˜ç®—æ³•é€‰æ‹©å’Œä¼˜åŒ–ç³»ç»Ÿ ğŸ¤–

- [ ] **Primaryç›®æ ‡**: äº²æ‰‹å®ç°è‡ªé€‚åº”çš„ç¼“å­˜ç®—æ³•é€‰æ‹©å’Œæ··åˆç­–ç•¥
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹** (ä¸€å­—ä¸å·®åœ°æ‰‹åŠ¨è¾“å…¥):
  ```kotlin
  // ç›®æ ‡ï¼šå®ç°èƒ½æ ¹æ®æ•°æ®è®¿é—®æ¨¡å¼è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ç®—æ³•çš„ç³»ç»Ÿ
  
  // æ•°æ®è®¿é—®æ¨¡å¼åˆ†æ
  data class AccessPattern(
      val temporalLocality: Double,    // æ—¶é—´å±€éƒ¨æ€§ 0.0-1.0
      val spatialLocality: Double,     // ç©ºé—´å±€éƒ¨æ€§ 0.0-1.0
      val accessFrequency: Double,     // è®¿é—®é¢‘ç‡ 0.0-1.0
      val dataLifetime: Long,          // æ•°æ®ç”Ÿå‘½å‘¨æœŸï¼ˆæ¯«ç§’ï¼‰
      val workingSetSize: Int,         // å·¥ä½œé›†å¤§å°
      val randomAccessRatio: Double    // éšæœºè®¿é—®æ¯”ä¾‹
  )
  
  // TODO 1: äº²æ‰‹å®ç°æ•°æ®è®¿é—®æ¨¡å¼åˆ†æå™¨
  class AccessPatternAnalyzer {
      private val accessHistory = mutableListOf<AccessRecord>()
      private val keyFrequencies = mutableMapOf<String, Long>()
      private val accessTimes = mutableMapOf<String, MutableList<Long>>()
      
      fun recordAccess(key: String, timestamp: Long = System.currentTimeMillis()) {
          // è®°å½•è®¿é—®å†å²
          accessHistory.add(AccessRecord(key, timestamp))
          
          // æ›´æ–°é¢‘ç‡ç»Ÿè®¡
          keyFrequencies[key] = keyFrequencies.getOrDefault(key, 0) + 1
          
          // è®°å½•è®¿é—®æ—¶é—´
          accessTimes.computeIfAbsent(key) { mutableListOf() }.add(timestamp)
          
          // ä¿æŒå†å²å¤§å°
          if (accessHistory.size > 10000) {
              accessHistory.removeAt(0)
          }
      }
      
      fun analyzePattern(): AccessPattern {
          // TODO: äº²æ‰‹å®ç°è®¿é—®æ¨¡å¼åˆ†æç®—æ³•
          
          val temporalLocality = calculateTemporalLocality()
          val spatialLocality = calculateSpatialLocality()
          val accessFrequency = calculateAccessFrequency()
          val avgLifetime = calculateAverageDataLifetime()
          val workingSetSize = calculateWorkingSetSize()
          val randomRatio = calculateRandomAccessRatio()
          
          return AccessPattern(
              temporalLocality = temporalLocality,
              spatialLocality = spatialLocality,
              accessFrequency = accessFrequency,
              dataLifetime = avgLifetime,
              workingSetSize = workingSetSize,
              randomAccessRatio = randomRatio
          )
      }
      
      private fun calculateTemporalLocality(): Double {
          // TODO: è®¡ç®—æ—¶é—´å±€éƒ¨æ€§ï¼ˆé‡å¤è®¿é—®çš„æ•°æ®åœ¨çŸ­æ—¶é—´å†…å†æ¬¡è®¿é—®çš„æ¦‚ç‡ï¼‰
          if (accessHistory.size < 2) return 0.0
          
          val timeWindow = 60_000L // 1åˆ†é’Ÿçª—å£
          var repeatedAccesses = 0
          val recentKeys = mutableSetOf<String>()
          
          for (i in accessHistory.size - 1 downTo 0) {
              val record = accessHistory[i]
              val timeSinceNow = System.currentTimeMillis() - record.timestamp
              
              if (timeSinceNow > timeWindow) break
              
              if (record.key in recentKeys) {
                  repeatedAccesses++
              } else {
                  recentKeys.add(record.key)
              }
          }
          
          return if (accessHistory.size > 0) {
              repeatedAccesses.toDouble() / accessHistory.size
          } else 0.0
      }
      
      private fun calculateSpatialLocality(): Double {
          // TODO: è®¡ç®—ç©ºé—´å±€éƒ¨æ€§ï¼ˆç›¸ä¼¼é”®çš„è®¿é—®æ¨¡å¼ï¼‰
          val sequentialAccesses = accessHistory.zipWithNext { current, next ->
              if (areKeysSequential(current.key, next.key)) 1 else 0
          }.sum()
          
          return if (accessHistory.size > 1) {
              sequentialAccesses.toDouble() / (accessHistory.size - 1)
          } else 0.0
      }
      
      private fun areKeysSequential(key1: String, key2: String): Boolean {
          // TODO: åˆ¤æ–­ä¸¤ä¸ªé”®æ˜¯å¦åœ¨ç©ºé—´ä¸Šç›¸é‚»
          return try {
              val num1 = key1.substringAfterLast("_").toIntOrNull()
              val num2 = key2.substringAfterLast("_").toIntOrNull()
              if (num1 != null && num2 != null) {
                  kotlin.math.abs(num1 - num2) <= 1
              } else {
                  false
              }
          } catch (e: Exception) {
              false
          }
      }
      
      private fun calculateAccessFrequency(): Double {
          // TODO: è®¡ç®—å¹³å‡è®¿é—®é¢‘ç‡
          val uniqueKeys = keyFrequencies.size
          val totalAccesses = keyFrequencies.values.sum()
          
          return if (uniqueKeys > 0) {
              totalAccesses.toDouble() / uniqueKeys
          } else 0.0
      }
      
      private fun calculateAverageDataLifetime(): Long {
          // TODO: è®¡ç®—æ•°æ®çš„å¹³å‡ç”Ÿå‘½å‘¨æœŸ
          val lifetimes = accessTimes.values.mapNotNull { times ->
              if (times.size > 1) {
                  times.maxOrNull()?.minus(times.minOrNull() ?: 0L)
              } else null
          }
          
          return if (lifetimes.isNotEmpty()) {
              lifetimes.average().toLong()
          } else 0L
      }
      
      private fun calculateWorkingSetSize(): Int {
          // TODO: è®¡ç®—å·¥ä½œé›†å¤§å°ï¼ˆæœ€è¿‘æ—¶é—´çª—å£å†…çš„å”¯ä¸€é”®æ•°é‡ï¼‰
          val timeWindow = 300_000L // 5åˆ†é’Ÿçª—å£
          val currentTime = System.currentTimeMillis()
          
          return accessHistory.filter { 
              currentTime - it.timestamp <= timeWindow 
          }.map { it.key }.toSet().size
      }
      
      private fun calculateRandomAccessRatio(): Double {
          // TODO: è®¡ç®—éšæœºè®¿é—®æ¯”ä¾‹
          val spatialLocality = calculateSpatialLocality()
          return 1.0 - spatialLocality
      }
  }
  
  // TODO 2: äº²æ‰‹å®ç°æ™ºèƒ½ç¼“å­˜ç®—æ³•é€‰æ‹©å™¨
  class SmartCacheSelector {
      
      fun selectOptimalAlgorithm(pattern: AccessPattern): CacheAlgorithmType {
          // TODO: æ ¹æ®è®¿é—®æ¨¡å¼é€‰æ‹©æœ€ä¼˜ç®—æ³•
          
          val score = calculateAlgorithmScores(pattern)
          return score.maxByOrNull { it.value }?.key ?: CacheAlgorithmType.LRU
      }
      
      private fun calculateAlgorithmScores(pattern: AccessPattern): Map<CacheAlgorithmType, Double> {
          val scores = mutableMapOf<CacheAlgorithmType, Double>()
          
          // LRUå¾—åˆ†è®¡ç®—
          scores[CacheAlgorithmType.LRU] = calculateLRUScore(pattern)
          
          // LFUå¾—åˆ†è®¡ç®—
          scores[CacheAlgorithmType.LFU] = calculateLFUScore(pattern)
          
          // FIFOå¾—åˆ†è®¡ç®—
          scores[CacheAlgorithmType.FIFO] = calculateFIFOScore(pattern)
          
          // æ··åˆç­–ç•¥å¾—åˆ†
          scores[CacheAlgorithmType.HYBRID] = calculateHybridScore(pattern)
          
          return scores
      }
      
      private fun calculateLRUScore(pattern: AccessPattern): Double {
          // TODO: LRUé€‚åˆæ—¶é—´å±€éƒ¨æ€§å¼ºçš„åœºæ™¯
          var score = 0.0
          
          // æ—¶é—´å±€éƒ¨æ€§è¶Šå¼ºï¼ŒLRUè¶Šé€‚åˆ
          score += pattern.temporalLocality * 0.4
          
          // éšæœºè®¿é—®æ¯”ä¾‹é€‚ä¸­æ—¶LRUè¡¨ç°è¾ƒå¥½
          if (pattern.randomAccessRatio in 0.3..0.7) {
              score += 0.3
          }
          
          // å·¥ä½œé›†å¤§å°é€‚ä¸­æ—¶LRUæ•ˆæœå¥½
          if (pattern.workingSetSize in 100..1000) {
              score += 0.2
          }
          
          // æ•°æ®ç”Ÿå‘½å‘¨æœŸçŸ­æ—¶LRUé€‚åˆ
          if (pattern.dataLifetime < 300_000) { // 5åˆ†é’Ÿ
              score += 0.1
          }
          
          return score
      }
      
      private fun calculateLFUScore(pattern: AccessPattern): Double {
          // TODO: LFUé€‚åˆé¢‘ç‡å·®å¼‚æ˜æ˜¾çš„åœºæ™¯
          var score = 0.0
          
          // è®¿é—®é¢‘ç‡é«˜ä¸”é›†ä¸­æ—¶LFUé€‚åˆ
          if (pattern.accessFrequency > 2.0) {
              score += 0.4
          }
          
          // æ•°æ®ç”Ÿå‘½å‘¨æœŸé•¿æ—¶LFUä¼˜åŠ¿æ˜æ˜¾
          if (pattern.dataLifetime > 3600_000) { // 1å°æ—¶
              score += 0.3
          }
          
          // æ—¶é—´å±€éƒ¨æ€§å¼±ä½†é¢‘ç‡å±€éƒ¨æ€§å¼ºæ—¶LFUé€‚åˆ
          if (pattern.temporalLocality < 0.3 && pattern.accessFrequency > 1.5) {
              score += 0.2
          }
          
          // å·¥ä½œé›†è¾ƒå¤§æ—¶LFUé€‚åˆ
          if (pattern.workingSetSize > 1000) {
              score += 0.1
          }
          
          return score
      }
      
      private fun calculateFIFOScore(pattern: AccessPattern): Double {
          // TODO: FIFOé€‚åˆç®€å•åœºæ™¯å’Œæµå¼æ•°æ®
          var score = 0.0
          
          // ç©ºé—´å±€éƒ¨æ€§å¼ºæ—¶FIFOé€‚åˆ
          score += pattern.spatialLocality * 0.4
          
          // è®¿é—®é¢‘ç‡ä½ä¸”å‡åŒ€æ—¶FIFOç®€å•æœ‰æ•ˆ
          if (pattern.accessFrequency < 1.2) {
              score += 0.3
          }
          
          // æ•°æ®ç”Ÿå‘½å‘¨æœŸçŸ­ä¸”å‡åŒ€æ—¶FIFOé€‚åˆ
          if (pattern.dataLifetime < 60_000) { // 1åˆ†é’Ÿ
              score += 0.2
          }
          
          // éšæœºè®¿é—®æ¯”ä¾‹ä½æ—¶FIFOé€‚åˆ
          if (pattern.randomAccessRatio < 0.3) {
              score += 0.1
          }
          
          return score
      }
      
      private fun calculateHybridScore(pattern: AccessPattern): Double {
          // TODO: æ··åˆç­–ç•¥é€‚åˆå¤æ‚åœºæ™¯
          var score = 0.0
          
          // è®¿é—®æ¨¡å¼å¤æ‚æ—¶æ··åˆç­–ç•¥æœ‰ä¼˜åŠ¿
          val complexity = pattern.temporalLocality * pattern.spatialLocality * pattern.randomAccessRatio
          if (complexity > 0.1) {
              score += 0.5
          }
          
          // å·¥ä½œé›†å¤§å°å˜åŒ–å¤§æ—¶æ··åˆç­–ç•¥é€‚åˆ
          if (pattern.workingSetSize > 500) {
              score += 0.3
          }
          
          // é¢‘ç‡å’Œæ—¶é—´å±€éƒ¨æ€§éƒ½ä¸­ç­‰æ—¶æ··åˆç­–ç•¥æ•ˆæœå¥½
          if (pattern.accessFrequency in 1.0..3.0 && pattern.temporalLocality in 0.3..0.7) {
              score += 0.2
          }
          
          return score
      }
  }
  
  enum class CacheAlgorithmType {
      LRU, LFU, FIFO, HYBRID
  }
  
  data class AccessRecord(
      val key: String,
      val timestamp: Long
  )
  ```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥è®¿é—®æ¨¡å¼åˆ†æå’Œç®—æ³•é€‰æ‹©ç³»ç»Ÿ
  2. ğŸ¤– å®ç°æ™ºèƒ½ç®—æ³•é€‰æ‹©å’Œæ··åˆç­–ç•¥
  3. ğŸ“Š æ„å»ºç¼“å­˜æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–ç³»ç»Ÿ
  4. ğŸ” ç¼–å†™ä¸åŒä¸šåŠ¡åœºæ™¯çš„ç®—æ³•é€‰æ‹©æŒ‡å—
  5. ğŸƒ æµ‹è¯•è‡ªé€‚åº”é€‰æ‹©åœ¨å„ç§æ•°æ®è®¿é—®æ¨¡å¼ä¸‹çš„è¡¨ç°
- [ ] **æ™ºèƒ½é€‰æ‹©éªŒè¯**: é€‰æ‹©å‡†ç¡®ç‡>85%ï¼Œæ€§èƒ½æå‡2x+ï¼Œé€‚é…æ€§>90%
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ çš„æ™ºèƒ½é€‰æ‹©ç³»ç»Ÿèƒ½åœ¨å®é™…ä¸šåŠ¡ä¸­è‡ªåŠ¨ä¼˜åŒ–ç¼“å­˜ç­–ç•¥å—ï¼Ÿ
- [ ] **æ™ºèƒ½æ£€æŸ¥**: â–¡ æ¨¡å¼è¯†åˆ«å‡†ç¡® â–¡ ç®—æ³•é€‰æ‹©åˆç† â–¡ æ··åˆç­–ç•¥æœ‰æ•ˆ â–¡ æ€§èƒ½ç›‘æ§å®Œæ•´
- [ ] **æ–‡ä»¶**: `student_progress/cache_algorithms/smart_selector/`

#### Task 9.3.3: Androidç¼“å­˜å±‚æ¬¡ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: ç†è§£Androidç³»ç»Ÿçš„å¤šçº§ç¼“å­˜
- [ ] **å…·ä½“ä»»åŠ¡**: åˆ†æå†…å­˜ç¼“å­˜ã€ç£ç›˜ç¼“å­˜ã€ç½‘ç»œç¼“å­˜çš„å±‚æ¬¡
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½è®¾è®¡åº”ç”¨çš„ç¼“å­˜å±‚æ¬¡ç»“æ„
- [ ] **æ–‡ä»¶**: æ·»åŠ Androidç¼“å­˜å±‚æ¬¡åˆ†æ

#### Task 9.3.4: ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: ç†è§£åˆ†å¸ƒå¼ç¼“å­˜çš„ä¸€è‡´æ€§æŒ‘æˆ˜
- [ ] **å…·ä½“ä»»åŠ¡**: å­¦ä¹ å¼ºä¸€è‡´æ€§ã€æœ€ç»ˆä¸€è‡´æ€§ã€å¼±ä¸€è‡´æ€§
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åˆ†æä¸šåŠ¡å¯¹ä¸€è‡´æ€§çš„è¦æ±‚
- [ ] **æ–‡ä»¶**: æ·»åŠ ä¸€è‡´æ€§ç­–ç•¥åˆ†æ

#### Task 9.3.5: ç¼“å­˜ç©¿é€ä¸é›ªå´© (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: ç†è§£ç¼“å­˜å¤±æ•ˆçš„å¸¸è§é—®é¢˜
- [ ] **å…·ä½“ä»»åŠ¡**: å­¦ä¹ å¸ƒéš†è¿‡æ»¤å™¨ã€ç¼“å­˜é¢„çƒ­ç­‰è§£å†³æ–¹æ¡ˆ
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½è®¾è®¡é˜²æŠ¤ç­–ç•¥
- [ ] **æ–‡ä»¶**: å®Œå–„ç¼“å­˜é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

## Phase 11: å›¾ç‰‡åº”ç”¨ç¼“å­˜æ¶æ„å®æˆ˜ (35åˆ†é’Ÿæ€»è®¡)

#### Task 9.3.6: å›¾ç‰‡ç¼“å­˜éœ€æ±‚åˆ†æ (5åˆ†é’Ÿ) â° [Primary]
- [ ] **å­¦ä¹ ç›®æ ‡**: åˆ†æå›¾ç‰‡åº”ç”¨çš„ç¼“å­˜éœ€æ±‚
- [ ] **å…·ä½“ä»»åŠ¡**: è€ƒè™‘å›¾ç‰‡å¤§å°ã€è®¿é—®é¢‘ç‡ã€å­˜å‚¨é™åˆ¶
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åˆ¶å®šå›¾ç‰‡ç¼“å­˜ç­–ç•¥
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/image_cache_design/requirements.md`

#### Task 9.3.7: å†…å­˜ç¼“å­˜è®¾è®¡ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°é«˜æ•ˆçš„å†…å­˜å›¾ç‰‡ç¼“å­˜
- [ ] **å…·ä½“ä»»åŠ¡**: ä½¿ç”¨LruCacheå®ç°å†…å­˜ç¼“å­˜
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æ ¹æ®å†…å­˜å¤§å°åŠ¨æ€è°ƒæ•´ç¼“å­˜å®¹é‡
- [ ] **æ–‡ä»¶**: `image_cache_design/MemoryImageCache.kt`

#### Task 9.3.8: ç£ç›˜ç¼“å­˜å®ç° (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°æŒä¹…åŒ–å›¾ç‰‡ç¼“å­˜
- [ ] **å…·ä½“ä»»åŠ¡**: ä½¿ç”¨DiskLruCacheç®¡ç†ç£ç›˜ç¼“å­˜
- [ ] **æ£€æŸ¥ç‚¹**: æ”¯æŒç¼“å­˜å¤§å°é™åˆ¶å’ŒLRUæ·˜æ±°
- [ ] **æ–‡ä»¶**: `image_cache_design/DiskImageCache.kt`

#### Task 9.3.9: å¤šçº§ç¼“å­˜åè°ƒ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡å†…å­˜-ç£ç›˜-ç½‘ç»œçš„åè°ƒæœºåˆ¶
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°ç¼“å­˜æŸ¥æ‰¾çš„ä¼˜å…ˆçº§ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: ç¼“å­˜å‘½ä¸­ç‡é«˜ï¼ŒæŸ¥æ‰¾æ•ˆç‡ä¼˜
- [ ] **æ–‡ä»¶**: `image_cache_design/MultiLevelCache.kt`

#### Task 9.3.10: å›¾ç‰‡æ ¼å¼ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: æ ¹æ®åœºæ™¯é€‰æ‹©æœ€ä¼˜å›¾ç‰‡æ ¼å¼
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°WebPã€JPEGã€PNGçš„æ™ºèƒ½é€‰æ‹©
- [ ] **æ£€æŸ¥ç‚¹**: åœ¨è´¨é‡å’Œå¤§å°é—´æ‰¾åˆ°å¹³è¡¡
- [ ] **æ–‡ä»¶**: `image_cache_design/ImageFormatOptimizer.kt`

#### Task 9.3.11: é¢„åŠ è½½ç­–ç•¥ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡æ™ºèƒ½çš„å›¾ç‰‡é¢„åŠ è½½
- [ ] **å…·ä½“ä»»åŠ¡**: æ ¹æ®ç”¨æˆ·è¡Œä¸ºé¢„æµ‹éœ€è¦çš„å›¾ç‰‡
- [ ] **æ£€æŸ¥ç‚¹**: æå‡ç”¨æˆ·ä½“éªŒåŒæ—¶æ§åˆ¶æµé‡
- [ ] **æ–‡ä»¶**: `image_cache_design/PreloadManager.kt`

#### Task 9.3.12: ç¼“å­˜ç»Ÿè®¡ä¸ç›‘æ§ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å»ºç«‹ç¼“å­˜æ•ˆæœçš„ç›‘æ§ä½“ç³»
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°å‘½ä¸­ç‡ã€å†…å­˜ä½¿ç”¨ã€ç£ç›˜å ç”¨ç»Ÿè®¡
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æ•°æ®é©±åŠ¨åœ°ä¼˜åŒ–ç¼“å­˜ç­–ç•¥
- [ ] **æ–‡ä»¶**: `image_cache_design/CacheMetrics.kt`

## Phase 12: ç¼“å­˜ä¸€è‡´æ€§ä¿è¯æœºåˆ¶ (30åˆ†é’Ÿæ€»è®¡)

#### Task 9.3.13: ç‰ˆæœ¬æ§åˆ¶æœºåˆ¶ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡ç¼“å­˜æ•°æ®çš„ç‰ˆæœ¬ç®¡ç†
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°åŸºäºETagçš„ç¼“å­˜éªŒè¯
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æ£€æµ‹æ•°æ®æ˜¯å¦å·²è¿‡æœŸ
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/cache_consistency/VersionManager.kt`

#### Task 9.3.14: å¤±æ•ˆé€šçŸ¥æœºåˆ¶ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°ä¸»åŠ¨çš„ç¼“å­˜å¤±æ•ˆé€šçŸ¥
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ¨é€å¼çš„ç¼“å­˜æ›´æ–°æœºåˆ¶
- [ ] **æ£€æŸ¥ç‚¹**: æ•°æ®å˜æ›´èƒ½åŠæ—¶é€šçŸ¥å®¢æˆ·ç«¯
- [ ] **æ–‡ä»¶**: `cache_consistency/InvalidationNotifier.kt`

#### Task 9.3.15: åˆ†å¸ƒå¼ç¼“å­˜åŒæ­¥ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å¤„ç†å¤šè®¾å¤‡é—´çš„ç¼“å­˜åŒæ­¥
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æœ€ç»ˆä¸€è‡´æ€§çš„åŒæ­¥ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: å¤šè®¾å¤‡æ•°æ®èƒ½è¾¾åˆ°æœ€ç»ˆä¸€è‡´
- [ ] **æ–‡ä»¶**: `cache_consistency/DistributedSync.kt`

#### Task 9.3.16: å†²çªè§£å†³ç­–ç•¥ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å¤„ç†ç¼“å­˜æ•°æ®çš„å†™å…¥å†²çª
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°last-write-winsã€vector-clockç­‰ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åˆç†è§£å†³æ•°æ®å†²çª
- [ ] **æ–‡ä»¶**: `cache_consistency/ConflictResolver.kt`

#### Task 9.3.17: äº‹åŠ¡æ€§ç¼“å­˜æ“ä½œ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¿è¯ç¼“å­˜æ“ä½œçš„åŸå­æ€§
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°ç¼“å­˜çš„äº‹åŠ¡æ“ä½œæ”¯æŒ
- [ ] **æ£€æŸ¥ç‚¹**: å¤šä¸ªç¼“å­˜æ“ä½œè¦ä¹ˆå…¨æˆåŠŸè¦ä¹ˆå…¨å¤±è´¥
- [ ] **æ–‡ä»¶**: `cache_consistency/TransactionalCache.kt`

#### Task 9.3.18: ç¼“å­˜ä¸€è‡´æ€§æµ‹è¯• (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: éªŒè¯ç¼“å­˜ä¸€è‡´æ€§ç­–ç•¥çš„æ­£ç¡®æ€§
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡å¹¶å‘åœºæ™¯ä¸‹çš„ä¸€è‡´æ€§æµ‹è¯•
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åœ¨æµ‹è¯•ä¸­å‘ç°å’Œä¿®å¤ä¸€è‡´æ€§é—®é¢˜
- [ ] **æ–‡ä»¶**: `cache_consistency/ConsistencyTest.kt`

## Phase 13: æŠ–éŸ³çº§çŸ­è§†é¢‘ç¼“å­˜ç³»ç»Ÿ (25åˆ†é’Ÿæ€»è®¡)

#### Task 9.3.19: è§†é¢‘ç¼“å­˜ç‰¹æ®Šéœ€æ±‚ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: åˆ†æè§†é¢‘ç¼“å­˜çš„ç‰¹æ®Šæ€§
- [ ] **å…·ä½“ä»»åŠ¡**: è€ƒè™‘æ–‡ä»¶å¤§å°ã€ç½‘ç»œå¸¦å®½ã€æ’­æ”¾æµç•…æ€§
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åˆ¶å®šè§†é¢‘ç¼“å­˜çš„ç‹¬ç‰¹ç­–ç•¥
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/video_cache_design/requirements.md`

#### Task 9.3.20: åˆ†ç‰‡ç¼“å­˜æœºåˆ¶ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°è§†é¢‘çš„åˆ†ç‰‡ç¼“å­˜ç­–ç•¥
- [ ] **å…·ä½“ä»»åŠ¡**: å°†è§†é¢‘åˆ†æ®µç¼“å­˜ï¼Œæ”¯æŒè¾¹ä¸‹è¾¹æ’­
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æå‡è§†é¢‘æ’­æ”¾çš„å¯åŠ¨é€Ÿåº¦
- [ ] **æ–‡ä»¶**: `video_cache_design/ChunkedVideoCache.kt`

#### Task 9.3.21: æ™ºèƒ½é¢„ç¼“å­˜ç®—æ³• (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: æ ¹æ®ç”¨æˆ·è¡Œä¸ºé¢„æµ‹ç¼“å­˜éœ€æ±‚
- [ ] **å…·ä½“ä»»åŠ¡**: åˆ†æç”¨æˆ·æ»‘åŠ¨æ¨¡å¼ï¼Œé¢„ç¼“å­˜å¯èƒ½è§‚çœ‹çš„è§†é¢‘
- [ ] **æ£€æŸ¥ç‚¹**: æé«˜ç¼“å­˜å‘½ä¸­ç‡ï¼Œå‡å°‘ç­‰å¾…æ—¶é—´
- [ ] **æ–‡ä»¶**: `video_cache_design/PredictiveCache.kt`

#### Task 9.3.22: ç½‘ç»œè‡ªé€‚åº”ç¼“å­˜ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: æ ¹æ®ç½‘ç»œæ¡ä»¶è°ƒæ•´ç¼“å­˜ç­–ç•¥
- [ ] **å…·ä½“ä»»åŠ¡**: WiFiä¸‹æ¿€è¿›ç¼“å­˜ï¼Œç§»åŠ¨ç½‘ç»œä¸‹ä¿å®ˆç¼“å­˜
- [ ] **æ£€æŸ¥ç‚¹**: åœ¨ç”¨æˆ·ä½“éªŒå’Œæµé‡æ¶ˆè€—é—´å¹³è¡¡
- [ ] **æ–‡ä»¶**: `video_cache_design/AdaptiveCache.kt`

#### Task 9.3.23: å¤§è§„æ¨¡ç¼“å­˜æ¶æ„ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡æ”¯æŒåƒä¸‡çº§ç”¨æˆ·çš„ç¼“å­˜æ¶æ„
- [ ] **å…·ä½“ä»»åŠ¡**: è€ƒè™‘CDNã€è¾¹ç¼˜ç¼“å­˜ã€çƒ­ç‚¹æ•°æ®ç­‰
- [ ] **æ£€æŸ¥ç‚¹**: ç³»ç»Ÿèƒ½æ‰¿å—é«˜å¹¶å‘è®¿é—®
- [ ] **æ–‡ä»¶**: `video_cache_design/ScalableArchitecture.md`

## Phase 14: é¢è¯•å®æˆ˜ä¸ç¼“å­˜ä¼˜åŒ– (15åˆ†é’Ÿæ€»è®¡)

#### Task 9.3.24: ç¼“å­˜ç­–ç•¥é€‰æ‹© (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å‡†å¤‡ç¼“å­˜ç­–ç•¥çš„é¢è¯•é—®é¢˜
- [ ] **å…·ä½“ä»»åŠ¡**: æ•´ç†ä¸åŒä¸šåŠ¡åœºæ™¯çš„ç¼“å­˜é€‰æ‹©ä¾æ®
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½ä¸ºå…·ä½“åœºæ™¯è®¾è®¡ç¼“å­˜æ–¹æ¡ˆ
- [ ] **æ–‡ä»¶**: åœ¨`chapter9_interview_qa.md`ä¸­æ·»åŠ ç¼“å­˜ç­–ç•¥éƒ¨åˆ†

#### Task 9.3.25: æ€§èƒ½ä¼˜åŒ–å®è·µ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å±•ç¤ºç¼“å­˜ä¼˜åŒ–çš„å®æˆ˜ç»éªŒ
- [ ] **å…·ä½“ä»»åŠ¡**: æ€»ç»“ç¼“å­˜æ€§èƒ½è°ƒä¼˜çš„æ–¹æ³•å’Œå·¥å…·
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å®šä½å’Œè§£å†³ç¼“å­˜æ€§èƒ½é—®é¢˜
- [ ] **æ–‡ä»¶**: æ·»åŠ æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹

#### Task 9.3.26: é«˜çº§ç¼“å­˜è¯é¢˜ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å‡†å¤‡é«˜çº§ç¼“å­˜é¢è¯•é—®é¢˜
- [ ] **å…·ä½“ä»»åŠ¡**: å‡†å¤‡åˆ†å¸ƒå¼ç¼“å­˜ã€ç¼“å­˜é›ªå´©ç­‰é«˜çº§è¯é¢˜
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æ·±å…¥è®¨è®ºç¼“å­˜çš„å¤æ‚é—®é¢˜
- [ ] **æ–‡ä»¶**: å®Œæˆç¼“å­˜è®¾è®¡æ€»ç»“

---

# ğŸ—ï¸ 9.4 å¤§å‹åº”ç”¨æ¶æ„ï¼šå¾®æœåŠ¡ + æ¨¡å—åŒ–

## Phase 15: æ¨¡å—åŒ–æ¶æ„è®¾è®¡ (30åˆ†é’Ÿæ€»è®¡)

#### Task 9.4.1: æ¨¡å—åŒ–åŸºç¡€æ¦‚å¿µ (5åˆ†é’Ÿ) â° [Primary]
> **æ¶æ„å“²å­¦**: è½¯ä»¶ç³»ç»Ÿçš„å¤æ‚æ€§æºäºç»„ä»¶é—´çš„ç›¸äº’ä¾èµ–ï¼Œæ¨¡å—åŒ–æ˜¯ç®¡ç†å¤æ‚æ€§çš„æœ€ä½³å®è·µ
> **æ‰‹åŠ¨ç¼–ç¨‹**: é€šè¿‡äº²æ‰‹æ„å»ºæ¨¡å—ä¾èµ–ç®¡ç†ç³»ç»Ÿï¼Œæ·±åº¦ç†è§£æ¨¡å—åŒ–çš„æ ¸å¿ƒä»·å€¼
> **No Copy-Paste**: å¿…é¡»æ‰‹åŠ¨è¾“å…¥æ¯è¡Œä»£ç ï¼ŒåŸ¹å…»æ¶æ„æ€ç»´çš„è‚Œè‚‰è®°å¿†

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºæ”¯æŒ100+æ¨¡å—çš„ä¼ä¸šçº§ä¾èµ–ç®¡ç†ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - æ¨¡å—åŒ–æ¶æ„ç®¡ç†å™¨**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°æ¨¡å—å®šä¹‰æ•°æ®ç»“æ„
data class Module(
    val name: String,
    val type: ModuleType,
    val dependencies: Set<String> = emptySet(),
    val apiSurface: Set<String> = emptySet(),
    val resources: Set<String> = emptySet(),
    val buildTimeMs: Long = 0,
    val testCoveragePercent: Double = 0.0
) {
    // TODO 2: æ‰‹åŠ¨å®ç°å†…èšæ€§è®¡ç®—
    fun calculateCohesion(): Double {
        // è®¡ç®—æ¨¡å—å†…éƒ¨ç»„ä»¶çš„å…³è”åº¦
        return if (apiSurface.isEmpty()) 0.0 
        else resources.size.toDouble() / apiSurface.size
    }
    
    // TODO 3: æ‰‹åŠ¨å®ç°å•ä¸€èŒè´£æ£€æŸ¥
    fun checkSingleResponsibility(): ResponsibilityScore {
        val apiCategories = apiSurface.groupBy { extractCategory(it) }
        val diversityScore = 1.0 / (apiCategories.size.coerceAtLeast(1))
        return ResponsibilityScore(diversityScore, apiCategories.keys)
    }
}

// TODO 4: äº²æ‰‹å®ç°æ¨¡å—ç±»å‹æšä¸¾
enum class ModuleType(val description: String, val allowedDependencies: Set<ModuleType>) {
    APP("åº”ç”¨æ¨¡å—", setOf(FEATURE, LIBRARY, COMMON)),
    FEATURE("åŠŸèƒ½æ¨¡å—", setOf(LIBRARY, COMMON)),
    LIBRARY("åº“æ¨¡å—", setOf(COMMON)),
    COMMON("åŸºç¡€æ¨¡å—", emptySet());
    
    // TODO 5: æ‰‹åŠ¨å®ç°ä¾èµ–è§„åˆ™éªŒè¯
    fun canDependOn(target: ModuleType): Boolean = target in allowedDependencies
}

// TODO 6: äº²æ‰‹å®ç°ä¾èµ–å›¾åˆ†æå™¨
class DependencyAnalyzer {
    private val modules = mutableMapOf<String, Module>()
    private val dependencyGraph = mutableMapOf<String, MutableSet<String>>()
    
    // TODO 7: æ‰‹åŠ¨å®ç°å¾ªç¯ä¾èµ–æ£€æµ‹
    fun detectCircularDependencies(): List<List<String>> {
        val visited = mutableSetOf<String>()
        val recursionStack = mutableSetOf<String>()
        val cycles = mutableListOf<List<String>>()
        
        for (module in modules.keys) {
            if (module !in visited) {
                findCyclesInPath(module, visited, recursionStack, cycles, mutableListOf())
            }
        }
        return cycles
    }
    
    // TODO 8: æ‰‹åŠ¨å®ç°æ„å»ºé¡ºåºè®¡ç®—
    fun calculateBuildOrder(): List<String> {
        val inDegree = modules.keys.associateWith { 0 }.toMutableMap()
        
        // è®¡ç®—å…¥åº¦
        for ((module, deps) in dependencyGraph) {
            for (dep in deps) {
                inDegree[dep] = inDegree.getValue(dep) + 1
            }
        }
        
        // æ‹“æ‰‘æ’åº
        val queue = ArrayDeque(inDegree.filter { it.value == 0 }.keys)
        val buildOrder = mutableListOf<String>()
        
        while (queue.isNotEmpty()) {
            val current = queue.removeFirst()
            buildOrder.add(current)
            
            dependencyGraph[current]?.forEach { dependent ->
                inDegree[dependent] = inDegree.getValue(dependent) - 1
                if (inDegree.getValue(dependent) == 0) {
                    queue.add(dependent)
                }
            }
        }
        
        return buildOrder
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ¨¡å—æ•°æ®ç»“æ„å’Œç±»å‹å®šä¹‰
  2. ğŸ” å®ç°å†…èšæ€§å’Œå•ä¸€èŒè´£æ£€æŸ¥ç®—æ³•
  3. ğŸŒ æ„å»ºä¾èµ–å›¾å’Œå¾ªç¯ä¾èµ–æ£€æµ‹
  4. âš¡ ç¼–å†™æ‹“æ‰‘æ’åºå’Œæ„å»ºé¡ºåºè®¡ç®—
  5. ğŸƒ æµ‹è¯•100ä¸ªæ¨¡å—çš„ä¾èµ–åˆ†ææ€§èƒ½
- [ ] **æ¶æ„å¤æ‚åº¦éªŒè¯**: æ”¯æŒ>100æ¨¡å—ï¼Œå¾ªç¯æ£€æµ‹<1sï¼Œæ„å»ºé¡ºåºè®¡ç®—æ­£ç¡®ç‡100%
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ èƒ½è¯´å‡ºæ¨¡å—åŒ–è§£å†³äº†å“ª3ä¸ªæ ¸å¿ƒé—®é¢˜å—ï¼Ÿ
- [ ] **æ¶æ„æ£€æŸ¥**: â–¡ ä¾èµ–è§„åˆ™æ¸…æ™° â–¡ å¾ªç¯æ£€æµ‹å‡†ç¡® â–¡ æ„å»ºé¡ºåºæ­£ç¡® â–¡ æ€§èƒ½è¾¾æ ‡
- [ ] **æ–‡ä»¶**: `student_progress/modular/dependency_analyzer/`

#### Task 9.4.2: Androidæ¨¡å—ç±»å‹ (5åˆ†é’Ÿ) â° [Primary]
> **æ¶æ„åŸç†**: Androidæ¨¡å—ç³»ç»Ÿæ˜¯åŸºäºGradleçš„å¤šé¡¹ç›®æ„å»ºï¼Œæ¯ç§æ¨¡å—ç±»å‹æœ‰ç‰¹å®šçš„èŒè´£å’Œèƒ½åŠ›è¾¹ç•Œ
> **äº²æ‰‹æ„å»º**: é€šè¿‡ç¼–å†™Gradleæ¨¡å—é…ç½®ç”Ÿæˆå™¨ï¼Œæ·±åº¦ç†è§£å„æ¨¡å—ç±»å‹çš„æŠ€æœ¯å·®å¼‚
> **ä¼ä¸šçº§è¦æ±‚**: æ”¯æŒåŠ¨æ€æ¨¡å—ã€æµ‹è¯•æ¨¡å—ã€åŸºç¡€è®¾æ–½æ¨¡å—ç­‰å¤æ‚åœºæ™¯

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºæ”¯æŒ6ç§Androidæ¨¡å—ç±»å‹çš„ä¼ä¸šçº§é…ç½®ç”Ÿæˆç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - Androidæ¨¡å—é…ç½®ç”Ÿæˆå™¨**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°Androidæ¨¡å—ç±»å‹æšä¸¾
enum class AndroidModuleType(
    val plugin: String,
    val capabilities: Set<ModuleCapability>,
    val restrictions: Set<ModuleRestriction>,
    val resourcesSupported: Boolean
) {
    APPLICATION(
        plugin = "com.android.application",
        capabilities = setOf(MAIN_ACTIVITY, MANIFEST_MERGE, APK_GENERATION),
        restrictions = setOf(SINGLE_PER_PROJECT),
        resourcesSupported = true
    ),
    LIBRARY(
        plugin = "com.android.library", 
        capabilities = setOf(RESOURCE_EXPORT, AAR_GENERATION, CONSUMER_PROGUARD),
        restrictions = setOf(NO_APPLICATION_ID),
        resourcesSupported = true
    ),
    DYNAMIC_FEATURE(
        plugin = "com.android.dynamic-feature",
        capabilities = setOf(ON_DEMAND_LOADING, CONDITIONAL_DELIVERY),
        restrictions = setOf(REQUIRES_BASE_APP),
        resourcesSupported = true
    ),
    TEST(
        plugin = "com.android.test",
        capabilities = setOf(INSTRUMENTATION_TESTS, TEST_APK_GENERATION),
        restrictions = setOf(TEST_ONLY),
        resourcesSupported = false
    ),
    KOTLIN_LIBRARY(
        plugin = "org.jetbrains.kotlin.jvm",
        capabilities = setOf(PURE_KOTLIN, JAR_GENERATION),
        restrictions = setOf(NO_ANDROID_APIS),
        resourcesSupported = false
    ),
    JAVA_LIBRARY(
        plugin = "java-library",
        capabilities = setOf(PURE_JAVA, JAR_GENERATION),
        restrictions = setOf(NO_ANDROID_APIS, NO_KOTLIN),
        resourcesSupported = false
    );
    
    // TODO 2: æ‰‹åŠ¨å®ç°æ¨¡å—èƒ½åŠ›æ£€æŸ¥
    fun canHandle(requirement: ProjectRequirement): Boolean {
        return when (requirement) {
            ProjectRequirement.NEEDS_MAIN_ACTIVITY -> MAIN_ACTIVITY in capabilities
            ProjectRequirement.NEEDS_RESOURCES -> resourcesSupported
            ProjectRequirement.NEEDS_ON_DEMAND -> ON_DEMAND_LOADING in capabilities
            ProjectRequirement.PURE_BUSINESS_LOGIC -> {
                NO_ANDROID_APIS in restrictions || plugin.contains("java")
            }
        }
    }
}

// TODO 3: äº²æ‰‹å®ç°Gradleé…ç½®ç”Ÿæˆå™¨
class GradleBuildGenerator {
    // TODO 4: æ‰‹åŠ¨å®ç°build.gradleç”Ÿæˆ
    fun generateBuildGradle(
        moduleType: AndroidModuleType,
        moduleName: String,
        dependencies: List<ModuleDependency>
    ): String = buildString {
        appendLine("plugins {")
        appendLine("    id '${moduleType.plugin}'")
        
        when (moduleType) {
            AndroidModuleType.APPLICATION, AndroidModuleType.LIBRARY, AndroidModuleType.DYNAMIC_FEATURE -> {
                appendLine("    id 'org.jetbrains.kotlin.android'")
                if (moduleType == AndroidModuleType.DYNAMIC_FEATURE) {
                    appendLine("    id 'kotlin-kapt'")
                }
            }
            AndroidModuleType.KOTLIN_LIBRARY -> {
                appendLine("    id 'org.jetbrains.kotlin.jvm'")
            }
            else -> { /* Java libraryä¸éœ€è¦é¢å¤–æ’ä»¶ */ }
        }
        appendLine("}")
        appendLine()
        
        // TODO 5: æ‰‹åŠ¨å®ç°androidé…ç½®å—
        if (moduleType.resourcesSupported) {
            generateAndroidBlock(moduleType, moduleName)
        }
        
        // TODO 6: æ‰‹åŠ¨å®ç°ä¾èµ–é…ç½®
        generateDependenciesBlock(dependencies, moduleType)
    }
    
    // TODO 7: æ‰‹åŠ¨å®ç°æ¨¡å—éªŒè¯å™¨
    fun validateModuleStructure(
        modules: List<ModuleInfo>
    ): ValidationResult {
        val errors = mutableListOf<String>()
        val appModules = modules.filter { it.type == AndroidModuleType.APPLICATION }
        
        // éªŒè¯åº”ç”¨æ¨¡å—æ•°é‡
        if (appModules.size != 1) {
            errors.add("é¡¹ç›®å¿…é¡»æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªApplicationæ¨¡å—ï¼Œå½“å‰æœ‰${appModules.size}ä¸ª")
        }
        
        // éªŒè¯Dynamic Featureä¾èµ–
        modules.filter { it.type == AndroidModuleType.DYNAMIC_FEATURE }
            .forEach { dynamicModule ->
                val hasAppDependency = dynamicModule.dependencies
                    .any { dep -> modules.find { it.name == dep.name }?.type == AndroidModuleType.APPLICATION }
                if (!hasAppDependency) {
                    errors.add("Dynamic Featureæ¨¡å— ${dynamicModule.name} å¿…é¡»ä¾èµ–Applicationæ¨¡å—")
                }
            }
        
        return ValidationResult(errors.isEmpty(), errors)
    }
}

// TODO 8: äº²æ‰‹å®ç°æ¨¡å—ä¾èµ–åˆ†æå™¨
class ModuleDependencyAnalyzer {
    fun analyzeOptimalStructure(
        features: List<String>,
        sharedComponents: List<String>
    ): ModuleRecommendation {
        val recommendations = mutableListOf<ModuleConfig>()
        
        // åº”ç”¨æ¨¡å—
        recommendations.add(ModuleConfig(
            name = "app",
            type = AndroidModuleType.APPLICATION,
            purpose = "åº”ç”¨å…¥å£ç‚¹ï¼Œé›†æˆæ‰€æœ‰åŠŸèƒ½æ¨¡å—"
        ))
        
        // åŠŸèƒ½æ¨¡å—
        features.forEach { feature ->
            recommendations.add(ModuleConfig(
                name = "feature-$feature",
                type = AndroidModuleType.DYNAMIC_FEATURE,
                purpose = "ç‹¬ç«‹åŠŸèƒ½ï¼š$feature"
            ))
        }
        
        // å…±äº«ç»„ä»¶
        sharedComponents.forEach { component ->
            recommendations.add(ModuleConfig(
                name = "lib-$component",
                type = AndroidModuleType.LIBRARY,
                purpose = "å…±äº«ç»„ä»¶ï¼š$component"
            ))
        }
        
        return ModuleRecommendation(recommendations, calculateBuildTime(recommendations))
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥Androidæ¨¡å—ç±»å‹å®šä¹‰å’Œèƒ½åŠ›æšä¸¾
  2. ğŸ”§ å®ç°Gradleé…ç½®æ–‡ä»¶è‡ªåŠ¨ç”Ÿæˆ
  3. âœ… æ„å»ºæ¨¡å—ç»“æ„éªŒè¯å™¨
  4. ğŸ“Š ç¼–å†™ä¾èµ–åˆ†æå’Œä¼˜åŒ–å»ºè®®ç³»ç»Ÿ
  5. ğŸƒ æµ‹è¯•6ç§æ¨¡å—ç±»å‹çš„é…ç½®ç”Ÿæˆ
- [ ] **æ¨¡å—é…ç½®éªŒè¯**: ç”Ÿæˆçš„build.gradleèƒ½æ­£ç¡®ç¼–è¯‘ï¼Œä¾èµ–æ£€æŸ¥å‡†ç¡®ç‡>95%
- [ ] **Primaryæ£€æŸ¥ç‚¹**: ä½ èƒ½è¯´å‡ºDynamic Featureå’ŒLibraryæ¨¡å—çš„æ ¸å¿ƒåŒºåˆ«å—ï¼Ÿ
- [ ] **æ¨¡å—æ£€æŸ¥**: â–¡ ç±»å‹é€‰æ‹©æ­£ç¡® â–¡ é…ç½®ç”Ÿæˆå®Œæ•´ â–¡ ä¾èµ–éªŒè¯å‡†ç¡® â–¡ æ€§èƒ½åˆ†æåˆç†
- [ ] **æ–‡ä»¶**: `student_progress/modular/gradle_generator/`

#### Task 9.4.3: ä¾èµ–å…³ç³»è®¾è®¡ (5åˆ†é’Ÿ) â° [Intermediate]
> **ä¾èµ–åŸåˆ™**: è‰¯å¥½çš„æ¨¡å—ä¾èµ–å…³ç³»æ˜¯æœ‰å‘æ— ç¯å›¾(DAG)ï¼Œä½“ç°æ¸…æ™°çš„åˆ†å±‚æ¶æ„å’Œç¨³å®šæ€§åŸåˆ™
> **å¯è§†åŒ–æ„å»º**: é€šè¿‡ç¼–ç å®ç°ä¾èµ–å›¾ç”Ÿæˆå’Œåˆ†æï¼ŒåŸ¹å…»æ¶æ„è®¾è®¡çš„ç³»ç»Ÿæ€§æ€ç»´
> **ä¼ä¸šå¤æ‚åº¦**: å¤„ç†300+æ¨¡å—é¡¹ç›®çš„ä¾èµ–å…³ç³»ç®¡ç†å’Œä¼˜åŒ–

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºä¼ä¸šçº§æ¨¡å—ä¾èµ–å…³ç³»ç®¡ç†å’Œå¯è§†åŒ–ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - ä¾èµ–å…³ç³»åˆ†æå¼•æ“**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°ä¾èµ–å…³ç³»æ•°æ®ç»“æ„
data class DependencyRelation(
    val from: String,
    val to: String,
    val type: DependencyType,
    val scope: DependencyScope = DependencyScope.IMPLEMENTATION,
    val optional: Boolean = false,
    val transitiveAllowed: Boolean = true
) {
    // TODO 2: æ‰‹åŠ¨å®ç°ä¾èµ–å¼ºåº¦è®¡ç®—
    fun calculateWeight(): Double = when (type) {
        DependencyType.API -> 1.0          // å¼ºä¾èµ–ï¼šAPIå˜åŒ–å½±å“ä½¿ç”¨è€…
        DependencyType.IMPLEMENTATION -> 0.7  // ä¸­ç­‰ä¾èµ–ï¼šå®ç°ç»†èŠ‚å˜åŒ–
        DependencyType.COMPILE_ONLY -> 0.3    // å¼±ä¾èµ–ï¼šç¼–è¯‘æ—¶ä¾èµ–
        DependencyType.RUNTIME_ONLY -> 0.5    // è¿è¡Œæ—¶ä¾èµ–
        DependencyType.TEST -> 0.2         // æµ‹è¯•ä¾èµ–ï¼šæœ€å¼±
    }
}

// TODO 3: äº²æ‰‹å®ç°åˆ†å±‚æ¶æ„éªŒè¯å™¨
class LayeredArchitectureValidator {
    private val architectureLayers = mapOf(
        "presentation" to 1,    // UIå±‚
        "domain" to 2,         // ä¸šåŠ¡é€»è¾‘å±‚  
        "data" to 3,           // æ•°æ®è®¿é—®å±‚
        "infrastructure" to 4   // åŸºç¡€è®¾æ–½å±‚
    )
    
    // TODO 4: æ‰‹åŠ¨å®ç°åˆ†å±‚ä¾èµ–è§„åˆ™æ£€æŸ¥
    fun validateLayerDependencies(
        dependencies: List<DependencyRelation>,
        moduleLayerMapping: Map<String, String>
    ): LayerValidationResult {
        val violations = mutableListOf<LayerViolation>()
        
        dependencies.forEach { dep ->
            val fromLayer = moduleLayerMapping[dep.from]
            val toLayer = moduleLayerMapping[dep.to]
            
            if (fromLayer != null && toLayer != null) {
                val fromLevel = architectureLayers[fromLayer] ?: 0
                val toLevel = architectureLayers[toLayer] ?: 0
                
                // æ£€æŸ¥åˆ†å±‚è§„åˆ™ï¼šä¸Šå±‚å¯ä»¥ä¾èµ–ä¸‹å±‚ï¼Œä½†ä¸èƒ½åå‘ä¾èµ–
                if (fromLevel > toLevel) {
                    violations.add(LayerViolation(
                        dependency = dep,
                        reason = "ä¸‹å±‚æ¨¡å— $fromLayer ä¸èƒ½ä¾èµ–ä¸Šå±‚æ¨¡å— $toLayer",
                        severity = ViolationSeverity.ERROR
                    ))
                }
                
                // æ£€æŸ¥è·¨å±‚ä¾èµ–ï¼šé¿å…è·¨è¶Šå¤šå±‚çš„ç›´æ¥ä¾èµ–
                if (fromLevel - toLevel > 1) {
                    violations.add(LayerViolation(
                        dependency = dep,
                        reason = "é¿å…è·¨å±‚ä¾èµ–ï¼š$fromLayer åº”é€šè¿‡ä¸­é—´å±‚è®¿é—® $toLayer",
                        severity = ViolationSeverity.WARNING
                    ))
                }
            }
        }
        
        return LayerValidationResult(violations.isEmpty(), violations)
    }
}

// TODO 5: äº²æ‰‹å®ç°ä¾èµ–å›¾å¯è§†åŒ–ç”Ÿæˆå™¨
class DependencyGraphVisualizer {
    // TODO 6: æ‰‹åŠ¨å®ç°DOTæ ¼å¼ç”Ÿæˆ
    fun generateDotGraph(
        modules: List<String>,
        dependencies: List<DependencyRelation>,
        highlightCycles: List<List<String>> = emptyList()
    ): String = buildString {
        appendLine("digraph ModuleDependencies {")
        appendLine("    rankdir=TB;")
        appendLine("    node [shape=box, style=filled];")
        appendLine()
        
        // ç»˜åˆ¶æ¨¡å—èŠ‚ç‚¹
        modules.forEach { module ->
            val color = when {
                highlightCycles.any { cycle -> module in cycle } -> "lightcoral"
                module.startsWith("app") -> "lightblue"
                module.startsWith("feature-") -> "lightgreen"
                module.startsWith("lib-") -> "lightyellow"
                else -> "white"
            }
            appendLine("    \"$module\" [fillcolor=$color];")
        }
        
        appendLine()
        
        // ç»˜åˆ¶ä¾èµ–å…³ç³»
        dependencies.forEach { dep ->
            val edgeStyle = when (dep.type) {
                DependencyType.API -> "[color=red, penwidth=2]"
                DependencyType.IMPLEMENTATION -> "[color=blue]"
                DependencyType.TEST -> "[color=gray, style=dashed]"
                else -> "[color=black]"
            }
            appendLine("    \"${dep.from}\" -> \"${dep.to}\" $edgeStyle;")
        }
        
        appendLine("}")
    }
    
    // TODO 7: æ‰‹åŠ¨å®ç°ä¾èµ–çŸ©é˜µç”Ÿæˆ
    fun generateDependencyMatrix(
        modules: List<String>,
        dependencies: List<DependencyRelation>
    ): DependencyMatrix {
        val matrix = Array(modules.size) { Array(modules.size) { 0 } }
        val moduleIndex = modules.withIndex().associate { it.value to it.index }
        
        dependencies.forEach { dep ->
            val fromIndex = moduleIndex[dep.from]
            val toIndex = moduleIndex[dep.to]
            if (fromIndex != null && toIndex != null) {
                matrix[fromIndex][toIndex] = 1
            }
        }
        
        return DependencyMatrix(modules, matrix)
    }
}

// TODO 8: äº²æ‰‹å®ç°ç¨³å®šæ€§åˆ†æå™¨
class ModuleStabilityAnalyzer {
    // TODO 9: æ‰‹åŠ¨å®ç°ç¨³å®šæ€§æŒ‡æ ‡è®¡ç®—
    fun calculateStabilityMetrics(
        module: String,
        dependencies: List<DependencyRelation>
    ): StabilityMetrics {
        // Ce (å‡ºå‘è€¦åˆ): æ¨¡å—ä¾èµ–çš„å…¶ä»–æ¨¡å—æ•°é‡
        val efferentCoupling = dependencies.count { it.from == module }
        
        // Ca (å…¥å‘è€¦åˆ): ä¾èµ–è¯¥æ¨¡å—çš„å…¶ä»–æ¨¡å—æ•°é‡  
        val afferentCoupling = dependencies.count { it.to == module }
        
        // I (ä¸ç¨³å®šæ€§): Ce / (Ce + Ca)ï¼Œå€¼è¶Šå°è¶Šç¨³å®š
        val instability = if (efferentCoupling + afferentCoupling == 0) 0.0
        else efferentCoupling.toDouble() / (efferentCoupling + afferentCoupling)
        
        // A (æŠ½è±¡æ€§): æŠ½è±¡ç±»/æ¥å£å æ¯” (éœ€è¦é¢å¤–åˆ†æä»£ç ç»“æ„)
        val abstractness = calculateAbstractness(module)
        
        // D (ä¸»åºåˆ—è·ç¦»): |A + I - 1|ï¼Œç†æƒ³å€¼æ¥è¿‘0
        val distanceFromMainSequence = kotlin.math.abs(abstractness + instability - 1)
        
        return StabilityMetrics(
            module = module,
            efferentCoupling = efferentCoupling,
            afferentCoupling = afferentCoupling,
            instability = instability,
            abstractness = abstractness,
            distanceFromMainSequence = distanceFromMainSequence
        )
    }
    
    // TODO 10: æ‰‹åŠ¨å®ç°ä¾èµ–ä¼˜åŒ–å»ºè®®
    fun suggestOptimizations(
        stabilityMetrics: List<StabilityMetrics>
    ): List<OptimizationSuggestion> {
        val suggestions = mutableListOf<OptimizationSuggestion>()
        
        stabilityMetrics.forEach { metrics ->
            when {
                metrics.distanceFromMainSequence > 0.7 -> {
                    suggestions.add(OptimizationSuggestion(
                        module = metrics.module,
                        type = OptimizationType.ARCHITECTURE_VIOLATION,
                        description = "æ¨¡å—ä½äºç—›è‹¦åŒºåŸŸæˆ–æ— ç”¨åŒºåŸŸï¼Œéœ€è¦é‡æ„",
                        priority = Priority.HIGH
                    ))
                }
                metrics.instability > 0.8 && metrics.afferentCoupling > 5 -> {
                    suggestions.add(OptimizationSuggestion(
                        module = metrics.module,
                        type = OptimizationType.TOO_UNSTABLE,
                        description = "æ¨¡å—è¿‡äºä¸ç¨³å®šä½†è¢«å¤§é‡ä¾èµ–ï¼Œè€ƒè™‘æå–ç¨³å®šæ¥å£",
                        priority = Priority.MEDIUM
                    ))
                }
                metrics.efferentCoupling > 10 -> {
                    suggestions.add(OptimizationSuggestion(
                        module = metrics.module,
                        type = OptimizationType.TOO_MANY_DEPENDENCIES,
                        description = "æ¨¡å—ä¾èµ–è¿‡å¤šï¼Œè€ƒè™‘æ‹†åˆ†æˆ–ä½¿ç”¨é—¨é¢æ¨¡å¼",
                        priority = Priority.MEDIUM
                    ))
                }
            }
        }
        
        return suggestions
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥ä¾èµ–å…³ç³»æ•°æ®ç»“æ„å’Œåˆ†å±‚éªŒè¯
  2. ğŸ¨ å®ç°DOTå›¾å½¢åŒ–ç”Ÿæˆå’Œä¾èµ–çŸ©é˜µ
  3. ğŸ“Š æ„å»ºç¨³å®šæ€§åˆ†æå’Œè€¦åˆåº¦è®¡ç®—
  4. ğŸ’¡ ç¼–å†™ä¾èµ–ä¼˜åŒ–å»ºè®®ç®—æ³•
  5. ğŸƒ æµ‹è¯•300ä¸ªæ¨¡å—çš„ä¾èµ–åˆ†ææ€§èƒ½
- [ ] **ä¾èµ–å¤æ‚åº¦éªŒè¯**: å¤„ç†>300æ¨¡å—ï¼Œåˆ†å±‚æ£€æŸ¥<2sï¼Œç¨³å®šæ€§åˆ†æå‡†ç¡®ç‡>90%
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ èƒ½è§£é‡Šä»€ä¹ˆæ˜¯"ä¸»åºåˆ—"ä»¥åŠå¦‚ä½•æµ‹é‡æ¨¡å—ç¨³å®šæ€§å—ï¼Ÿ
- [ ] **ä¾èµ–æ£€æŸ¥**: â–¡ åˆ†å±‚è§„åˆ™æ­£ç¡® â–¡ å¾ªç¯æ£€æµ‹å‡†ç¡® â–¡ å¯è§†åŒ–æ¸…æ™° â–¡ ä¼˜åŒ–å»ºè®®åˆç†
- [ ] **æ–‡ä»¶**: `student_progress/modular/dependency_graph/`

#### Task 9.4.4: æ¥å£æŠ½è±¡è®¾è®¡ (5åˆ†é’Ÿ) â° [Intermediate]
> **æ¥å£è®¾è®¡åŸåˆ™**: ä¾èµ–å€’ç½®åŸåˆ™ - é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½ä¾èµ–äºæŠ½è±¡
> **è§£è€¦ç­–ç•¥**: é€šè¿‡æ¥å£å¥‘çº¦å’ŒæœåŠ¡å®šä½æ¨¡å¼å®ç°æ¨¡å—é—´çš„æ¾æ•£è€¦åˆ
> **ä¼ä¸šçº§å®è·µ**: æ”¯æŒå¤šå›¢é˜Ÿå¹¶è¡Œå¼€å‘å’Œæ¨¡å—ç‹¬ç«‹æ¼”è¿›

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºä¼ä¸šçº§æ¨¡å—æ¥å£æŠ½è±¡å’ŒæœåŠ¡æ³¨å†Œå‘ç°ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - æ¨¡å—æ¥å£ç®¡ç†æ¡†æ¶**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°æ¨¡å—æœåŠ¡æ¥å£æŠ½è±¡
interface ModuleService {
    val moduleName: String
    val version: String
    val dependencies: Set<String>
    
    // TODO 2: æ‰‹åŠ¨å®ç°ç”Ÿå‘½å‘¨æœŸç®¡ç†
    suspend fun initialize(): Result<Unit>
    suspend fun start(): Result<Unit>
    suspend fun stop(): Result<Unit>
    suspend fun destroy(): Result<Unit>
    
    // TODO 3: æ‰‹åŠ¨å®ç°å¥åº·æ£€æŸ¥
    suspend fun healthCheck(): HealthStatus
}

// TODO 4: äº²æ‰‹å®ç°æœåŠ¡æ³¨å†Œä¸­å¿ƒ
class ModuleServiceRegistry {
    private val services = ConcurrentHashMap<String, ModuleServiceInfo>()
    private val serviceInstances = ConcurrentHashMap<String, ModuleService>()
    private val dependencies = ConcurrentHashMap<String, Set<String>>()
    
    // TODO 5: æ‰‹åŠ¨å®ç°æœåŠ¡æ³¨å†Œ
    fun <T : ModuleService> registerService(
        serviceClass: KClass<T>,
        factory: () -> T,
        metadata: ServiceMetadata = ServiceMetadata()
    ): Boolean {
        val serviceName = serviceClass.simpleName ?: return false
        
        val serviceInfo = ModuleServiceInfo(
            name = serviceName,
            type = serviceClass,
            factory = factory,
            metadata = metadata,
            registeredAt = System.currentTimeMillis()
        )
        
        return try {
            services[serviceName] = serviceInfo
            true
        } catch (e: Exception) {
            false
        }
    }
    
    // TODO 6: æ‰‹åŠ¨å®ç°æœåŠ¡å‘ç°
    @Suppress("UNCHECKED_CAST")
    fun <T : ModuleService> getService(
        serviceClass: KClass<T>
    ): T? {
        val serviceName = serviceClass.simpleName ?: return null
        
        return serviceInstances[serviceName] as? T ?: run {
            val serviceInfo = services[serviceName] ?: return null
            val instance = serviceInfo.factory() as? T
            
            if (instance != null) {
                serviceInstances[serviceName] = instance
            }
            instance
        }
    }
    
    // TODO 7: æ‰‹åŠ¨å®ç°ä¾èµ–è§£æ
    fun resolveDependencies(serviceName: String): List<String> {
        val visited = mutableSetOf<String>()
        val resolved = mutableListOf<String>()
        
        fun resolve(name: String) {
            if (name in visited) return
            visited.add(name)
            
            dependencies[name]?.forEach { dependency ->
                resolve(dependency)
            }
            
            resolved.add(name)
        }
        
        resolve(serviceName)
        return resolved
    }
}

// TODO 8: äº²æ‰‹å®ç°æ¨¡å—é—´é€šä¿¡å¥‘çº¦
interface ModuleCommunicationContract {
    // TODO 9: æ‰‹åŠ¨å®ç°äº‹ä»¶æ€»çº¿æ¥å£
    interface EventBus {
        fun <T> publish(event: T, channel: String = "default")
        fun <T> subscribe(
            eventType: KClass<T>,
            channel: String = "default",
            handler: (T) -> Unit
        ): Subscription
        fun unsubscribe(subscription: Subscription)
    }
    
    // TODO 10: æ‰‹åŠ¨å®ç°æ•°æ®å…±äº«æ¥å£
    interface DataStore {
        suspend fun <T> put(key: String, value: T, ttl: Long? = null): Boolean
        suspend fun <T> get(key: String, type: KClass<T>): T?
        suspend fun remove(key: String): Boolean
        suspend fun exists(key: String): Boolean
    }
    
    // TODO 11: æ‰‹åŠ¨å®ç°è·¯ç”±æ¥å£
    interface Router {
        fun registerRoute(pattern: String, handler: RouteHandler)
        fun navigate(uri: String, params: Map<String, Any?> = emptyMap()): Boolean
        fun buildUri(route: String, params: Map<String, Any?> = emptyMap()): String
    }
}

// TODO 12: äº²æ‰‹å®ç°æ¨¡å—æ¥å£ä»£ç†
class ModuleServiceProxy<T : ModuleService>(
    private val serviceClass: KClass<T>,
    private val registry: ModuleServiceRegistry
) : InvocationHandler {
    
    // TODO 13: æ‰‹åŠ¨å®ç°åŠ¨æ€ä»£ç†é€»è¾‘
    override fun invoke(proxy: Any, method: Method, args: Array<out Any?>?): Any? {
        val service = registry.getService(serviceClass)
            ?: throw ServiceNotFoundException("Service ${serviceClass.simpleName} not found")
        
        return try {
            // æ·»åŠ è°ƒç”¨ç›‘æ§å’Œå¼‚å¸¸å¤„ç†
            val startTime = System.currentTimeMillis()
            val result = method.invoke(service, *(args ?: emptyArray()))
            val duration = System.currentTimeMillis() - startTime
            
            // è®°å½•è°ƒç”¨æŒ‡æ ‡
            recordServiceCall(serviceClass.simpleName ?: "unknown", method.name, duration, true)
            
            result
        } catch (e: Exception) {
            recordServiceCall(serviceClass.simpleName ?: "unknown", method.name, 0, false)
            
            when (e.cause) {
                is ServiceUnavailableException -> {
                    // å°è¯•æœåŠ¡é‡å¯æˆ–é™çº§
                    handleServiceFailure(serviceClass, e.cause as ServiceUnavailableException)
                }
                else -> throw e
            }
        }
    }
    
    // TODO 14: æ‰‹åŠ¨å®ç°æœåŠ¡æ•…éšœå¤„ç†
    private fun handleServiceFailure(
        serviceClass: KClass<T>,
        exception: ServiceUnavailableException
    ): Any? {
        // å®ç°æ–­è·¯å™¨æ¨¡å¼
        val circuitBreaker = getCircuitBreaker(serviceClass.simpleName ?: "unknown")
        
        if (circuitBreaker.shouldAttemptReset()) {
            // å°è¯•é‡æ–°åˆå§‹åŒ–æœåŠ¡
            return attemptServiceRecovery(serviceClass)
        } else {
            // æ‰§è¡Œé™çº§é€»è¾‘
            return executeFallback(serviceClass, exception)
        }
    }
}

// TODO 15: äº²æ‰‹å®ç°æ¥å£å¥‘çº¦éªŒè¯å™¨
class ContractValidator {
    // TODO 16: æ‰‹åŠ¨å®ç°æ¥å£å…¼å®¹æ€§æ£€æŸ¥
    fun validateContractCompatibility(
        oldContract: KClass<*>,
        newContract: KClass<*>
    ): CompatibilityResult {
        val oldMethods = oldContract.java.declaredMethods.toSet()
        val newMethods = newContract.java.declaredMethods.toSet()
        
        val removedMethods = oldMethods - newMethods
        val addedMethods = newMethods - oldMethods
        val changedMethods = findChangedMethods(oldMethods, newMethods)
        
        val breakingChanges = removedMethods + changedMethods.filter { it.isBreaking }
        
        return CompatibilityResult(
            isCompatible = breakingChanges.isEmpty(),
            breakingChanges = breakingChanges.map { it.name },
            addedMethods = addedMethods.map { it.name },
            warnings = changedMethods.filter { !it.isBreaking }.map { it.description }
        )
    }
    
    // TODO 17: æ‰‹åŠ¨å®ç°æ–¹æ³•ç­¾åå˜åŒ–æ£€æµ‹
    private fun findChangedMethods(
        oldMethods: Set<Method>,
        newMethods: Set<Method>
    ): List<MethodChange> {
        val changes = mutableListOf<MethodChange>()
        
        oldMethods.forEach { oldMethod ->
            val newMethod = newMethods.find { it.name == oldMethod.name }
            if (newMethod != null) {
                // æ£€æŸ¥è¿”å›ç±»å‹
                if (!newMethod.returnType.isAssignableFrom(oldMethod.returnType)) {
                    changes.add(MethodChange(
                        method = oldMethod.name,
                        description = "è¿”å›ç±»å‹ä» ${oldMethod.returnType.simpleName} å˜ä¸º ${newMethod.returnType.simpleName}",
                        isBreaking = true
                    ))
                }
                
                // æ£€æŸ¥å‚æ•°ç±»å‹
                if (!Arrays.equals(oldMethod.parameterTypes, newMethod.parameterTypes)) {
                    changes.add(MethodChange(
                        method = oldMethod.name,
                        description = "å‚æ•°ç±»å‹å‘ç”Ÿå˜åŒ–",
                        isBreaking = true
                    ))
                }
            }
        }
        
        return changes
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æœåŠ¡æ¥å£å’Œæ³¨å†Œä¸­å¿ƒæ¶æ„
  2. ğŸ”— å®ç°ä¾èµ–è§£æå’ŒæœåŠ¡å‘ç°æœºåˆ¶
  3. ğŸšŒ æ„å»ºäº‹ä»¶æ€»çº¿å’Œæ•°æ®å…±äº«æ¥å£
  4. ğŸ›¡ï¸ ç¼–å†™åŠ¨æ€ä»£ç†å’Œæ•…éšœå¤„ç†
  5. âœ… å®ç°æ¥å£å¥‘çº¦éªŒè¯å’Œå…¼å®¹æ€§æ£€æŸ¥
- [ ] **æ¥å£æŠ½è±¡éªŒè¯**: æ”¯æŒ>50ä¸ªæœåŠ¡ï¼Œä¾èµ–è§£ææ­£ç¡®ç‡100%ï¼ŒæœåŠ¡å‘ç°<10ms
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ èƒ½è¯´å‡ºä¾èµ–å€’ç½®åŸåˆ™å¦‚ä½•è§£å†³æ¨¡å—è€¦åˆé—®é¢˜å—ï¼Ÿ
- [ ] **æ¥å£æ£€æŸ¥**: â–¡ æœåŠ¡æ³¨å†Œå®Œæ•´ â–¡ ä¾èµ–è§£ææ­£ç¡® â–¡ é€šä¿¡å¥‘çº¦æ¸…æ™° â–¡ å¥‘çº¦éªŒè¯å‡†ç¡®
- [ ] **æ–‡ä»¶**: `student_progress/modular/service_registry/`

#### Task 9.4.5: èµ„æºéš”ç¦»ç­–ç•¥ (5åˆ†é’Ÿ) â° [Advanced]
> **èµ„æºéš”ç¦»åŸç†**: é€šè¿‡å‘½åç©ºé—´ã€åŒ…å‰ç¼€ã€èµ„æºIDå‰ç¼€ç­‰æ‰‹æ®µå®ç°æ¨¡å—èµ„æºå®Œå…¨éš”ç¦»
> **å†²çªé¢„é˜²**: ç¼–è¯‘æ—¶æ£€æŸ¥å’Œè¿è¡Œæ—¶éªŒè¯åŒé‡ä¿éšœï¼Œç¡®ä¿ä¼ä¸šçº§é¡¹ç›®çš„èµ„æºå®‰å…¨
> **è‡ªåŠ¨åŒ–ç®¡ç†**: é€šè¿‡å·¥å…·è‡ªåŠ¨ç”Ÿæˆå’ŒéªŒè¯èµ„æºå‘½åè§„èŒƒ

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºä¼ä¸šçº§èµ„æºéš”ç¦»å’Œå†²çªæ£€æµ‹ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - èµ„æºéš”ç¦»ç®¡ç†ç³»ç»Ÿ**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°èµ„æºå‘½åè§„èŒƒå®šä¹‰
data class ResourceNamingRule(
    val modulePrefix: String,
    val resourceType: AndroidResourceType,
    val pattern: Regex,
    val examples: List<String>
) {
    // TODO 2: æ‰‹åŠ¨å®ç°èµ„æºåç§°éªŒè¯
    fun validateResourceName(name: String): ValidationResult {
        val isValid = pattern.matches(name)
        val hasCorrectPrefix = name.startsWith(modulePrefix)
        
        return ValidationResult(
            isValid = isValid && hasCorrectPrefix,
            errors = buildList {
                if (!hasCorrectPrefix) {
                    add("èµ„æºåç§°å¿…é¡»ä»¥æ¨¡å—å‰ç¼€ '$modulePrefix' å¼€å¤´")
                }
                if (!isValid) {
                    add("èµ„æºåç§°ä¸ç¬¦åˆå‘½åè§„èŒƒ: ${pattern.pattern}")
                }
            }
        )
    }
}

// TODO 3: äº²æ‰‹å®ç°Androidèµ„æºç±»å‹æšä¸¾
enum class AndroidResourceType(
    val folderName: String,
    val fileExtensions: Set<String>
) {
    LAYOUT("layout", setOf("xml")),
    DRAWABLE("drawable", setOf("xml", "png", "jpg", "webp", "svg")),
    VALUES("values", setOf("xml")),
    MIPMAP("mipmap", setOf("png", "xml")),
    ANIM("anim", setOf("xml")),
    COLOR("color", setOf("xml")),
    MENU("menu", setOf("xml")),
    RAW("raw", setOf("*")),
    FONT("font", setOf("ttf", "otf", "xml"));
    
    // TODO 4: æ‰‹åŠ¨å®ç°èµ„æºç±»å‹æ£€æµ‹
    fun isValidFile(fileName: String): Boolean {
        val extension = fileName.substringAfterLast(".", "")
        return "*" in fileExtensions || extension.lowercase() in fileExtensions
    }
}

// TODO 5: äº²æ‰‹å®ç°èµ„æºéš”ç¦»é…ç½®ç”Ÿæˆå™¨
class ResourceIsolationConfigGenerator {
    // TODO 6: æ‰‹åŠ¨å®ç°èµ„æºå‰ç¼€è§„åˆ™ç”Ÿæˆ
    fun generateResourcePrefixRules(
        modules: List<ModuleInfo>
    ): Map<String, ResourceNamingRule> {
        val rules = mutableMapOf<String, ResourceNamingRule>()
        
        modules.forEach { module ->
            val prefix = generateModulePrefix(module.name)
            
            AndroidResourceType.values().forEach { resourceType ->
                val rule = when (resourceType) {
                    AndroidResourceType.LAYOUT -> ResourceNamingRule(
                        modulePrefix = "${prefix}_",
                        resourceType = resourceType,
                        pattern = Regex("${prefix}_[a-z][a-z0-9_]*"),
                        examples = listOf("${prefix}_activity_main", "${prefix}_fragment_profile")
                    )
                    AndroidResourceType.DRAWABLE -> ResourceNamingRule(
                        modulePrefix = "${prefix}_",
                        resourceType = resourceType,
                        pattern = Regex("${prefix}_[a-z][a-z0-9_]*"),
                        examples = listOf("${prefix}_ic_star", "${prefix}_bg_gradient")
                    )
                    AndroidResourceType.VALUES -> ResourceNamingRule(
                        modulePrefix = prefix,
                        resourceType = resourceType,
                        pattern = Regex("${prefix}[A-Z][a-zA-Z0-9]*"),
                        examples = listOf("${prefix}ColorPrimary", "${prefix}StringWelcome")
                    )
                    else -> ResourceNamingRule(
                        modulePrefix = "${prefix}_",
                        resourceType = resourceType,
                        pattern = Regex("${prefix}_[a-z][a-z0-9_]*"),
                        examples = listOf("${prefix}_example")
                    )
                }
                
                rules["${module.name}_${resourceType.name}"] = rule
            }
        }
        
        return rules
    }
    
    // TODO 7: æ‰‹åŠ¨å®ç°æ¨¡å—å‰ç¼€ç”Ÿæˆç®—æ³•
    private fun generateModulePrefix(moduleName: String): String {
        // è½¬æ¢æ¨¡å—åä¸ºåˆé€‚çš„å‰ç¼€
        return moduleName
            .replace("-", "_")
            .replace("feature_", "f_")
            .replace("lib_", "l_")
            .take(8) // é™åˆ¶å‰ç¼€é•¿åº¦
            .lowercase()
    }
}

// TODO 8: äº²æ‰‹å®ç°èµ„æºå†²çªæ£€æµ‹å™¨
class ResourceConflictDetector {
    // TODO 9: æ‰‹åŠ¨å®ç°èµ„æºæ‰«æ
    fun scanModuleResources(modulePath: String): List<ResourceInfo> {
        val resources = mutableListOf<ResourceInfo>()
        val resDir = File(modulePath, "src/main/res")
        
        if (!resDir.exists()) return resources
        
        AndroidResourceType.values().forEach { resourceType ->
            val typeDir = File(resDir, resourceType.folderName)
            if (typeDir.exists()) {
                typeDir.listFiles()?.forEach { file ->
                    if (resourceType.isValidFile(file.name)) {
                        resources.add(ResourceInfo(
                            name = file.nameWithoutExtension,
                            type = resourceType,
                            module = modulePath.substringAfterLast("/"),
                            filePath = file.absolutePath
                        ))
                    }
                }
            }
        }
        
        return resources
    }
    
    // TODO 10: æ‰‹åŠ¨å®ç°è·¨æ¨¡å—å†²çªæ£€æµ‹
    fun detectConflicts(
        allResources: List<ResourceInfo>
    ): List<ResourceConflict> {
        val conflicts = mutableListOf<ResourceConflict>()
        val resourcesByName = allResources.groupBy { "${it.type.name}_${it.name}" }
        
        resourcesByName.forEach { (resourceKey, resources) ->
            if (resources.size > 1) {
                // æ£€æŸ¥æ˜¯å¦ä¸ºçœŸæ­£çš„å†²çªï¼ˆæ’é™¤intentional overridesï¼‰
                val modules = resources.map { it.module }.distinct()
                if (modules.size > 1) {
                    conflicts.add(ResourceConflict(
                        resourceName = resources.first().name,
                        resourceType = resources.first().type,
                        conflictingModules = modules,
                        severity = calculateConflictSeverity(resources)
                    ))
                }
            }
        }
        
        return conflicts
    }
    
    // TODO 11: æ‰‹åŠ¨å®ç°å†²çªä¸¥é‡ç¨‹åº¦è¯„ä¼°
    private fun calculateConflictSeverity(resources: List<ResourceInfo>): ConflictSeverity {
        return when {
            resources.any { it.type == AndroidResourceType.VALUES } -> ConflictSeverity.HIGH
            resources.any { it.type == AndroidResourceType.LAYOUT } -> ConflictSeverity.MEDIUM
            else -> ConflictSeverity.LOW
        }
    }
}

// TODO 12: äº²æ‰‹å®ç°èµ„æºå‘½åç©ºé—´éš”ç¦»
class ResourceNamespaceIsolator {
    // TODO 13: æ‰‹åŠ¨å®ç°å‘½åç©ºé—´é…ç½®ç”Ÿæˆ
    fun generateNamespaceConfig(
        modules: List<ModuleInfo>
    ): String = buildString {
        appendLine("// è‡ªåŠ¨ç”Ÿæˆçš„èµ„æºå‘½åç©ºé—´é…ç½®")
        appendLine("android {")
        appendLine("    resourcePrefix '${generateGlobalPrefix()}'")
        appendLine("}")
        appendLine()
        
        modules.forEach { module ->
            appendLine("// ${module.name} æ¨¡å—èµ„æºé…ç½®")
            appendLine("android.libraryVariants.all { variant ->")
            appendLine("    variant.mergeResourcesProvider.configure { task ->")
            appendLine("        task.doFirst {")
            appendLine("            // éªŒè¯ ${module.name} æ¨¡å—èµ„æºå‰ç¼€")
            appendLine("            validateResourcePrefix('${generateModulePrefix(module.name)}')")
            appendLine("        }")
            appendLine("    }")
            appendLine("}")
            appendLine()
        }
    }
    
    // TODO 14: æ‰‹åŠ¨å®ç°è¿è¡Œæ—¶èµ„æºè®¿é—®æ‹¦æˆª
    fun createResourceAccessInterceptor(): ResourceAccessInterceptor {
        return object : ResourceAccessInterceptor {
            override fun interceptGetIdentifier(
                name: String,
                defType: String,
                defPackage: String
            ): Int {
                // éªŒè¯èµ„æºè®¿é—®æ˜¯å¦ç¬¦åˆéš”ç¦»è§„åˆ™
                if (!isAllowedResourceAccess(name, defType, defPackage)) {
                    throw SecurityException(
                        "è·¨æ¨¡å—èµ„æºè®¿é—®è¢«æ‹’ç»: $name ($defType) from $defPackage"
                    )
                }
                
                return super.interceptGetIdentifier(name, defType, defPackage)
            }
            
            override fun interceptGetResourceName(resId: Int): String {
                val resourceName = super.interceptGetResourceName(resId)
                logResourceAccess(resId, resourceName)
                return resourceName
            }
        }
    }
}

// TODO 15: äº²æ‰‹å®ç°èµ„æºéš”ç¦»éªŒè¯å·¥å…·
class ResourceIsolationValidator {
    // TODO 16: æ‰‹åŠ¨å®ç°ç¼–è¯‘æ—¶éªŒè¯
    fun validateAtBuildTime(
        modules: List<ModuleInfo>,
        namingRules: Map<String, ResourceNamingRule>
    ): BuildValidationResult {
        val violations = mutableListOf<ResourceViolation>()
        val conflictDetector = ResourceConflictDetector()
        
        // æ‰«ææ‰€æœ‰æ¨¡å—èµ„æº
        val allResources = modules.flatMap { module ->
            conflictDetector.scanModuleResources(module.path)
        }
        
        // æ£€æŸ¥å‘½åè§„èŒƒè¿è§„
        allResources.forEach { resource ->
            val ruleKey = "${resource.module}_${resource.type.name}"
            val rule = namingRules[ruleKey]
            
            if (rule != null) {
                val validationResult = rule.validateResourceName(resource.name)
                if (!validationResult.isValid) {
                    violations.add(ResourceViolation(
                        resource = resource,
                        rule = rule,
                        errors = validationResult.errors
                    ))
                }
            }
        }
        
        // æ£€æŸ¥èµ„æºå†²çª
        val conflicts = conflictDetector.detectConflicts(allResources)
        
        return BuildValidationResult(
            isValid = violations.isEmpty() && conflicts.isEmpty(),
            violations = violations,
            conflicts = conflicts,
            totalResourcesScanned = allResources.size
        )
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥èµ„æºå‘½åè§„èŒƒå’Œç±»å‹å®šä¹‰
  2. ğŸ” å®ç°èµ„æºæ‰«æå’Œå†²çªæ£€æµ‹ç®—æ³•
  3. ğŸ›¡ï¸ æ„å»ºå‘½åç©ºé—´éš”ç¦»å’Œè®¿é—®æ‹¦æˆª
  4. âœ… ç¼–å†™ç¼–è¯‘æ—¶éªŒè¯å’ŒæŠ¥å‘Šç”Ÿæˆ
  5. ğŸƒ æµ‹è¯•100ä¸ªæ¨¡å—çš„èµ„æºéš”ç¦»æ€§èƒ½
- [ ] **èµ„æºéš”ç¦»éªŒè¯**: å¤„ç†>10000ä¸ªèµ„æºï¼Œå†²çªæ£€æµ‹å‡†ç¡®ç‡100%ï¼ŒéªŒè¯æ—¶é—´<5s
- [ ] **Advancedæ£€æŸ¥ç‚¹**: ä½ èƒ½è¯´å‡ºAndroidèµ„æºå‘½åç©ºé—´éš”ç¦»çš„3ç§å®ç°ç­–ç•¥å—ï¼Ÿ
- [ ] **éš”ç¦»æ£€æŸ¥**: â–¡ å‘½åè§„èŒƒå®Œæ•´ â–¡ å†²çªæ£€æµ‹å‡†ç¡® â–¡ å‘½åç©ºé—´éš”ç¦» â–¡ éªŒè¯å·¥å…·å¯ç”¨
- [ ] **æ–‡ä»¶**: `student_progress/modular/resource_isolation/`

#### Task 9.4.6: æ„å»ºä¼˜åŒ–é…ç½® (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¼˜åŒ–æ¨¡å—åŒ–é¡¹ç›®çš„æ„å»ºæ€§èƒ½
- [ ] **å…·ä½“ä»»åŠ¡**: é…ç½®å¹¶è¡Œæ„å»ºã€å¢é‡ç¼–è¯‘ã€Build Cache
- [ ] **æ£€æŸ¥ç‚¹**: æ˜¾è‘—æå‡æ„å»ºé€Ÿåº¦
- [ ] **æ–‡ä»¶**: å®Œå–„æ¨¡å—åŒ–æœ€ä½³å®è·µ

## Phase 16: ç”µå•†APPæ¨¡å—åŒ–å®æˆ˜ (35åˆ†é’Ÿæ€»è®¡)

#### Task 9.4.7: ç”µå•†ä¸šåŠ¡æ¨¡å—åˆ†æ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: åˆ†æç”µå•†åº”ç”¨çš„ä¸šåŠ¡æ¨¡å—
- [ ] **å…·ä½“ä»»åŠ¡**: è¯†åˆ«ç”¨æˆ·ã€å•†å“ã€è®¢å•ã€æ”¯ä»˜ç­‰æ ¸å¿ƒæ¨¡å—
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åˆç†åˆ’åˆ†ä¸šåŠ¡è¾¹ç•Œ
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/ecommerce_modular_design/module_analysis.md`

#### Task 9.4.8: åŸºç¡€è®¾æ–½æ¨¡å—è®¾è®¡ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡å…¬å…±åŸºç¡€æ¨¡å—
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°networkã€databaseã€commonæ¨¡å—
- [ ] **æ£€æŸ¥ç‚¹**: åŸºç¡€æ¨¡å—åŠŸèƒ½å®Œæ•´ï¼Œæ¥å£æ¸…æ™°
- [ ] **æ–‡ä»¶**: `ecommerce_modular_design/infrastructure/`

#### Task 9.4.9: åŠŸèƒ½æ¨¡å—å®ç° (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°ç‹¬ç«‹çš„åŠŸèƒ½æ¨¡å—
- [ ] **å…·ä½“ä»»åŠ¡**: åˆ›å»ºuserã€productã€orderæ¨¡å—
- [ ] **æ£€æŸ¥ç‚¹**: æ¨¡å—èƒ½ç‹¬ç«‹ç¼–è¯‘å’Œæµ‹è¯•
- [ ] **æ–‡ä»¶**: `ecommerce_modular_design/features/`

#### Task 9.4.10: æ¨¡å—é—´è·¯ç”±è®¾è®¡ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°æ¨¡å—é—´çš„é¡µé¢è·³è½¬
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡åŸºäºURLçš„è·¯ç”±ç³»ç»Ÿ
- [ ] **æ£€æŸ¥ç‚¹**: æ”¯æŒè·¨æ¨¡å—å¯¼èˆªä¸”è§£è€¦
- [ ] **æ–‡ä»¶**: `ecommerce_modular_design/router/`

#### Task 9.4.11: äº‹ä»¶æ€»çº¿å®ç° (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°æ¨¡å—é—´çš„äº‹ä»¶é€šä¿¡
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡å‘å¸ƒ-è®¢é˜…æ¨¡å¼çš„äº‹ä»¶ç³»ç»Ÿ
- [ ] **æ£€æŸ¥ç‚¹**: æ¨¡å—é—´èƒ½å¼‚æ­¥é€šä¿¡ä¸”ä½è€¦åˆ
- [ ] **æ–‡ä»¶**: `ecommerce_modular_design/eventbus/`

#### Task 9.4.12: æ•°æ®å…±äº«æœºåˆ¶ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å¤„ç†æ¨¡å—é—´çš„æ•°æ®å…±äº«
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡ç”¨æˆ·çŠ¶æ€ã€è´­ç‰©è½¦ç­‰å…±äº«æ•°æ®ç®¡ç†
- [ ] **æ£€æŸ¥ç‚¹**: æ•°æ®ä¸€è‡´æ€§å’Œè®¿é—®æƒé™åˆç†
- [ ] **æ–‡ä»¶**: `ecommerce_modular_design/shared_data/`

#### Task 9.4.13: åŠ¨æ€ç‰¹æ€§æ¨¡å— (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°æŒ‰éœ€ä¸‹è½½çš„ç‰¹æ€§æ¨¡å—
- [ ] **å…·ä½“ä»»åŠ¡**: é…ç½®Dynamic Feature Module
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åŠ¨æ€å®‰è£…å’Œå¸è½½åŠŸèƒ½æ¨¡å—
- [ ] **æ–‡ä»¶**: `ecommerce_modular_design/dynamic_features/`

## Phase 17: å›¢é˜Ÿåä½œä¸æ’ä»¶åŒ–æ¶æ„ (25åˆ†é’Ÿæ€»è®¡)

#### Task 9.4.14: å›¢é˜Ÿåˆ†å·¥ç­–ç•¥ (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: åŸºäºæ¨¡å—åŒ–çš„å›¢é˜Ÿåˆ†å·¥
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ¨¡å—è´£ä»»äººåˆ¶åº¦å’Œåä½œæµç¨‹
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å‡å°‘å›¢é˜Ÿé—´çš„å¼€å‘å†²çª
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/team_collaboration/workflow.md`

#### Task 9.4.15: ç‰ˆæœ¬ç®¡ç†ç­–ç•¥ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: ç®¡ç†æ¨¡å—é—´çš„ç‰ˆæœ¬ä¾èµ–
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ¨¡å—ç‰ˆæœ¬å·è§„èŒƒå’Œå…¼å®¹æ€§ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¤„ç†æ¨¡å—ç‰ˆæœ¬å‡çº§å†²çª
- [ ] **æ–‡ä»¶**: `team_collaboration/version_strategy.md`

#### Task 9.4.16: CI/CDæµæ°´çº¿è®¾è®¡ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¸ºæ¨¡å—åŒ–é¡¹ç›®è®¾è®¡CI/CD
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°æ¨¡å—çº§çš„æ„å»ºã€æµ‹è¯•ã€éƒ¨ç½²
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½ç‹¬ç«‹å‘å¸ƒæ¨¡å—æ›´æ–°
- [ ] **æ–‡ä»¶**: `team_collaboration/ci_cd_pipeline.yml`

#### Task 9.4.17: æ’ä»¶åŒ–æ¶æ„è®¾è®¡ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡æ”¯æŒæ’ä»¶çš„æ¶æ„
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°æ’ä»¶åŠ è½½ã€ç”Ÿå‘½å‘¨æœŸç®¡ç†
- [ ] **æ£€æŸ¥ç‚¹**: æ”¯æŒè¿è¡Œæ—¶åŠ¨æ€åŠ è½½åŠŸèƒ½
- [ ] **æ–‡ä»¶**: `team_collaboration/plugin_architecture/`

#### Task 9.4.18: çƒ­æ›´æ–°æœºåˆ¶ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°åº”ç”¨çš„çƒ­æ›´æ–°èƒ½åŠ›
- [ ] **å…·ä½“ä»»åŠ¡**: é›†æˆçƒ­ä¿®å¤æ¡†æ¶ï¼Œè®¾è®¡æ›´æ–°ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æ— ç¼ä¿®å¤çº¿ä¸Šé—®é¢˜
- [ ] **æ–‡ä»¶**: `team_collaboration/hotfix_system/`

## Phase 18: æ”¯ä»˜å®çº§è¶…çº§APPæ¶æ„ (20åˆ†é’Ÿæ€»è®¡)

#### Task 9.4.19: è¶…çº§APPæ¶æ„åˆ†æ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: åˆ†æè¶…çº§APPçš„æ¶æ„ç‰¹ç‚¹
- [ ] **å…·ä½“ä»»åŠ¡**: ç ”ç©¶æ”¯ä»˜å®ã€å¾®ä¿¡çš„æ¨¡å—åŒ–ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: ç†è§£å¤æ‚åº¦ç®¡ç†çš„æ ¸å¿ƒæ€è·¯
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/super_app_design/architecture_analysis.md`

#### Task 9.4.20: å°ç¨‹åºå®¹å™¨è®¾è®¡ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡å°ç¨‹åºè¿è¡Œå®¹å™¨
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°JSå¼•æ“ã€APIæ¡¥æ¥ã€æƒé™æ§åˆ¶
- [ ] **æ£€æŸ¥ç‚¹**: æ”¯æŒç¬¬ä¸‰æ–¹å°ç¨‹åºå®‰å…¨è¿è¡Œ
- [ ] **æ–‡ä»¶**: `super_app_design/miniapp_container/`

#### Task 9.4.21: èµ„æºéš”ç¦»ä¸å®‰å…¨ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: ç¡®ä¿æ¨¡å—é—´çš„å®‰å…¨éš”ç¦»
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ²™ç®±æœºåˆ¶ã€æƒé™æ§åˆ¶ã€æ•°æ®éš”ç¦»
- [ ] **æ£€æŸ¥ç‚¹**: å„æ¨¡å—ä¸èƒ½äº’ç›¸å¹²æ‰°
- [ ] **æ–‡ä»¶**: `super_app_design/security_isolation/`

#### Task 9.4.22: æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å»ºç«‹è¶…çº§APPçš„æ€§èƒ½ç›‘æ§
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ¨¡å—çº§æ€§èƒ½æŒ‡æ ‡å’Œä¼˜åŒ–ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¿«é€Ÿå®šä½æ€§èƒ½ç“¶é¢ˆ
- [ ] **æ–‡ä»¶**: `super_app_design/performance_monitoring/`

## Phase 19: é¢è¯•å®æˆ˜ä¸æ¶æ„æ€ç»´ (20åˆ†é’Ÿæ€»è®¡)

#### Task 9.4.23: æ¨¡å—åŒ–è®¾è®¡åŸåˆ™ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: æ€»ç»“æ¨¡å—åŒ–è®¾è®¡çš„æ ¸å¿ƒåŸåˆ™
- [ ] **å…·ä½“ä»»åŠ¡**: æ•´ç†é«˜å†…èšä½è€¦åˆã€å•ä¸€èŒè´£ç­‰åŸåˆ™
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æŒ‡å¯¼å®é™…çš„æ¨¡å—åˆ’åˆ†
- [ ] **æ–‡ä»¶**: åœ¨`chapter9_interview_qa.md`ä¸­æ·»åŠ æ¨¡å—åŒ–éƒ¨åˆ†

#### Task 9.4.24: å¤æ‚åº¦ç®¡ç†ç­–ç•¥ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å±•ç¤ºå¤æ‚ç³»ç»Ÿçš„ç®¡ç†èƒ½åŠ›
- [ ] **å…·ä½“ä»»åŠ¡**: åˆ†æå¦‚ä½•æ§åˆ¶å¤§å‹é¡¹ç›®çš„æŠ€æœ¯å€ºåŠ¡
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¹³è¡¡åŠŸèƒ½éœ€æ±‚å’ŒæŠ€æœ¯è´¨é‡
- [ ] **æ–‡ä»¶**: æ·»åŠ å¤æ‚åº¦ç®¡ç†ç»éªŒ

#### Task 9.4.25: æ¶æ„æ¼”è¿›è·¯å¾„ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è§„åˆ’æ¶æ„çš„å¹³æ»‘æ¼”è¿›
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡ä»å•ä½“åˆ°æ¨¡å—åŒ–çš„è¿ç§»ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åœ¨ä¸å½±å“ä¸šåŠ¡çš„å‰æä¸‹é‡æ„æ¶æ„
- [ ] **æ–‡ä»¶**: æ·»åŠ æ¶æ„è¿ç§»ç­–ç•¥

#### Task 9.4.26: æŠ€æœ¯é€‰å‹å†³ç­– (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å±•ç¤ºæŠ€æœ¯å†³ç­–çš„æ€è€ƒè¿‡ç¨‹
- [ ] **å…·ä½“ä»»åŠ¡**: åˆ†ææ¨¡å—åŒ–æŠ€æœ¯é€‰å‹çš„æƒè¡¡å› ç´ 
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åšå‡ºåˆç†çš„æŠ€æœ¯é€‰æ‹©å¹¶æ‰¿æ‹…è´£ä»»
- [ ] **æ–‡ä»¶**: å®Œæˆæ¨¡å—åŒ–æ¶æ„è®¾è®¡æ€»ç»“

---

# ğŸš€ 9.5 æ€§èƒ½ä¸æ‰©å±•æ€§ï¼šè´Ÿè½½å‡è¡¡ + CDNä¼˜åŒ–

## Phase 20: æ€§èƒ½ä¼˜åŒ–ç†è®ºåŸºç¡€ (25åˆ†é’Ÿæ€»è®¡)

#### Task 9.5.1: æ€§èƒ½ç“¶é¢ˆè¯†åˆ« (5åˆ†é’Ÿ) â° [Intermediate]
> **æ€§èƒ½åˆ†æå“²å­¦**: æ€§èƒ½ä¼˜åŒ–çš„æœ¬è´¨æ˜¯èµ„æºé…ç½®çš„æœ€ä¼˜åŒ–ï¼Œé€šè¿‡é‡åŒ–åˆ†ææ‰¾åˆ°çœŸæ­£çš„ç“¶é¢ˆç‚¹
> **ç³»ç»ŸåŒ–è¯Šæ–­**: æ„å»ºå®Œæ•´çš„æ€§èƒ½ç›‘æ§å’Œåˆ†æå·¥å…·é“¾ï¼Œå®ç°ä»å®è§‚åˆ°å¾®è§‚çš„å…¨æ–¹ä½æ€§èƒ½é€è§†
> **ä¼ä¸šçº§è¦æ±‚**: æ”¯æŒç™¾ä¸‡çº§ç”¨æˆ·çš„æ€§èƒ½ç›‘æ§ï¼Œæ¯«ç§’çº§ç“¶é¢ˆå®šä½ï¼Œè‡ªåŠ¨åŒ–æ€§èƒ½å›å½’æ£€æµ‹

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºä¼ä¸šçº§æ€§èƒ½ç“¶é¢ˆè¯†åˆ«å’Œåˆ†æç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - æ€§èƒ½ç“¶é¢ˆè¯Šæ–­å¼•æ“**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°æ€§èƒ½æŒ‡æ ‡æ•°æ®ç»“æ„
data class PerformanceMetrics(
    val timestamp: Long = System.currentTimeMillis(),
    val cpuUsage: CpuMetrics,
    val memoryUsage: MemoryMetrics,
    val networkUsage: NetworkMetrics,
    val storageUsage: StorageMetrics,
    val batteryUsage: BatteryMetrics,
    val userExperience: UXMetrics
) {
    // TODO 2: æ‰‹åŠ¨å®ç°ç»¼åˆæ€§èƒ½è¯„åˆ†
    fun calculatePerformanceScore(): PerformanceScore {
        val cpuScore = cpuUsage.calculateScore()
        val memoryScore = memoryUsage.calculateScore()
        val networkScore = networkUsage.calculateScore()
        val storageScore = storageUsage.calculateScore()
        val batteryScore = batteryUsage.calculateScore()
        val uxScore = userExperience.calculateScore()
        
        val weightedScore = (cpuScore * 0.2 + memoryScore * 0.25 + 
                           networkScore * 0.15 + storageScore * 0.1 + 
                           batteryScore * 0.1 + uxScore * 0.2)
        
        return PerformanceScore(
            overall = weightedScore,
            breakdown = mapOf(
                "CPU" to cpuScore,
                "Memory" to memoryScore,
                "Network" to networkScore,
                "Storage" to storageScore,
                "Battery" to batteryScore,
                "UX" to uxScore
            ),
            bottlenecks = identifyBottlenecks()
        )
    }
}

// TODO 3: äº²æ‰‹å®ç°CPUæ€§èƒ½ç›‘æ§
class CpuPerformanceMonitor {
    private val cpuHistory = CircularBuffer<CpuSnapshot>(capacity = 1000)
    
    // TODO 4: æ‰‹åŠ¨å®ç°CPUä½¿ç”¨ç‡ç›‘æ§
    fun monitorCpuUsage(): CpuMetrics {
        val processCpuTime = getProcessCpuTime()
        val systemCpuTime = getSystemCpuTime()
        val threadCount = Thread.activeCount()
        
        val currentSnapshot = CpuSnapshot(
            processCpuPercent = calculateCpuPercent(processCpuTime),
            systemCpuPercent = calculateSystemCpuPercent(systemCpuTime),
            threadCount = threadCount,
            timestamp = System.currentTimeMillis()
        )
        
        cpuHistory.add(currentSnapshot)
        
        return CpuMetrics(
            current = currentSnapshot,
            average5Min = calculateAverage(5 * 60 * 1000),
            peak24Hour = findPeak(24 * 60 * 60 * 1000),
            isBottleneck = detectCpuBottleneck(currentSnapshot)
        )
    }
    
    // TODO 5: æ‰‹åŠ¨å®ç°CPUç“¶é¢ˆæ£€æµ‹
    private fun detectCpuBottleneck(snapshot: CpuSnapshot): Boolean {
        return snapshot.processCpuPercent > 80.0 || 
               snapshot.systemCpuPercent > 90.0 ||
               snapshot.threadCount > 50
    }
}

// TODO 6: äº²æ‰‹å®ç°å†…å­˜æ€§èƒ½åˆ†æå™¨
class MemoryPerformanceAnalyzer {
    // TODO 7: æ‰‹åŠ¨å®ç°å†…å­˜æ³„æ¼æ£€æµ‹
    fun detectMemoryLeaks(): List<MemoryLeak> {
        val heapDump = captureHeapDump()
        val suspiciousObjects = findSuspiciousObjects(heapDump)
        val leaks = mutableListOf<MemoryLeak>()
        
        suspiciousObjects.forEach { obj ->
            val retainedSize = calculateRetainedSize(obj)
            val gcRoots = findGcRoots(obj)
            
            if (isLikelyLeak(obj, retainedSize, gcRoots)) {
                leaks.add(MemoryLeak(
                    objectClass = obj.className,
                    retainedSize = retainedSize,
                    instanceCount = countInstances(obj.className),
                    leakPath = tracePath(obj, gcRoots),
                    severity = calculateLeakSeverity(retainedSize)
                ))
            }
        }
        
        return leaks.sortedByDescending { it.retainedSize }
    }
    
    // TODO 8: æ‰‹åŠ¨å®ç°å†…å­˜ä½¿ç”¨æ¨¡å¼åˆ†æ
    fun analyzeMemoryPatterns(): MemoryPatternAnalysis {
        val allocations = trackAllocations(duration = 60_000) // 1åˆ†é’Ÿ
        val patterns = mutableMapOf<String, AllocationPattern>()
        
        allocations.groupBy { it.className }.forEach { (className, allocs) ->
            val pattern = AllocationPattern(
                className = className,
                totalSize = allocs.sumOf { it.size },
                frequency = allocs.size,
                avgObjectSize = allocs.map { it.size }.average(),
                peakAllocationRate = findPeakAllocationRate(allocs),
                isProblematic = isProblematicPattern(allocs)
            )
            patterns[className] = pattern
        }
        
        return MemoryPatternAnalysis(
            patterns = patterns,
            recommendations = generateMemoryRecommendations(patterns)
        )
    }
}

// TODO 9: äº²æ‰‹å®ç°ç½‘ç»œæ€§èƒ½è¯Šæ–­å™¨
class NetworkPerformanceDiagnostic {
    // TODO 10: æ‰‹åŠ¨å®ç°ç½‘ç»œå»¶è¿Ÿåˆ†æ
    suspend fun measureNetworkLatency(endpoints: List<String>): NetworkLatencyReport {
        val measurements = mutableMapOf<String, LatencyMeasurement>()
        
        endpoints.forEach { endpoint ->
            val samples = (1..10).map { 
                measureSingleRequest(endpoint)
            }
            
            measurements[endpoint] = LatencyMeasurement(
                endpoint = endpoint,
                samples = samples,
                min = samples.minOrNull() ?: 0,
                max = samples.maxOrNull() ?: 0,
                avg = samples.average(),
                p95 = calculatePercentile(samples, 95.0),
                p99 = calculatePercentile(samples, 99.0),
                jitter = calculateJitter(samples),
                packetLoss = measurePacketLoss(endpoint)
            )
        }
        
        return NetworkLatencyReport(
            measurements = measurements,
            overallHealth = assessNetworkHealth(measurements),
            recommendations = generateNetworkOptimizations(measurements)
        )
    }
    
    // TODO 11: æ‰‹åŠ¨å®ç°å¸¦å®½åˆ©ç”¨ç‡åˆ†æ
    fun analyzeBandwidthUtilization(): BandwidthAnalysis {
        val traffic = monitorNetworkTraffic(duration = 30_000) // 30ç§’
        
        return BandwidthAnalysis(
            totalUpload = traffic.sumOf { it.uploadBytes },
            totalDownload = traffic.sumOf { it.downloadBytes },
            peakUploadRate = traffic.maxOfOrNull { it.uploadRate } ?: 0,
            peakDownloadRate = traffic.maxOfOrNull { it.downloadRate } ?: 0,
            averageUploadRate = traffic.map { it.uploadRate }.average(),
            averageDownloadRate = traffic.map { it.downloadRate }.average(),
            protocolBreakdown = analyzeProtocolUsage(traffic),
            inefficiencies = detectBandwidthInefficiencies(traffic)
        )
    }
}

// TODO 12: äº²æ‰‹å®ç°å­˜å‚¨æ€§èƒ½ç›‘æ§å™¨
class StoragePerformanceMonitor {
    // TODO 13: æ‰‹åŠ¨å®ç°I/Oæ€§èƒ½æµ‹è¯•
    suspend fun measureIOPerformance(): IOPerformanceReport {
        val sequentialRead = measureSequentialRead()
        val sequentialWrite = measureSequentialWrite()
        val randomRead = measureRandomRead()
        val randomWrite = measureRandomWrite()
        
        return IOPerformanceReport(
            sequentialReadMBps = sequentialRead,
            sequentialWriteMBps = sequentialWrite,
            randomReadIOPS = randomRead,
            randomWriteIOPS = randomWrite,
            storageHealth = assessStorageHealth(),
            recommendations = generateStorageOptimizations()
        )
    }
    
    // TODO 14: æ‰‹åŠ¨å®ç°å­˜å‚¨ç©ºé—´åˆ†æ
    fun analyzeStorageUsage(): StorageUsageAnalysis {
        val internalStorage = analyzeInternalStorage()
        val externalStorage = analyzeExternalStorage()
        val cacheUsage = analyzeCacheUsage()
        
        return StorageUsageAnalysis(
            internal = internalStorage,
            external = externalStorage,
            cache = cacheUsage,
            projectedUsage = projectStorageGrowth(),
            cleanupOpportunities = identifyCleanupOpportunities()
        )
    }
}

// TODO 15: äº²æ‰‹å®ç°æ€§èƒ½ç“¶é¢ˆè¯†åˆ«å¼•æ“
class PerformanceBottleneckEngine {
    // TODO 16: æ‰‹åŠ¨å®ç°æ™ºèƒ½ç“¶é¢ˆæ£€æµ‹
    fun identifyBottlenecks(metrics: PerformanceMetrics): BottleneckAnalysis {
        val detectors = listOf(
            CpuBottleneckDetector(),
            MemoryBottleneckDetector(),
            NetworkBottleneckDetector(),
            StorageBottleneckDetector(),
            BatteryBottleneckDetector(),
            UXBottleneckDetector()
        )
        
        val bottlenecks = detectors.mapNotNull { detector ->
            detector.analyze(metrics)
        }.sortedByDescending { it.severity }
        
        val rootCause = analyzeRootCause(bottlenecks)
        val recommendations = generateOptimizationPlan(bottlenecks)
        
        return BottleneckAnalysis(
            bottlenecks = bottlenecks,
            rootCause = rootCause,
            optimizationPlan = recommendations,
            estimatedImpact = estimateOptimizationImpact(recommendations)
        )
    }
    
    // TODO 17: æ‰‹åŠ¨å®ç°æ€§èƒ½å›å½’æ£€æµ‹
    fun detectPerformanceRegression(
        currentMetrics: PerformanceMetrics,
        baselineMetrics: PerformanceMetrics
    ): RegressionAnalysis {
        val regressions = mutableListOf<PerformanceRegression>()
        
        // æ£€æŸ¥å„é¡¹æŒ‡æ ‡çš„å›å½’
        if (isSignificantRegression(currentMetrics.cpuUsage, baselineMetrics.cpuUsage)) {
            regressions.add(PerformanceRegression(
                metric = "CPU Usage",
                currentValue = currentMetrics.cpuUsage.current.processCpuPercent,
                baselineValue = baselineMetrics.cpuUsage.current.processCpuPercent,
                regressionPercent = calculateRegressionPercent(
                    currentMetrics.cpuUsage.current.processCpuPercent,
                    baselineMetrics.cpuUsage.current.processCpuPercent
                ),
                severity = RegressionSeverity.HIGH
            ))
        }
        
        return RegressionAnalysis(
            hasRegression = regressions.isNotEmpty(),
            regressions = regressions,
            overallImpact = calculateOverallImpact(regressions),
            suggestedActions = generateRegressionActions(regressions)
        )
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æ€§èƒ½æŒ‡æ ‡æ•°æ®ç»“æ„å’Œç›‘æ§æ¡†æ¶
  2. ğŸ” å®ç°CPUã€å†…å­˜ã€ç½‘ç»œã€å­˜å‚¨æ€§èƒ½åˆ†æå™¨
  3. ğŸ§  æ„å»ºæ™ºèƒ½ç“¶é¢ˆæ£€æµ‹å’Œæ ¹å› åˆ†æå¼•æ“
  4. ğŸ“Š ç¼–å†™æ€§èƒ½å›å½’æ£€æµ‹å’Œä¼˜åŒ–å»ºè®®ç³»ç»Ÿ
  5. ğŸƒ æµ‹è¯•ç™¾ä¸‡ç”¨æˆ·çº§åˆ«çš„æ€§èƒ½ç›‘æ§èƒ½åŠ›
- [ ] **æ€§èƒ½è¯Šæ–­éªŒè¯**: æ”¯æŒ>100ä¸‡ç”¨æˆ·ç›‘æ§ï¼Œç“¶é¢ˆå®šä½<1sï¼Œå›å½’æ£€æµ‹å‡†ç¡®ç‡>95%
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ èƒ½è¯´å‡ºç§»åŠ¨ç«¯æ€§èƒ½ç“¶é¢ˆçš„4ä¸ªä¸»è¦ç±»å‹å’Œå¯¹åº”çš„æ£€æµ‹æ–¹æ³•å—ï¼Ÿ
- [ ] **æ€§èƒ½æ£€æŸ¥**: â–¡ æŒ‡æ ‡ç›‘æ§å®Œæ•´ â–¡ ç“¶é¢ˆæ£€æµ‹å‡†ç¡® â–¡ æ ¹å› åˆ†ææ·±å…¥ â–¡ ä¼˜åŒ–å»ºè®®å®ç”¨
- [ ] **æ–‡ä»¶**: `student_progress/performance/bottleneck_engine/`

#### Task 9.5.2: ç§»åŠ¨ç«¯æ€§èƒ½ç‰¹ç‚¹ (5åˆ†é’Ÿ) â° [Intermediate]
> **ç§»åŠ¨ç«¯çº¦æŸ**: ç§»åŠ¨è®¾å¤‡çš„ç”µæ± ã€ç½‘ç»œã€è®¡ç®—ã€å­˜å‚¨èµ„æºéƒ½æœ‰ä¸¥æ ¼é™åˆ¶ï¼Œéœ€è¦ä¸“é—¨çš„ä¼˜åŒ–ç­–ç•¥
> **èƒ½è€—ä¼˜å…ˆ**: ç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒæ˜¯èƒ½è€—æ•ˆç‡ï¼Œä¸æ˜¯ç»å¯¹æ€§èƒ½
> **ç”¨æˆ·ä½“éªŒå¯¼å‘**: ç§»åŠ¨ç«¯æ€§èƒ½ç›´æ¥å½±å“ç”¨æˆ·ç•™å­˜ï¼Œéœ€è¦ä»ç”¨æˆ·è§†è§’è®¾è®¡æ€§èƒ½æŒ‡æ ‡

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºç§»åŠ¨ç«¯ä¸“ç”¨æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - ç§»åŠ¨ç«¯æ€§èƒ½ç‰¹å¾åˆ†æå™¨**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°ç§»åŠ¨ç«¯æ€§èƒ½çº¦æŸæ¨¡å‹
data class MobilePerformanceConstraints(
    val battery: BatteryConstraints,
    val thermal: ThermalConstraints,
    val network: NetworkConstraints,
    val memory: MemoryConstraints,
    val storage: StorageConstraints,
    val userExperience: UXConstraints
) {
    // TODO 2: æ‰‹åŠ¨å®ç°çº¦æŸè¯„ä¼°
    fun evaluateConstraints(): ConstraintAssessment {
        val batteryScore = battery.assessCurrentState()
        val thermalScore = thermal.assessCurrentState()
        val networkScore = network.assessCurrentState()
        val memoryScore = memory.assessCurrentState()
        val storageScore = storage.assessCurrentState()
        val uxScore = userExperience.assessCurrentState()
        
        return ConstraintAssessment(
            overallConstraintLevel = calculateOverallConstraint(
                batteryScore, thermalScore, networkScore, memoryScore, storageScore, uxScore
            ),
            criticalConstraints = identifyCriticalConstraints(),
            optimizationPriorities = calculateOptimizationPriorities()
        )
    }
}

// TODO 3: äº²æ‰‹å®ç°ç”µæ± æ€§èƒ½ç›‘æ§å™¨
class BatteryPerformanceMonitor {
    private val batteryHistory = CircularBuffer<BatterySnapshot>(capacity = 1440) // 24å°æ—¶ï¼Œæ¯åˆ†é’Ÿä¸€ä¸ª
    
    // TODO 4: æ‰‹åŠ¨å®ç°ç”µæ± æ¶ˆè€—åˆ†æ
    fun analyzeBatteryConsumption(): BatteryAnalysis {
        val currentLevel = getCurrentBatteryLevel()
        val chargingState = getChargingState()
        val temperature = getBatteryTemperature()
        val voltage = getBatteryVoltage()
        
        val snapshot = BatterySnapshot(
            level = currentLevel,
            isCharging = chargingState.isCharging,
            temperature = temperature,
            voltage = voltage,
            timestamp = System.currentTimeMillis()
        )
        
        batteryHistory.add(snapshot)
        
        return BatteryAnalysis(
            currentSnapshot = snapshot,
            drainRate = calculateDrainRate(),
            estimatedTimeRemaining = estimateTimeRemaining(),
            powerHungryComponents = identifyPowerHungryComponents(),
            optimizationSuggestions = generateBatteryOptimizations()
        )
    }
    
    // TODO 5: æ‰‹åŠ¨å®ç°åº”ç”¨çº§ç”µé‡åˆ†æ
    fun analyzeAppPowerUsage(): AppPowerAnalysis {
        val cpuPower = estimateCpuPowerUsage()
        val screenPower = estimateScreenPowerUsage()
        val networkPower = estimateNetworkPowerUsage()
        val gpsLocationPower = estimateLocationPowerUsage()
        val cameraPower = estimateCameraPowerUsage()
        
        return AppPowerAnalysis(
            totalEstimatedUsage = cpuPower + screenPower + networkPower + gpsLocationPower + cameraPower,
            breakdown = mapOf(
                "CPU" to cpuPower,
                "Screen" to screenPower,
                "Network" to networkPower,
                "Location" to gpsLocationPower,
                "Camera" to cameraPower
            ),
            powerEfficiencyScore = calculatePowerEfficiency(),
            recommendations = generatePowerOptimizations()
        )
    }
}

// TODO 6: äº²æ‰‹å®ç°çƒ­ç®¡ç†ç›‘æ§å™¨
class ThermalManagementMonitor {
    // TODO 7: æ‰‹åŠ¨å®ç°æ¸©åº¦ç›‘æ§
    fun monitorThermalState(): ThermalState {
        val cpuTemp = getCpuTemperature()
        val batteryTemp = getBatteryTemperature()
        val ambientTemp = getAmbientTemperature()
        val thermalThrottling = getThermalThrottlingState()
        
        val thermalState = ThermalState(
            cpuTemperature = cpuTemp,
            batteryTemperature = batteryTemp,
            ambientTemperature = ambientTemp,
            isThrottling = thermalThrottling.isActive,
            throttlingLevel = thermalThrottling.level,
            sustainablePerformanceMode = checkSustainablePerformanceMode()
        )
        
        return thermalState
    }
    
    // TODO 8: æ‰‹åŠ¨å®ç°çƒ­ä¼˜åŒ–ç­–ç•¥
    fun generateThermalOptimizations(thermalState: ThermalState): List<ThermalOptimization> {
        val optimizations = mutableListOf<ThermalOptimization>()
        
        if (thermalState.cpuTemperature > 70.0) {
            optimizations.add(ThermalOptimization(
                type = OptimizationType.CPU_FREQUENCY_SCALING,
                description = "é™ä½CPUé¢‘ç‡ä»¥å‡å°‘å‘çƒ­",
                expectedImpact = "æ¸©åº¦é™ä½5-10Â°Cï¼Œæ€§èƒ½é™ä½15-25%",
                priority = Priority.HIGH
            ))
        }
        
        if (thermalState.isThrottling) {
            optimizations.add(ThermalOptimization(
                type = OptimizationType.BACKGROUND_TASK_REDUCTION,
                description = "æš‚åœéå…³é”®åå°ä»»åŠ¡",
                expectedImpact = "å‡å°‘CPUè´Ÿè½½ï¼Œç¼“è§£çƒ­èŠ‚æµ",
                priority = Priority.CRITICAL
            ))
        }
        
        return optimizations
    }
}

// TODO 9: äº²æ‰‹å®ç°ç§»åŠ¨ç½‘ç»œæ€§èƒ½é€‚é…å™¨
class MobileNetworkPerformanceAdapter {
    // TODO 10: æ‰‹åŠ¨å®ç°ç½‘ç»œç±»å‹æ£€æµ‹å’Œé€‚é…
    fun adaptToNetworkConditions(): NetworkAdaptation {
        val networkType = getCurrentNetworkType()
        val signalStrength = getSignalStrength()
        val latency = measureCurrentLatency()
        val bandwidth = measureCurrentBandwidth()
        
        val networkCondition = NetworkCondition(
            type = networkType,
            signalStrength = signalStrength,
            latency = latency,
            bandwidth = bandwidth,
            isMetered = isMeteredConnection()
        )
        
        return NetworkAdaptation(
            condition = networkCondition,
            recommendedStrategy = selectOptimalStrategy(networkCondition),
            adaptations = generateNetworkAdaptations(networkCondition)
        )
    }
    
    // TODO 11: æ‰‹åŠ¨å®ç°å¼±ç½‘ç¯å¢ƒä¼˜åŒ–
    private fun generateNetworkAdaptations(condition: NetworkCondition): List<NetworkOptimization> {
        val adaptations = mutableListOf<NetworkOptimization>()
        
        when (condition.type) {
            NetworkType.WIFI -> {
                if (condition.latency > 100) {
                    adaptations.add(NetworkOptimization(
                        type = "REQUEST_BATCHING",
                        description = "æ‰¹é‡åˆå¹¶ç½‘ç»œè¯·æ±‚",
                        expectedBenefit = "å‡å°‘è¯·æ±‚å»¶è¿Ÿå½±å“"
                    ))
                }
            }
            NetworkType.CELLULAR_4G -> {
                adaptations.add(NetworkOptimization(
                    type = "CONTENT_COMPRESSION",
                    description = "å¯ç”¨å†…å®¹å‹ç¼©",
                    expectedBenefit = "èŠ‚çœæµé‡ï¼Œæé«˜åŠ è½½é€Ÿåº¦"
                ))
            }
            NetworkType.CELLULAR_3G, NetworkType.CELLULAR_2G -> {
                adaptations.add(NetworkOptimization(
                    type = "LOW_QUALITY_MODE",
                    description = "åˆ‡æ¢åˆ°ä½è´¨é‡æ¨¡å¼",
                    expectedBenefit = "ç¡®ä¿åŸºæœ¬åŠŸèƒ½å¯ç”¨"
                ))
            }
        }
        
        return adaptations
    }
}

// TODO 12: äº²æ‰‹å®ç°å†…å­˜å‹åŠ›ç®¡ç†å™¨
class MobileMemoryPressureManager {
    // TODO 13: æ‰‹åŠ¨å®ç°å†…å­˜å‹åŠ›æ£€æµ‹
    fun detectMemoryPressure(): MemoryPressureState {
        val availableMemory = getAvailableMemory()
        val totalMemory = getTotalMemory()
        val lowMemoryThreshold = totalMemory * 0.1 // 10%
        val criticalMemoryThreshold = totalMemory * 0.05 // 5%
        
        val pressureLevel = when {
            availableMemory < criticalMemoryThreshold -> MemoryPressureLevel.CRITICAL
            availableMemory < lowMemoryThreshold -> MemoryPressureLevel.HIGH
            availableMemory < totalMemory * 0.2 -> MemoryPressureLevel.MODERATE
            else -> MemoryPressureLevel.NORMAL
        }
        
        return MemoryPressureState(
            level = pressureLevel,
            availableMemory = availableMemory,
            totalMemory = totalMemory,
            utilizationPercent = ((totalMemory - availableMemory) / totalMemory.toDouble()) * 100,
            recommendations = generateMemoryPressureActions(pressureLevel)
        )
    }
    
    // TODO 14: æ‰‹åŠ¨å®ç°å†…å­˜é‡Šæ”¾ç­–ç•¥
    private fun generateMemoryPressureActions(level: MemoryPressureLevel): List<MemoryAction> {
        return when (level) {
            MemoryPressureLevel.CRITICAL -> listOf(
                MemoryAction("CLEAR_IMAGE_CACHE", "æ¸…ç©ºå›¾ç‰‡ç¼“å­˜", Priority.CRITICAL),
                MemoryAction("STOP_BACKGROUND_SERVICES", "åœæ­¢åå°æœåŠ¡", Priority.CRITICAL),
                MemoryAction("FORCE_GC", "å¼ºåˆ¶åƒåœ¾å›æ”¶", Priority.HIGH)
            )
            MemoryPressureLevel.HIGH -> listOf(
                MemoryAction("TRIM_CACHE", "æ¸…ç†ç¼“å­˜", Priority.HIGH),
                MemoryAction("RELEASE_NON_ESSENTIAL", "é‡Šæ”¾éå¿…è¦èµ„æº", Priority.MEDIUM)
            )
            MemoryPressureLevel.MODERATE -> listOf(
                MemoryAction("LAZY_CLEANUP", "å»¶è¿Ÿæ¸…ç†", Priority.LOW)
            )
            MemoryPressureLevel.NORMAL -> emptyList()
        }
    }
}

// TODO 15: äº²æ‰‹å®ç°ç§»åŠ¨ç«¯UXæ€§èƒ½ç›‘æ§å™¨
class MobileUXPerformanceMonitor {
    // TODO 16: æ‰‹åŠ¨å®ç°ç”¨æˆ·æ„ŸçŸ¥æ€§èƒ½æµ‹é‡
    fun measurePerceivedPerformance(): PerceivedPerformanceMetrics {
        val appStartTime = measureAppStartTime()
        val firstContentfulPaint = measureFirstContentfulPaint()
        val timeToInteractive = measureTimeToInteractive()
        val frameDropRate = measureFrameDropRate()
        val touchResponseTime = measureTouchResponseTime()
        
        return PerceivedPerformanceMetrics(
            appStartTime = appStartTime,
            firstContentfulPaint = firstContentfulPaint,
            timeToInteractive = timeToInteractive,
            frameDropRate = frameDropRate,
            touchResponseTime = touchResponseTime,
            overallUXScore = calculateUXScore(
                appStartTime, firstContentfulPaint, timeToInteractive, 
                frameDropRate, touchResponseTime
            ),
            userSatisfactionLevel = estimateUserSatisfaction()
        )
    }
    
    // TODO 17: æ‰‹åŠ¨å®ç°UXæ€§èƒ½ä¼˜åŒ–å»ºè®®
    fun generateUXOptimizations(metrics: PerceivedPerformanceMetrics): List<UXOptimization> {
        val optimizations = mutableListOf<UXOptimization>()
        
        if (metrics.appStartTime > 3000) { // 3ç§’
            optimizations.add(UXOptimization(
                area = "App Startup",
                issue = "å¯åŠ¨æ—¶é—´è¿‡é•¿",
                solution = "å®ç°å¯åŠ¨é¡µé¢„åŠ è½½å’Œå»¶è¿Ÿåˆå§‹åŒ–",
                expectedImprovement = "å¯åŠ¨æ—¶é—´å‡å°‘30-50%"
            ))
        }
        
        if (metrics.frameDropRate > 0.05) { // 5%
            optimizations.add(UXOptimization(
                area = "UI Smoothness",
                issue = "å¸§ç‡ä¸ç¨³å®š",
                solution = "ä¼˜åŒ–UIæ¸²æŸ“å’Œå‡å°‘ä¸»çº¿ç¨‹å·¥ä½œ",
                expectedImprovement = "å¸§ç‡æå‡åˆ°60fpsç¨³å®š"
            ))
        }
        
        return optimizations
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥ç§»åŠ¨ç«¯çº¦æŸæ¨¡å‹å’Œç›‘æ§æ¡†æ¶
  2. ğŸ”‹ å®ç°ç”µæ± ã€çƒ­ç®¡ç†ã€å†…å­˜å‹åŠ›ç›‘æ§å™¨
  3. ğŸ“± æ„å»ºç½‘ç»œé€‚é…å’ŒUXæ€§èƒ½ç›‘æ§ç³»ç»Ÿ
  4. ğŸ¯ ç¼–å†™ç§»åŠ¨ç«¯ä¸“ç”¨ä¼˜åŒ–ç­–ç•¥ç”Ÿæˆå™¨
  5. ğŸƒ æµ‹è¯•å„ç§ç§»åŠ¨è®¾å¤‡çš„æ€§èƒ½é€‚é…èƒ½åŠ›
- [ ] **ç§»åŠ¨ç«¯ç‰¹å¾éªŒè¯**: æ”¯æŒ>20ç§è®¾å¤‡å‹å·ï¼Œçº¦æŸæ£€æµ‹å‡†ç¡®ç‡>90%ï¼Œä¼˜åŒ–å»ºè®®å®ç”¨æ€§>85%
- [ ] **Intermediateæ£€æŸ¥ç‚¹**: ä½ èƒ½è¯´å‡ºç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–ä¸æ¡Œé¢ç«¯çš„3ä¸ªæ ¸å¿ƒå·®å¼‚å—ï¼Ÿ
- [ ] **ç§»åŠ¨ç«¯æ£€æŸ¥**: â–¡ çº¦æŸå»ºæ¨¡å®Œæ•´ â–¡ ç”µé‡ç›‘æ§å‡†ç¡® â–¡ ç½‘ç»œé€‚é…æ™ºèƒ½ â–¡ UXæŒ‡æ ‡åˆç†
- [ ] **æ–‡ä»¶**: `student_progress/performance/mobile_adapter/`

#### Task 9.5.3: è´Ÿè½½å‡è¡¡åŸç† (5åˆ†é’Ÿ) â° [Advanced]
> **è´Ÿè½½å‡è¡¡æ ¸å¿ƒ**: é€šè¿‡æ™ºèƒ½åˆ†å‘è¯·æ±‚å®ç°ç³»ç»Ÿå®¹é‡æœ€å¤§åŒ–å’Œæ•…éšœå®¹é”™ï¼Œæ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºçŸ³
> **ç®—æ³•é€‰æ‹©**: ä¸åŒè´Ÿè½½å‡è¡¡ç®—æ³•é€‚ç”¨äºä¸åŒåœºæ™¯ï¼Œéœ€è¦æ ¹æ®ä¸šåŠ¡ç‰¹ç‚¹å’ŒæœåŠ¡ç‰¹æ€§ç²¾ç¡®é€‰æ‹©
> **åŠ¨æ€é€‚åº”**: ç°ä»£è´Ÿè½½å‡è¡¡éœ€è¦å®æ—¶æ„ŸçŸ¥æœåŠ¡çŠ¶æ€ï¼ŒåŠ¨æ€è°ƒæ•´åˆ†å‘ç­–ç•¥

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºæ™ºèƒ½è´Ÿè½½å‡è¡¡ç®—æ³•å¼•æ“å’Œæ€§èƒ½ä¼˜åŒ–ç³»ç»Ÿ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - æ™ºèƒ½è´Ÿè½½å‡è¡¡å™¨**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°æœåŠ¡èŠ‚ç‚¹æ¨¡å‹
data class ServiceNode(
    val id: String,
    val address: String,
    val port: Int,
    val weight: Int = 1,
    val maxConnections: Int = 1000,
    val currentConnections: Int = 0,
    val responseTime: Long = 0,
    val healthStatus: HealthStatus = HealthStatus.HEALTHY,
    val cpuUsage: Double = 0.0,
    val memoryUsage: Double = 0.0,
    val lastHealthCheck: Long = System.currentTimeMillis()
) {
    // TODO 2: æ‰‹åŠ¨å®ç°èŠ‚ç‚¹è´Ÿè½½è¯„ä¼°
    fun calculateLoadScore(): Double {
        val connectionLoad = currentConnections.toDouble() / maxConnections
        val responseTimeLoad = responseTime / 1000.0 // æ ‡å‡†åŒ–åˆ°ç§’
        val resourceLoad = (cpuUsage + memoryUsage) / 2.0
        
        return (connectionLoad * 0.4 + responseTimeLoad * 0.3 + resourceLoad * 0.3)
    }
    
    // TODO 3: æ‰‹åŠ¨å®ç°èŠ‚ç‚¹å¯ç”¨æ€§æ£€æŸ¥
    fun isAvailable(): Boolean {
        return healthStatus == HealthStatus.HEALTHY && 
               currentConnections < maxConnections &&
               System.currentTimeMillis() - lastHealthCheck < 30_000 // 30ç§’å†…æœ‰å¥åº·æ£€æŸ¥
    }
}

// TODO 4: äº²æ‰‹å®ç°è´Ÿè½½å‡è¡¡ç®—æ³•æ¥å£
interface LoadBalanceAlgorithm {
    fun selectNode(nodes: List<ServiceNode>, request: Request? = null): ServiceNode?
    fun updateNodeMetrics(nodeId: String, metrics: NodeMetrics)
    fun getName(): String
}

// TODO 5: äº²æ‰‹å®ç°è½®è¯¢è´Ÿè½½å‡è¡¡
class RoundRobinLoadBalancer : LoadBalanceAlgorithm {
    private var currentIndex = AtomicInteger(0)
    
    override fun selectNode(nodes: List<ServiceNode>, request: Request?): ServiceNode? {
        val availableNodes = nodes.filter { it.isAvailable() }
        if (availableNodes.isEmpty()) return null
        
        val index = currentIndex.getAndIncrement() % availableNodes.size
        return availableNodes[index]
    }
    
    override fun updateNodeMetrics(nodeId: String, metrics: NodeMetrics) {
        // è½®è¯¢ç®—æ³•ä¸éœ€è¦ç‰¹æ®Šçš„æŒ‡æ ‡æ›´æ–°
    }
    
    override fun getName() = "RoundRobin"
}

// TODO 6: äº²æ‰‹å®ç°åŠ æƒè½®è¯¢è´Ÿè½½å‡è¡¡
class WeightedRoundRobinLoadBalancer : LoadBalanceAlgorithm {
    private val nodeWeights = ConcurrentHashMap<String, Int>()
    private val currentWeights = ConcurrentHashMap<String, Int>()
    
    override fun selectNode(nodes: List<ServiceNode>, request: Request?): ServiceNode? {
        val availableNodes = nodes.filter { it.isAvailable() }
        if (availableNodes.isEmpty()) return null
        
        // åˆå§‹åŒ–æƒé‡
        availableNodes.forEach { node ->
            nodeWeights.putIfAbsent(node.id, node.weight)
            currentWeights.putIfAbsent(node.id, 0)
        }
        
        // æ‰¾åˆ°å½“å‰æƒé‡æœ€é«˜çš„èŠ‚ç‚¹
        var selectedNode: ServiceNode? = null
        var maxCurrentWeight = Int.MIN_VALUE
        var totalWeight = 0
        
        availableNodes.forEach { node ->
            currentWeights[node.id] = currentWeights[node.id]!! + nodeWeights[node.id]!!
            totalWeight += nodeWeights[node.id]!!
            
            if (currentWeights[node.id]!! > maxCurrentWeight) {
                maxCurrentWeight = currentWeights[node.id]!!
                selectedNode = node
            }
        }
        
        // å‡å»æ€»æƒé‡
        selectedNode?.let { node ->
            currentWeights[node.id] = currentWeights[node.id]!! - totalWeight
        }
        
        return selectedNode
    }
    
    override fun updateNodeMetrics(nodeId: String, metrics: NodeMetrics) {
        // å¯ä»¥æ ¹æ®æ€§èƒ½æŒ‡æ ‡åŠ¨æ€è°ƒæ•´æƒé‡
        val performanceScore = calculatePerformanceScore(metrics)
        val adjustedWeight = (nodeWeights[nodeId] ?: 1) * performanceScore
        nodeWeights[nodeId] = adjustedWeight.toInt().coerceIn(1, 10)
    }
    
    override fun getName() = "WeightedRoundRobin"
}

// TODO 7: äº²æ‰‹å®ç°æœ€å°‘è¿æ¥è´Ÿè½½å‡è¡¡
class LeastConnectionsLoadBalancer : LoadBalanceAlgorithm {
    override fun selectNode(nodes: List<ServiceNode>, request: Request?): ServiceNode? {
        val availableNodes = nodes.filter { it.isAvailable() }
        if (availableNodes.isEmpty()) return null
        
        return availableNodes.minByOrNull { node ->
            // è€ƒè™‘è¿æ¥æ•°å’Œæƒé‡çš„ç»¼åˆè¯„åˆ†
            node.currentConnections.toDouble() / node.weight
        }
    }
    
    override fun updateNodeMetrics(nodeId: String, metrics: NodeMetrics) {
        // æœ€å°‘è¿æ¥ç®—æ³•ä¾èµ–å®æ—¶è¿æ¥æ•°ï¼Œåœ¨è¯·æ±‚å¤„ç†æ—¶æ›´æ–°
    }
    
    override fun getName() = "LeastConnections"
}

// TODO 8: äº²æ‰‹å®ç°å“åº”æ—¶é—´è´Ÿè½½å‡è¡¡
class ResponseTimeLoadBalancer : LoadBalanceAlgorithm {
    private val responseTimeHistory = ConcurrentHashMap<String, CircularBuffer<Long>>()
    
    override fun selectNode(nodes: List<ServiceNode>, request: Request?): ServiceNode? {
        val availableNodes = nodes.filter { it.isAvailable() }
        if (availableNodes.isEmpty()) return null
        
        return availableNodes.minByOrNull { node ->
            calculateAverageResponseTime(node.id)
        }
    }
    
    override fun updateNodeMetrics(nodeId: String, metrics: NodeMetrics) {
        val history = responseTimeHistory.getOrPut(nodeId) { 
            CircularBuffer<Long>(capacity = 100) 
        }
        history.add(metrics.responseTime)
    }
    
    private fun calculateAverageResponseTime(nodeId: String): Long {
        val history = responseTimeHistory[nodeId] ?: return Long.MAX_VALUE
        return if (history.isEmpty()) Long.MAX_VALUE else history.average().toLong()
    }
    
    override fun getName() = "ResponseTime"
}

// TODO 9: äº²æ‰‹å®ç°ä¸€è‡´æ€§å“ˆå¸Œè´Ÿè½½å‡è¡¡
class ConsistentHashLoadBalancer : LoadBalanceAlgorithm {
    private val virtualNodes = 150 // æ¯ä¸ªç‰©ç†èŠ‚ç‚¹çš„è™šæ‹ŸèŠ‚ç‚¹æ•°
    private val ring = TreeMap<Long, ServiceNode>()
    
    // TODO 10: æ‰‹åŠ¨å®ç°å“ˆå¸Œç¯æ„å»º
    private fun buildHashRing(nodes: List<ServiceNode>) {
        ring.clear()
        nodes.filter { it.isAvailable() }.forEach { node ->
            repeat(virtualNodes) { i ->
                val hash = calculateHash("${node.id}:$i")
                ring[hash] = node
            }
        }
    }
    
    override fun selectNode(nodes: List<ServiceNode>, request: Request?): ServiceNode? {
        buildHashRing(nodes)
        if (ring.isEmpty()) return null
        
        val requestHash = request?.let { calculateHash(it.getRoutingKey()) } 
            ?: Random.nextLong()
        
        // åœ¨ç¯ä¸Šæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºè¯·æ±‚å“ˆå¸Œçš„èŠ‚ç‚¹
        val entry = ring.ceilingEntry(requestHash) ?: ring.firstEntry()
        return entry?.value
    }
    
    override fun updateNodeMetrics(nodeId: String, metrics: NodeMetrics) {
        // ä¸€è‡´æ€§å“ˆå¸Œä¸»è¦ç”¨äºä¼šè¯ä¿æŒï¼Œä¸éœ€è¦ç‰¹æ®Šçš„æŒ‡æ ‡æ›´æ–°
    }
    
    private fun calculateHash(key: String): Long {
        return key.hashCode().toLong() and 0x7FFFFFFFL
    }
    
    override fun getName() = "ConsistentHash"
}

// TODO 11: äº²æ‰‹å®ç°æ™ºèƒ½è´Ÿè½½å‡è¡¡å™¨
class IntelligentLoadBalancer : LoadBalanceAlgorithm {
    private val algorithms = mapOf(
        "round_robin" to RoundRobinLoadBalancer(),
        "weighted_round_robin" to WeightedRoundRobinLoadBalancer(),
        "least_connections" to LeastConnectionsLoadBalancer(),
        "response_time" to ResponseTimeLoadBalancer(),
        "consistent_hash" to ConsistentHashLoadBalancer()
    )
    
    private var currentAlgorithm = "weighted_round_robin"
    private val performanceMetrics = ConcurrentHashMap<String, AlgorithmPerformance>()
    
    // TODO 12: æ‰‹åŠ¨å®ç°ç®—æ³•æ€§èƒ½è¯„ä¼°
    override fun selectNode(nodes: List<ServiceNode>, request: Request?): ServiceNode? {
        val algorithm = algorithms[currentAlgorithm] ?: algorithms["round_robin"]!!
        val startTime = System.currentTimeMillis()
        
        val selectedNode = algorithm.selectNode(nodes, request)
        
        val executionTime = System.currentTimeMillis() - startTime
        updateAlgorithmPerformance(currentAlgorithm, executionTime, selectedNode != null)
        
        // å®šæœŸè¯„ä¼°æ˜¯å¦éœ€è¦åˆ‡æ¢ç®—æ³•
        if (shouldSwitchAlgorithm()) {
            currentAlgorithm = selectOptimalAlgorithm(nodes, request)
        }
        
        return selectedNode
    }
    
    // TODO 13: æ‰‹åŠ¨å®ç°ç®—æ³•è‡ªé€‚åº”é€‰æ‹©
    private fun selectOptimalAlgorithm(nodes: List<ServiceNode>, request: Request?): String {
        val nodeCount = nodes.size
        val connectionVariance = calculateConnectionVariance(nodes)
        val responseTimeVariance = calculateResponseTimeVariance(nodes)
        
        return when {
            // èŠ‚ç‚¹æ€§èƒ½å·®å¼‚å¤§ï¼Œä½¿ç”¨åŠ æƒè½®è¯¢
            responseTimeVariance > 100 -> "weighted_round_robin"
            
            // è¿æ¥æ•°å·®å¼‚å¤§ï¼Œä½¿ç”¨æœ€å°‘è¿æ¥
            connectionVariance > 0.3 -> "least_connections"
            
            // éœ€è¦ä¼šè¯ä¿æŒï¼Œä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œ
            request?.needsSessionAffinity() == true -> "consistent_hash"
            
            // è¿½æ±‚æœ€ä½å»¶è¿Ÿï¼Œä½¿ç”¨å“åº”æ—¶é—´ç®—æ³•
            request?.isLatencyCritical() == true -> "response_time"
            
            // é»˜è®¤ä½¿ç”¨è½®è¯¢
            else -> "round_robin"
        }
    }
    
    // TODO 14: æ‰‹åŠ¨å®ç°è´Ÿè½½å‡è¡¡æ€§èƒ½ç›‘æ§
    override fun updateNodeMetrics(nodeId: String, metrics: NodeMetrics) {
        algorithms.values.forEach { algorithm ->
            algorithm.updateNodeMetrics(nodeId, metrics)
        }
    }
    
    private fun shouldSwitchAlgorithm(): Boolean {
        val currentPerf = performanceMetrics[currentAlgorithm] ?: return false
        return currentPerf.successRate < 0.95 || currentPerf.averageResponseTime > 1000
    }
    
    override fun getName() = "Intelligent($currentAlgorithm)"
}

// TODO 15: äº²æ‰‹å®ç°è´Ÿè½½å‡è¡¡å™¨ç®¡ç†å™¨
class LoadBalancerManager {
    private val healthChecker = HealthChecker()
    private val metricsCollector = MetricsCollector()
    private val loadBalancer = IntelligentLoadBalancer()
    
    // TODO 16: æ‰‹åŠ¨å®ç°è¯·æ±‚åˆ†å‘
    suspend fun distributeRequest(request: Request): LoadBalanceResult {
        val nodes = getAvailableNodes()
        val selectedNode = loadBalancer.selectNode(nodes, request)
        
        return if (selectedNode != null) {
            val startTime = System.currentTimeMillis()
            
            try {
                val response = forwardRequest(selectedNode, request)
                val responseTime = System.currentTimeMillis() - startTime
                
                // æ›´æ–°èŠ‚ç‚¹æŒ‡æ ‡
                updateNodeMetrics(selectedNode.id, responseTime, true)
                
                LoadBalanceResult.Success(selectedNode, response, responseTime)
            } catch (e: Exception) {
                updateNodeMetrics(selectedNode.id, System.currentTimeMillis() - startTime, false)
                LoadBalanceResult.Failure(selectedNode, e)
            }
        } else {
            LoadBalanceResult.NoAvailableNodes
        }
    }
    
    // TODO 17: æ‰‹åŠ¨å®ç°å¥åº·æ£€æŸ¥ç®¡ç†
    private fun updateNodeMetrics(nodeId: String, responseTime: Long, success: Boolean) {
        val metrics = NodeMetrics(
            responseTime = responseTime,
            success = success,
            timestamp = System.currentTimeMillis()
        )
        
        loadBalancer.updateNodeMetrics(nodeId, metrics)
        metricsCollector.recordMetrics(nodeId, metrics)
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥æœåŠ¡èŠ‚ç‚¹æ¨¡å‹å’Œè´Ÿè½½å‡è¡¡æ¥å£
  2. âš–ï¸ å®ç°5ç§ç»å…¸è´Ÿè½½å‡è¡¡ç®—æ³•ï¼ˆè½®è¯¢ã€åŠ æƒã€æœ€å°‘è¿æ¥ã€å“åº”æ—¶é—´ã€ä¸€è‡´æ€§å“ˆå¸Œï¼‰
  3. ğŸ§  æ„å»ºæ™ºèƒ½è´Ÿè½½å‡è¡¡å™¨å’Œè‡ªé€‚åº”ç®—æ³•é€‰æ‹©
  4. ğŸ“Š ç¼–å†™æ€§èƒ½ç›‘æ§å’Œå¥åº·æ£€æŸ¥ç³»ç»Ÿ
  5. ğŸƒ æµ‹è¯•ç™¾ä¸‡çº§è¯·æ±‚çš„è´Ÿè½½å‡è¡¡æ€§èƒ½
- [ ] **è´Ÿè½½å‡è¡¡éªŒè¯**: æ”¯æŒ>100ä¸‡RPSï¼ŒèŠ‚ç‚¹æ•…éšœåˆ‡æ¢<100msï¼Œç®—æ³•é€‰æ‹©å‡†ç¡®ç‡>90%
- [ ] **Advancedæ£€æŸ¥ç‚¹**: ä½ èƒ½è¯´å‡ºä»€ä¹ˆåœºæ™¯ä¸‹åº”è¯¥é€‰æ‹©ä¸€è‡´æ€§å“ˆå¸Œè€Œä¸æ˜¯è½®è¯¢ç®—æ³•å—ï¼Ÿ
- [ ] **å‡è¡¡æ£€æŸ¥**: â–¡ ç®—æ³•å®ç°æ­£ç¡® â–¡ æ™ºèƒ½é€‰æ‹©åˆç† â–¡ æ€§èƒ½ç›‘æ§å®Œæ•´ â–¡ æ•…éšœå¤„ç†åŠæ—¶
- [ ] **æ–‡ä»¶**: `student_progress/performance/load_balancer/`

#### Task 9.5.4: CDNå·¥ä½œåŸç† (5åˆ†é’Ÿ) â° [Advanced]
> **CDNæ ¸å¿ƒåŸç†**: é€šè¿‡åœ°ç†åˆ†å¸ƒçš„è¾¹ç¼˜èŠ‚ç‚¹å’Œæ™ºèƒ½ç¼“å­˜ç­–ç•¥ï¼Œå°†å†…å®¹æ¨é€åˆ°ç¦»ç”¨æˆ·æœ€è¿‘çš„ä½ç½®
> **ç¼“å­˜å±‚æ¬¡**: å¤šçº§ç¼“å­˜ä½“ç³»ä»æµè§ˆå™¨åˆ°è¾¹ç¼˜èŠ‚ç‚¹åˆ°æºç«™ï¼Œæ¯ä¸€å±‚éƒ½æœ‰ä¸åŒçš„ç¼“å­˜ç­–ç•¥å’ŒTTL
> **æ™ºèƒ½è°ƒåº¦**: åŸºäºç”¨æˆ·åœ°ç†ä½ç½®ã€ç½‘ç»œçŠ¶å†µã€èŠ‚ç‚¹è´Ÿè½½çš„æ™ºèƒ½è°ƒåº¦ç®—æ³•

- [ ] **å®æˆ˜ç›®æ ‡**: æ„å»ºä¼ä¸šçº§CDNç³»ç»Ÿå’Œæ™ºèƒ½å†…å®¹åˆ†å‘ç½‘ç»œ
- [ ] **ğŸ’» å¿…é¡»æ‰‹åŠ¨ç¼–ç¨‹ - CDNæ™ºèƒ½åˆ†å‘ç³»ç»Ÿ**:
```kotlin
// TODO 1: äº²æ‰‹å®ç°CDNè¾¹ç¼˜èŠ‚ç‚¹æ¨¡å‹
data class EdgeNode(
    val nodeId: String,
    val region: String,
    val location: GeoLocation,
    val capacity: NodeCapacity,
    val currentLoad: NodeLoad,
    val cacheStatus: CacheStatus,
    val networkQuality: NetworkQuality,
    val lastHeartbeat: Long = System.currentTimeMillis()
) {
    // TODO 2: æ‰‹åŠ¨å®ç°èŠ‚ç‚¹è´¨é‡è¯„åˆ†
    fun calculateQualityScore(userLocation: GeoLocation): Double {
        val distanceScore = calculateDistanceScore(location, userLocation)
        val loadScore = 1.0 - (currentLoad.cpuUsage + currentLoad.memoryUsage) / 2.0
        val networkScore = networkQuality.overallScore
        val cacheScore = cacheStatus.hitRate
        
        return (distanceScore * 0.3 + loadScore * 0.25 + 
                networkScore * 0.25 + cacheScore * 0.2)
    }
    
    // TODO 3: æ‰‹åŠ¨å®ç°èŠ‚ç‚¹å¯ç”¨æ€§æ£€æŸ¥
    fun isAvailable(): Boolean {
        val isHealthy = System.currentTimeMillis() - lastHeartbeat < 30_000
        val hasCapacity = currentLoad.cpuUsage < 90.0 && currentLoad.memoryUsage < 90.0
        val networkOk = networkQuality.latency < 200 && networkQuality.bandwidth > 10_000
        
        return isHealthy && hasCapacity && networkOk
    }
}

// TODO 4: äº²æ‰‹å®ç°CDNç¼“å­˜ç­–ç•¥ç®¡ç†å™¨
class CDNCacheStrategyManager {
    private val cacheRules = mutableMapOf<String, CacheRule>()
    private val contentTypes = mutableMapOf<String, ContentTypeConfig>()
    
    // TODO 5: æ‰‹åŠ¨å®ç°ç¼“å­˜è§„åˆ™å¼•æ“
    fun getCacheStrategy(request: CDNRequest): CacheStrategy {
        val contentType = detectContentType(request.path)
        val fileExtension = request.path.substringAfterLast(".", "")
        val userRegion = request.userLocation.region
        
        val rule = cacheRules[request.path] 
            ?: contentTypes[contentType]?.defaultRule
            ?: getDefaultCacheRule(fileExtension)
        
        return CacheStrategy(
            ttl = calculateOptimalTTL(rule, contentType, userRegion),
            cacheLevel = determineCacheLevel(contentType, request.priority),
            compressionEnabled = shouldCompress(contentType, request.userAgent),
            edgeCacheable = isEdgeCacheable(contentType, request.size),
            originPullStrategy = getOriginPullStrategy(contentType)
        )
    }
    
    // TODO 6: æ‰‹åŠ¨å®ç°åŠ¨æ€TTLè®¡ç®—
    private fun calculateOptimalTTL(
        rule: CacheRule,
        contentType: String,
        userRegion: String
    ): Long {
        val baseTTL = rule.baseTTL
        
        // æ ¹æ®å†…å®¹ç±»å‹è°ƒæ•´
        val typeMultiplier = when (contentType) {
            "image" -> 2.0      // å›¾ç‰‡ç¼“å­˜æ—¶é—´æ›´é•¿
            "video" -> 1.5      // è§†é¢‘é€‚ä¸­
            "api" -> 0.1        // APIå“åº”ç¼“å­˜æ—¶é—´å¾ˆçŸ­
            "static" -> 3.0     // é™æ€èµ„æºæœ€é•¿
            else -> 1.0
        }
        
        // æ ¹æ®åœ°åŒºè°ƒæ•´ï¼ˆè¿œç¦»æºç«™çš„åœ°åŒºç¼“å­˜æ—¶é—´æ›´é•¿ï¼‰
        val regionMultiplier = calculateRegionMultiplier(userRegion)
        
        return (baseTTL * typeMultiplier * regionMultiplier).toLong()
    }
}

// TODO 7: äº²æ‰‹å®ç°CDNæ™ºèƒ½è°ƒåº¦å™¨
class CDNIntelligentScheduler {
    private val edgeNodes = ConcurrentHashMap<String, EdgeNode>()
    private val userLocationCache = LRUCache<String, GeoLocation>(10000)
    private val performanceMetrics = ConcurrentHashMap<String, NodePerformanceHistory>()
    
    // TODO 8: æ‰‹åŠ¨å®ç°æœ€ä¼˜èŠ‚ç‚¹é€‰æ‹©
    fun selectOptimalNode(request: CDNRequest): NodeSelectionResult {
        val userLocation = getUserLocation(request.clientIP)
        val candidateNodes = findCandidateNodes(userLocation, request.contentType)
        
        if (candidateNodes.isEmpty()) {
            return NodeSelectionResult.NoAvailableNodes
        }
        
        val scoredNodes = candidateNodes.map { node ->
            ScoredNode(
                node = node,
                score = calculateNodeScore(node, userLocation, request),
                estimatedLatency = estimateLatency(node, userLocation),
                cacheHitProbability = estimateCacheHit(node, request)
            )
        }.sortedByDescending { it.score }
        
        val primaryNode = scoredNodes.first().node
        val fallbackNodes = scoredNodes.drop(1).take(2).map { it.node }
        
        return NodeSelectionResult.Success(
            primaryNode = primaryNode,
            fallbackNodes = fallbackNodes,
            selectionReason = generateSelectionReason(scoredNodes.first())
        )
    }
    
    // TODO 9: æ‰‹åŠ¨å®ç°åœ°ç†ä½ç½®æ™ºèƒ½åŒ¹é…
    private fun findCandidateNodes(
        userLocation: GeoLocation,
        contentType: String
    ): List<EdgeNode> {
        val maxDistance = getMaxDistanceForContentType(contentType)
        
        return edgeNodes.values.filter { node ->
            node.isAvailable() &&
            calculateDistance(userLocation, node.location) <= maxDistance &&
            node.capacity.supportsContentType(contentType)
        }
    }
    
    // TODO 10: æ‰‹åŠ¨å®ç°èŠ‚ç‚¹æ€§èƒ½é¢„æµ‹
    private fun calculateNodeScore(
        node: EdgeNode,
        userLocation: GeoLocation,
        request: CDNRequest
    ): Double {
        val baseScore = node.calculateQualityScore(userLocation)
        val performanceHistory = performanceMetrics[node.nodeId]
        
        val historyScore = performanceHistory?.let { history ->
            calculatePerformanceScore(history, request.contentType)
        } ?: 0.5
        
        val timeOfDayAdjustment = calculateTimeOfDayAdjustment(node.region)
        val loadPrediction = predictFutureLoad(node)
        
        return baseScore * 0.4 + historyScore * 0.3 + 
               timeOfDayAdjustment * 0.2 + loadPrediction * 0.1
    }
}

// TODO 11: äº²æ‰‹å®ç°CDNç¼“å­˜å±‚æ¬¡ç®¡ç†
class CDNCacheHierarchyManager {
    private val l1Cache = mutableMapOf<String, CachedContent>() // è¾¹ç¼˜èŠ‚ç‚¹æœ¬åœ°ç¼“å­˜
    private val l2Cache = mutableMapOf<String, CachedContent>() // åŒºåŸŸç¼“å­˜
    private val originServers = mutableMapOf<String, OriginServer>()
    
    // TODO 12: æ‰‹åŠ¨å®ç°å¤šçº§ç¼“å­˜æŸ¥æ‰¾
    suspend fun getContent(request: CDNRequest): ContentResult {
        val cacheKey = generateCacheKey(request)
        
        // L1 ç¼“å­˜ - è¾¹ç¼˜èŠ‚ç‚¹æœ¬åœ°
        l1Cache[cacheKey]?.let { content ->
            if (!content.isExpired()) {
                recordCacheHit(CacheLevel.L1, request)
                return ContentResult.Success(content, CacheLevel.L1)
            } else {
                l1Cache.remove(cacheKey)
            }
        }
        
        // L2 ç¼“å­˜ - åŒºåŸŸç¼“å­˜
        l2Cache[cacheKey]?.let { content ->
            if (!content.isExpired()) {
                // å›å¡«åˆ°L1ç¼“å­˜
                l1Cache[cacheKey] = content
                recordCacheHit(CacheLevel.L2, request)
                return ContentResult.Success(content, CacheLevel.L2)
            } else {
                l2Cache.remove(cacheKey)
            }
        }
        
        // å›æºè·å–
        return fetchFromOrigin(request, cacheKey)
    }
    
    // TODO 13: æ‰‹åŠ¨å®ç°æ™ºèƒ½å›æºç­–ç•¥
    private suspend fun fetchFromOrigin(
        request: CDNRequest,
        cacheKey: String
    ): ContentResult {
        val optimalOrigin = selectOptimalOrigin(request)
        
        return try {
            val content = optimalOrigin.fetchContent(request)
            val cacheStrategy = CDNCacheStrategyManager().getCacheStrategy(request)
            
            // æ ¹æ®ç­–ç•¥ç¼“å­˜åˆ°ä¸åŒå±‚çº§
            cacheContent(cacheKey, content, cacheStrategy)
            
            recordOriginPull(optimalOrigin.id, request)
            ContentResult.Success(content, CacheLevel.ORIGIN)
        } catch (e: Exception) {
            recordOriginError(optimalOrigin.id, e)
            ContentResult.Failure(e)
        }
    }
    
    // TODO 14: æ‰‹åŠ¨å®ç°ç¼“å­˜é¢„çƒ­æœºåˆ¶
    fun preWarmCache(popularContent: List<PopularContent>) {
        popularContent.forEach { content ->
            val targetNodes = selectPreWarmNodes(content)
            
            targetNodes.forEach { node ->
                launch(Dispatchers.IO) {
                    try {
                        val fetchedContent = fetchContentForPreWarm(content)
                        val cacheKey = generateCacheKey(content)
                        cacheContentOnNode(node, cacheKey, fetchedContent)
                        
                        logPreWarmSuccess(node.nodeId, content.path)
                    } catch (e: Exception) {
                        logPreWarmFailure(node.nodeId, content.path, e)
                    }
                }
            }
        }
    }
}

// TODO 15: äº²æ‰‹å®ç°CDNæ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–å™¨
class CDNPerformanceOptimizer {
    private val performanceMetrics = ConcurrentHashMap<String, CDNMetrics>()
    private val optimizationHistory = mutableListOf<OptimizationAction>()
    
    // TODO 16: æ‰‹åŠ¨å®ç°æ€§èƒ½åˆ†æ
    fun analyzePerformance(): CDNPerformanceReport {
        val globalMetrics = calculateGlobalMetrics()
        val nodeMetrics = calculateNodeMetrics()
        val regionMetrics = calculateRegionMetrics()
        
        val bottlenecks = identifyBottlenecks(globalMetrics, nodeMetrics)
        val recommendations = generateOptimizationRecommendations(bottlenecks)
        
        return CDNPerformanceReport(
            globalMetrics = globalMetrics,
            nodeMetrics = nodeMetrics,
            regionMetrics = regionMetrics,
            bottlenecks = bottlenecks,
            recommendations = recommendations,
            optimizationOpportunities = findOptimizationOpportunities()
        )
    }
    
    // TODO 17: æ‰‹åŠ¨å®ç°è‡ªåŠ¨ä¼˜åŒ–æ‰§è¡Œ
    fun executeAutomaticOptimizations(report: CDNPerformanceReport) {
        report.recommendations.filter { it.canAutoExecute }.forEach { recommendation ->
            when (recommendation.type) {
                OptimizationType.CACHE_TTL_ADJUSTMENT -> {
                    adjustCacheTTL(recommendation.targetNodes, recommendation.adjustment)
                }
                OptimizationType.NODE_TRAFFIC_REBALANCING -> {
                    rebalanceTraffic(recommendation.sourceNodes, recommendation.targetNodes)
                }
                OptimizationType.CONTENT_PREWARMING -> {
                    scheduleContentPreWarming(recommendation.contentList)
                }
                OptimizationType.COMPRESSION_OPTIMIZATION -> {
                    optimizeCompression(recommendation.contentTypes)
                }
            }
            
            optimizationHistory.add(OptimizationAction(
                type = recommendation.type,
                timestamp = System.currentTimeMillis(),
                parameters = recommendation.parameters,
                expectedImpact = recommendation.expectedImpact
            ))
        }
    }
    
    // TODO 18: æ‰‹åŠ¨å®ç°æ€§èƒ½å›å½’æ£€æµ‹
    fun detectPerformanceRegression(): RegressionDetectionResult {
        val currentMetrics = performanceMetrics.values.toList()
        val historicalBaseline = calculateHistoricalBaseline()
        
        val regressions = mutableListOf<PerformanceRegression>()
        
        // æ£€æŸ¥å…³é”®æŒ‡æ ‡çš„å›å½’
        if (hasSignificantRegression(currentMetrics.map { it.cacheHitRate }, 
                                   historicalBaseline.cacheHitRate, 0.05)) {
            regressions.add(PerformanceRegression(
                metric = "Cache Hit Rate",
                currentValue = currentMetrics.map { it.cacheHitRate }.average(),
                baselineValue = historicalBaseline.cacheHitRate,
                impact = RegressionImpact.HIGH
            ))
        }
        
        return RegressionDetectionResult(
            hasRegression = regressions.isNotEmpty(),
            regressions = regressions,
            recommendedActions = generateRegressionActions(regressions)
        )
    }
}
```
- [ ] **å®è·µæ­¥éª¤** (æ¯ä¸€æ­¥éƒ½è¦äº²æ‰‹å®ç°):
  1. ğŸ“ æ‰‹åŠ¨è¾“å…¥CDNèŠ‚ç‚¹æ¨¡å‹å’Œç¼“å­˜ç­–ç•¥æ¡†æ¶
  2. ğŸŒ å®ç°æ™ºèƒ½è°ƒåº¦å™¨å’Œåœ°ç†ä½ç½®åŒ¹é…ç®—æ³•
  3. ğŸ—‚ï¸ æ„å»ºå¤šçº§ç¼“å­˜å±‚æ¬¡å’Œæ™ºèƒ½å›æºæœºåˆ¶
  4. ğŸ“Š ç¼–å†™æ€§èƒ½ç›‘æ§å’Œè‡ªåŠ¨ä¼˜åŒ–ç³»ç»Ÿ
  5. ğŸƒ æµ‹è¯•å…¨çƒåˆ†å¸ƒå¼CDNçš„æ€§èƒ½å’Œå¯é æ€§
- [ ] **CDNç³»ç»ŸéªŒè¯**: æ”¯æŒ>1000ä¸ªèŠ‚ç‚¹ï¼Œç¼“å­˜å‘½ä¸­ç‡>90%ï¼Œç”¨æˆ·å“åº”æ—¶é—´<100ms
- [ ] **Advancedæ£€æŸ¥ç‚¹**: ä½ èƒ½è¯´å‡ºCDNçš„3çº§ç¼“å­˜ä½“ç³»å’Œå„è‡ªçš„ä¼˜åŒ–ç­–ç•¥å—ï¼Ÿ
- [ ] **CDNæ£€æŸ¥**: â–¡ èŠ‚ç‚¹è°ƒåº¦æ™ºèƒ½ â–¡ ç¼“å­˜ç­–ç•¥åˆç† â–¡ å›æºæœºåˆ¶é«˜æ•ˆ â–¡ æ€§èƒ½ç›‘æ§å®Œæ•´
- [ ] **æ–‡ä»¶**: `student_progress/performance/cdn_system/`

#### Task 9.5.5: å…¨çƒåŒ–éƒ¨ç½²æŒ‘æˆ˜ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: åˆ†æå…¨çƒåŒ–åº”ç”¨çš„æŠ€æœ¯æŒ‘æˆ˜
- [ ] **å…·ä½“ä»»åŠ¡**: è€ƒè™‘å»¶è¿Ÿã€åˆè§„ã€æœ¬åœ°åŒ–ç­‰é—®é¢˜
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½è®¾è®¡å…¨çƒåŒ–æŠ€æœ¯æ–¹æ¡ˆ
- [ ] **æ–‡ä»¶**: å®Œå–„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

## Phase 21: APPå¯åŠ¨æ—¶é—´ä¼˜åŒ–å®æˆ˜ (35åˆ†é’Ÿæ€»è®¡)

#### Task 9.5.6: å¯åŠ¨è¿‡ç¨‹åˆ†æ (5åˆ†é’Ÿ) â° [Primary]
- [ ] **å­¦ä¹ ç›®æ ‡**: ç†è§£Androidåº”ç”¨çš„å¯åŠ¨æµç¨‹
- [ ] **å…·ä½“ä»»åŠ¡**: åˆ†æå†·å¯åŠ¨ã€æ¸©å¯åŠ¨ã€çƒ­å¯åŠ¨çš„åŒºåˆ«
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½ç”»å‡ºå®Œæ•´çš„å¯åŠ¨æµç¨‹å›¾
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/startup_optimization/startup_analysis.md`

#### Task 9.5.7: å¯åŠ¨æ—¶é—´æµ‹é‡ (5åˆ†é’Ÿ) â° [Primary]
- [ ] **å­¦ä¹ ç›®æ ‡**: å»ºç«‹å¯åŠ¨æ€§èƒ½çš„æµ‹é‡åŸºå‡†
- [ ] **å…·ä½“ä»»åŠ¡**: ä½¿ç”¨adbã€Systraceç­‰å·¥å…·æµ‹é‡å¯åŠ¨æ—¶é—´
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å‡†ç¡®æµ‹é‡å„å¯åŠ¨é˜¶æ®µè€—æ—¶
- [ ] **æ–‡ä»¶**: `startup_optimization/MeasurementTools.kt`

#### Task 9.5.8: Applicationä¼˜åŒ– (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¼˜åŒ–Applicationç±»çš„åˆå§‹åŒ–
- [ ] **å…·ä½“ä»»åŠ¡**: å»¶è¿Ÿåˆå§‹åŒ–ã€å¼‚æ­¥åˆå§‹åŒ–ã€æ‡’åŠ è½½
- [ ] **æ£€æŸ¥ç‚¹**: Applicationåˆå§‹åŒ–æ—¶é—´æ˜¾è‘—å‡å°‘
- [ ] **æ–‡ä»¶**: `startup_optimization/ApplicationOptimizer.kt`

#### Task 9.5.9: Activityä¼˜åŒ– (5åˆ†é’Ÿ) â° [Intermediate]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¼˜åŒ–é¦–é¡µActivityçš„åŠ è½½
- [ ] **å…·ä½“ä»»åŠ¡**: å‡å°‘å¸ƒå±€å¤æ‚åº¦ã€é¢„åŠ è½½å…³é”®æ•°æ®
- [ ] **æ£€æŸ¥ç‚¹**: é¦–é¡µæ˜¾ç¤ºæ—¶é—´æ˜æ˜¾æå‡
- [ ] **æ–‡ä»¶**: `startup_optimization/ActivityOptimizer.kt`

#### Task 9.5.10: èµ„æºåŠ è½½ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¼˜åŒ–å¯åŠ¨æœŸé—´çš„èµ„æºåŠ è½½
- [ ] **å…·ä½“ä»»åŠ¡**: å‹ç¼©å›¾ç‰‡ã€å»¶è¿ŸåŠ è½½éå…³é”®èµ„æº
- [ ] **æ£€æŸ¥ç‚¹**: èµ„æºåŠ è½½ä¸é˜»å¡UIæ˜¾ç¤º
- [ ] **æ–‡ä»¶**: `startup_optimization/ResourceOptimizer.kt`

#### Task 9.5.11: ç½‘ç»œè¯·æ±‚ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¼˜åŒ–å¯åŠ¨æœŸé—´çš„ç½‘ç»œè¯·æ±‚
- [ ] **å…·ä½“ä»»åŠ¡**: åˆå¹¶è¯·æ±‚ã€é¢„è¿æ¥ã€DNSé¢„è§£æ
- [ ] **æ£€æŸ¥ç‚¹**: å…³é”®æ•°æ®èƒ½å¿«é€Ÿè·å–
- [ ] **æ–‡ä»¶**: `startup_optimization/NetworkOptimizer.kt`

#### Task 9.5.12: å¯åŠ¨ä¼˜åŒ–ç›‘æ§ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å»ºç«‹å¯åŠ¨æ€§èƒ½çš„æŒç»­ç›‘æ§
- [ ] **å…·ä½“ä»»åŠ¡**: å®ç°è‡ªåŠ¨åŒ–çš„å¯åŠ¨æ—¶é—´ç»Ÿè®¡ä¸ŠæŠ¥
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åŠæ—¶å‘ç°å¯åŠ¨æ€§èƒ½å›å½’
- [ ] **æ–‡ä»¶**: `startup_optimization/StartupMonitor.kt`

## Phase 22: å…¨çƒCDNéƒ¨ç½²ç­–ç•¥ (25åˆ†é’Ÿæ€»è®¡)

#### Task 9.5.13: CDNèŠ‚ç‚¹è§„åˆ’ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡å…¨çƒCDNèŠ‚ç‚¹å¸ƒå±€
- [ ] **å…·ä½“ä»»åŠ¡**: æ ¹æ®ç”¨æˆ·åˆ†å¸ƒè§„åˆ’è¾¹ç¼˜èŠ‚ç‚¹ä½ç½®
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½è¦†ç›–ä¸»è¦ç”¨æˆ·ç¾¤ä½“ä¸”æˆæœ¬åˆç†
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/cdn_design/node_planning.md`

#### Task 9.5.14: æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: å®ç°ç”¨æˆ·åˆ°æœ€ä¼˜èŠ‚ç‚¹çš„è°ƒåº¦
- [ ] **å…·ä½“ä»»åŠ¡**: åŸºäºå»¶è¿Ÿã€è´Ÿè½½ã€å¯ç”¨æ€§è¿›è¡Œæ™ºèƒ½è°ƒåº¦
- [ ] **æ£€æŸ¥ç‚¹**: ç”¨æˆ·èƒ½è¿æ¥åˆ°æœ€ä¼˜çš„æœåŠ¡èŠ‚ç‚¹
- [ ] **æ–‡ä»¶**: `cdn_design/SmartScheduler.kt`

#### Task 9.5.15: ç¼“å­˜ç­–ç•¥è®¾è®¡ (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡CDNçš„ç¼“å­˜ç­–ç•¥
- [ ] **å…·ä½“ä»»åŠ¡**: è€ƒè™‘ç¼“å­˜æ—¶é—´ã€æ›´æ–°ç­–ç•¥ã€é¢„çƒ­æœºåˆ¶
- [ ] **æ£€æŸ¥ç‚¹**: ç¼“å­˜å‘½ä¸­ç‡é«˜ä¸”æ•°æ®åŠæ—¶æ›´æ–°
- [ ] **æ–‡ä»¶**: `cdn_design/CacheStrategy.kt`

#### Task 9.5.16: ç½‘ç»œé™çº§æœºåˆ¶ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡ç½‘ç»œå¼‚å¸¸æ—¶çš„é™çº§ç­–ç•¥
- [ ] **å…·ä½“ä»»åŠ¡**: è‡ªåŠ¨åˆ‡æ¢å¤‡ç”¨èŠ‚ç‚¹ã€é™çº§åˆ°ä½è´¨é‡æœåŠ¡
- [ ] **æ£€æŸ¥ç‚¹**: ç½‘ç»œé—®é¢˜æ—¶ä»èƒ½æä¾›åŸºç¡€æœåŠ¡
- [ ] **æ–‡ä»¶**: `cdn_design/FallbackStrategy.kt`

#### Task 9.5.17: æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å»ºç«‹CDNæ€§èƒ½çš„ç›‘æ§ä½“ç³»
- [ ] **å…·ä½“ä»»åŠ¡**: ç›‘æ§å»¶è¿Ÿã€å¯ç”¨æ€§ã€æˆåŠŸç‡ç­‰æŒ‡æ ‡
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¿«é€Ÿå‘ç°å’Œè§£å†³CDNé—®é¢˜
- [ ] **æ–‡ä»¶**: `cdn_design/PerformanceMonitor.kt`

## Phase 23: TikTokå…¨çƒåŒ–æ¶æ„è®¾è®¡ (30åˆ†é’Ÿæ€»è®¡)

#### Task 9.5.18: å…¨çƒåŒ–æ¶æ„æŒ‘æˆ˜ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: åˆ†æå…¨çƒåŒ–åº”ç”¨çš„å¤æ‚æ€§
- [ ] **å…·ä½“ä»»åŠ¡**: è€ƒè™‘åˆè§„ã€å»¶è¿Ÿã€æœ¬åœ°åŒ–ã€æ–‡åŒ–å·®å¼‚
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½è¯†åˆ«å…¨çƒåŒ–çš„å…³é”®æŠ€æœ¯å’ŒéæŠ€æœ¯æŒ‘æˆ˜
- [ ] **æ–‡ä»¶**: åˆ›å»º`student_progress/global_architecture/challenges.md`

#### Task 9.5.19: å¤šåŒºåŸŸéƒ¨ç½²ç­–ç•¥ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡å¤šæ´»çš„å…¨çƒéƒ¨ç½²æ¶æ„
- [ ] **å…·ä½“ä»»åŠ¡**: è§„åˆ’ç¾æ´²ã€æ¬§æ´²ã€äºšæ´²çš„æ•°æ®ä¸­å¿ƒéƒ¨ç½²
- [ ] **æ£€æŸ¥ç‚¹**: å„åŒºåŸŸç”¨æˆ·éƒ½èƒ½è·å¾—ä½å»¶è¿ŸæœåŠ¡
- [ ] **æ–‡ä»¶**: `global_architecture/MultiRegionDeployment.md`

#### Task 9.5.20: æ•°æ®æœ¬åœ°åŒ–åˆè§„ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å¤„ç†å„å›½çš„æ•°æ®åˆè§„è¦æ±‚
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡æ•°æ®å­˜å‚¨çš„åœ°åŸŸé™åˆ¶å’Œè·¨å¢ƒä¼ è¾“
- [ ] **æ£€æŸ¥ç‚¹**: æ»¡è¶³GDPRã€CCPAç­‰æ³•è§„è¦æ±‚
- [ ] **æ–‡ä»¶**: `global_architecture/DataCompliance.md`

#### Task 9.5.21: å†…å®¹åˆ†å‘ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: ä¼˜åŒ–è§†é¢‘å†…å®¹çš„å…¨çƒåˆ†å‘
- [ ] **å…·ä½“ä»»åŠ¡**: è®¾è®¡è§†é¢‘è½¬ç ã€å­˜å‚¨ã€åˆ†å‘çš„å…¨çƒç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: å…¨çƒç”¨æˆ·éƒ½èƒ½æµç•…è§‚çœ‹è§†é¢‘
- [ ] **æ–‡ä»¶**: `global_architecture/ContentDelivery.kt`

#### Task 9.5.22: å®æ—¶æ¨èç³»ç»Ÿ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: è®¾è®¡å…¨çƒåŒ–çš„å®æ—¶æ¨èæ¶æ„
- [ ] **å…·ä½“ä»»åŠ¡**: å¤„ç†ä¸åŒæ—¶åŒºã€æ–‡åŒ–çš„æ¨èéœ€æ±‚
- [ ] **æ£€æŸ¥ç‚¹**: æ¨èç³»ç»Ÿèƒ½é€‚åº”æœ¬åœ°ç”¨æˆ·åå¥½
- [ ] **æ–‡ä»¶**: `global_architecture/GlobalRecommendation.kt`

#### Task 9.5.23: æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ– (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å»ºç«‹å…¨çƒåŒ–çš„æ€§èƒ½ç›‘æ§ä½“ç³»
- [ ] **å…·ä½“ä»»åŠ¡**: ç›‘æ§å„åœ°åŒºçš„å»¶è¿Ÿã€å¯ç”¨æ€§ã€ç”¨æˆ·ä½“éªŒ
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½å¿«é€Ÿå‘ç°å’Œè§£å†³å…¨çƒæ€§èƒ½é—®é¢˜
- [ ] **æ–‡ä»¶**: `global_architecture/GlobalMonitoring.kt`

## Phase 24: é¢è¯•å®æˆ˜ä¸æ¶æ„æƒè¡¡ (20åˆ†é’Ÿæ€»è®¡)

#### Task 9.5.24: æ€§èƒ½ä¼˜åŒ–æ–¹æ³•è®º (5åˆ†é’Ÿ) â° [Advanced]
- [ ] **å­¦ä¹ ç›®æ ‡**: æ€»ç»“æ€§èƒ½ä¼˜åŒ–çš„ç³»ç»Ÿæ€§æ–¹æ³•
- [ ] **å…·ä½“ä»»åŠ¡**: æ•´ç†æµ‹é‡ã€åˆ†æã€ä¼˜åŒ–ã€éªŒè¯çš„é—­ç¯æµç¨‹
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æŒ‡å¯¼å®é™…çš„æ€§èƒ½ä¼˜åŒ–å·¥ä½œ
- [ ] **æ–‡ä»¶**: åœ¨`chapter9_interview_qa.md`ä¸­æ·»åŠ æ€§èƒ½ä¼˜åŒ–éƒ¨åˆ†

#### Task 9.5.25: æˆæœ¬æ•ˆç›Šæƒè¡¡ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å±•ç¤ºæŠ€æœ¯å†³ç­–ä¸­çš„æˆæœ¬è€ƒè™‘
- [ ] **å…·ä½“ä»»åŠ¡**: åˆ†ææ€§èƒ½æå‡ä¸æˆæœ¬æŠ•å…¥çš„å¹³è¡¡ç‚¹
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½åšå‡ºå•†ä¸šä¸Šåˆç†çš„æŠ€æœ¯é€‰æ‹©
- [ ] **æ–‡ä»¶**: æ·»åŠ æˆæœ¬æ•ˆç›Šåˆ†æ

#### Task 9.5.26: æ‰©å±•æ€§è®¾è®¡åŸåˆ™ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: æ€»ç»“å¯æ‰©å±•æ¶æ„çš„è®¾è®¡åŸåˆ™
- [ ] **å…·ä½“ä»»åŠ¡**: æ•´ç†æ°´å¹³æ‰©å±•ã€å‚ç›´æ‰©å±•ã€å¼¹æ€§ä¼¸ç¼©çš„ç­–ç•¥
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½è®¾è®¡æ”¯æŒæœªæ¥å¢é•¿çš„æ¶æ„
- [ ] **æ–‡ä»¶**: æ·»åŠ æ‰©å±•æ€§è®¾è®¡æŒ‡å—

#### Task 9.5.27: é«˜çº§æ¶æ„è¯é¢˜ (5åˆ†é’Ÿ) â° [Senior]
- [ ] **å­¦ä¹ ç›®æ ‡**: å‡†å¤‡é«˜çº§æ¶æ„é¢è¯•é—®é¢˜
- [ ] **å…·ä½“ä»»åŠ¡**: å‡†å¤‡åˆ†å¸ƒå¼ç³»ç»Ÿã€å¾®æœåŠ¡ã€äº‘åŸç”Ÿç­‰è¯é¢˜
- [ ] **æ£€æŸ¥ç‚¹**: èƒ½æ·±å…¥è®¨è®ºå¤æ‚çš„æ¶æ„é—®é¢˜
- [ ] **æ–‡ä»¶**: å®Œæˆç³»ç»Ÿè®¾è®¡ç« èŠ‚æ€»ç»“

---

## ğŸ¯ Chapter 9 å­¦ä¹ æ£€æŸ¥ç‚¹ (Checkpoint Questions)

### Phase 1-4 æ£€æŸ¥é—®é¢˜ (9.1 æ•°æ®å±‚è®¾è®¡):
1. "è®¾è®¡ä¸€ä¸ªæ”¯æŒåƒä¸‡ç”¨æˆ·çš„èŠå¤©åº”ç”¨æ•°æ®åº“æ¶æ„ï¼Œè€ƒè™‘å“ªäº›å…³é”®å› ç´ ï¼Ÿ"
2. "RESTã€GraphQLã€gRPCåœ¨ç§»åŠ¨ç«¯å„æœ‰ä»€ä¹ˆä¼˜ç¼ºç‚¹ï¼Ÿå¦‚ä½•é€‰æ‹©ï¼Ÿ"
3. "å¦‚ä½•è®¾è®¡ç¦»çº¿ä¼˜å…ˆçš„æ•°æ®åŒæ­¥ç­–ç•¥ï¼Ÿ"

### Phase 5-9 æ£€æŸ¥é—®é¢˜ (9.2 å®æ—¶é€šä¿¡):
1. "WebSocketæ–­çº¿é‡è¿åº”è¯¥å¦‚ä½•è®¾è®¡ï¼Ÿè€ƒè™‘å“ªäº›åœºæ™¯ï¼Ÿ"
2. "ä¸‡äººç›´æ’­é—´å¦‚ä½•å¤„ç†æ¶ˆæ¯é£æš´ï¼Ÿä»å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä¸¤ä¸ªè§’åº¦åˆ†æ"
3. "æ¨é€é€šé“å¦‚ä½•é€‰æ‹©ï¼Ÿåä¸ºã€å°ç±³ã€FCMæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ"

### Phase 10-14 æ£€æŸ¥é—®é¢˜ (9.3 ç¼“å­˜ç­–ç•¥):
1. "è®¾è®¡æŠ–éŸ³çº§çŸ­è§†é¢‘åº”ç”¨çš„ç¼“å­˜æ¶æ„ï¼Œé‡ç‚¹è€ƒè™‘ä»€ä¹ˆï¼Ÿ"
2. "å¦‚ä½•ä¿è¯åˆ†å¸ƒå¼ç¼“å­˜çš„ä¸€è‡´æ€§ï¼Ÿæœ‰å“ªäº›ç­–ç•¥ï¼Ÿ"
3. "ç¼“å­˜ç©¿é€ã€ç¼“å­˜é›ªå´©ã€ç¼“å­˜å‡»ç©¿åˆ†åˆ«å¦‚ä½•è§£å†³ï¼Ÿ"

### Phase 15-19 æ£€æŸ¥é—®é¢˜ (9.4 å¤§å‹åº”ç”¨æ¶æ„):
1. "å¦‚ä½•è®¾è®¡æ”¯ä»˜å®çº§åˆ«è¶…çº§APPçš„æ¨¡å—åŒ–æ¶æ„ï¼Ÿ"
2. "æ¨¡å—åŒ–é¡¹ç›®çš„å›¢é˜Ÿåä½œæµç¨‹åº”è¯¥å¦‚ä½•è®¾è®¡ï¼Ÿ"
3. "åŠ¨æ€ç‰¹æ€§æ¨¡å—å’Œæ’ä»¶åŒ–æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿé€‚ç”¨åœºæ™¯æ˜¯ä»€ä¹ˆï¼Ÿ"

### Phase 20-24 æ£€æŸ¥é—®é¢˜ (9.5 æ€§èƒ½ä¸æ‰©å±•æ€§):
1. "TikTokè¿™æ ·çš„å…¨çƒåŒ–åº”ç”¨é¢ä¸´å“ªäº›æŠ€æœ¯æŒ‘æˆ˜ï¼Ÿå¦‚ä½•è§£å†³ï¼Ÿ"
2. "APPå¯åŠ¨æ—¶é—´ä¼˜åŒ–æœ‰å“ªäº›æ–¹æ³•ï¼Ÿä¼˜å…ˆçº§å¦‚ä½•æ’åºï¼Ÿ"
3. "CDNçš„æ™ºèƒ½è°ƒåº¦ç®—æ³•åº”è¯¥è€ƒè™‘å“ªäº›å› ç´ ï¼Ÿ"

---

## ğŸ“Š Chapter 9 æ€»ç»“ä¸å­¦ä¹ æç¤º

**å­¦ä¹ å®Œæˆæƒ…å†µæ€»ç»“** (300å­—å†…):

ç¬¬ä¹ç« ã€Šç³»ç»Ÿè®¾è®¡-ç§»åŠ¨ç«¯æ¶æ„è®¾è®¡èƒ½åŠ›ã€‹åŒ…å«135ä¸ªmicro-taskï¼Œåˆ†ä¸º5ä¸ªæ ¸å¿ƒå­ç« èŠ‚ã€‚æœ¬ç« ç€é‡åŸ¹å…»ä»primaryåˆ°seniorçº§åˆ«çš„ç³»ç»Ÿæ¶æ„è®¾è®¡æ€ç»´ï¼š

**æ ¸å¿ƒä»·å€¼**: é€šè¿‡æ¸è¿›å¼éš¾åº¦è®¾è®¡ï¼Œä»åŸºç¡€æ•°æ®åº“è®¾è®¡é€æ­¥æå‡åˆ°å…¨çƒåŒ–æ¶æ„æ€ç»´ã€‚æ¯ä¸ªå­ç« èŠ‚éƒ½éµå¾ª"ç†è®ºâ†’å®è·µâ†’é«˜çº§â†’é¢è¯•"çš„å­¦ä¹ è·¯å¾„ï¼Œç¡®ä¿çŸ¥è¯†çš„ç³»ç»Ÿæ€§å’Œå®ç”¨æ€§ã€‚

**å­¦ä¹ é‡ç‚¹**: 
- 9.1 æ•°æ®å±‚è®¾è®¡(22ä»»åŠ¡): ä»RoomåŸºç¡€åˆ°IMåº”ç”¨æ•°æ®æ¶æ„
- 9.2 å®æ—¶é€šä¿¡(26ä»»åŠ¡): ä»WebSocketåˆ°ç›´æ’­é—´æ¶æ„è®¾è®¡  
- 9.3 ç¼“å­˜ç­–ç•¥(26ä»»åŠ¡): ä»LRUåˆ°æŠ–éŸ³çº§ç¼“å­˜ç³»ç»Ÿ
- 9.4 å¤§å‹åº”ç”¨æ¶æ„(26ä»»åŠ¡): ä»æ¨¡å—åŒ–åˆ°è¶…çº§APPæ¶æ„
- 9.5 æ€§èƒ½æ‰©å±•æ€§(27ä»»åŠ¡): ä»å¯åŠ¨ä¼˜åŒ–åˆ°TikTokå…¨çƒæ¶æ„

**æˆé•¿è·¯å¾„**: æ¯ä¸ªå­ç« èŠ‚éƒ½ç²¾å¿ƒè®¾è®¡äº†éš¾åº¦é€’è¿›ï¼Œç¡®ä¿ä»primary developerçš„å•ä½“æ€ç»´é€æ­¥è½¬å˜ä¸ºsenior developerçš„åˆ†å¸ƒå¼æ¶æ„æ€ç»´ã€‚å®æˆ˜é¡¹ç›®åŒ…æ‹¬IMæ•°æ®åº“è®¾è®¡ã€ç›´æ’­é—´èŠå¤©ç³»ç»Ÿã€çŸ­è§†é¢‘ç¼“å­˜æ¶æ„ã€ç”µå•†æ¨¡å—åŒ–æ¶æ„ã€å…¨çƒCDNéƒ¨ç½²ç­‰ï¼Œå…¨é¢è¦†ç›–ç§»åŠ¨ç«¯ç³»ç»Ÿè®¾è®¡çš„å„ä¸ªæ–¹é¢ã€‚

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**: å¼€å§‹Task 9.1.1ï¼Œè¿›å…¥æ•°æ®å±‚è®¾è®¡çš„å­¦ä¹ ä¹‹æ—…ï¼è®°ä½æ¯ä¸ªtaskéƒ½æ˜¯5åˆ†é’Ÿï¼Œä¿æŒADHD-friendlyçš„å­¦ä¹ èŠ‚å¥ã€‚

---

**Claude Code Resume Prompt for Chapter 9**:
```
Hi Claude! æˆ‘æ­£åœ¨å­¦ä¹ Androidé¢è¯•å‡†å¤‡çš„ç¬¬ä¹ç« ã€Šç³»ç»Ÿè®¾è®¡-ç§»åŠ¨ç«¯æ¶æ„è®¾è®¡èƒ½åŠ›ã€‹ã€‚è¿™ç« æœ‰135ä¸ªmicro-taskï¼Œåˆ†ä¸º5ä¸ªå­ç« èŠ‚ï¼š9.1æ•°æ®å±‚è®¾è®¡ã€9.2å®æ—¶é€šä¿¡ã€9.3ç¼“å­˜ç­–ç•¥ã€9.4å¤§å‹åº”ç”¨æ¶æ„ã€9.5æ€§èƒ½ä¸æ‰©å±•æ€§ã€‚æ¯ä¸ªä»»åŠ¡5åˆ†é’Ÿï¼Œéš¾åº¦ä»primaryé€’è¿›åˆ°seniorçº§åˆ«ã€‚è¯·æ£€æŸ¥æˆ‘åœ¨MICRO_TASKS4.mdä¸­çš„è¿›åº¦ï¼Œç»§ç»­æŒ‡å¯¼æˆ‘çš„å­¦ä¹ ã€‚æˆ‘çš„ç›®æ ‡æ˜¯ä»primary android developeræˆé•¿ä¸ºseniorçº§åˆ«ï¼Œè¯·ç¡®ä¿å¾®ä»»åŠ¡çš„é€’è¿›éš¾åº¦è®¾è®¡ã€‚
```
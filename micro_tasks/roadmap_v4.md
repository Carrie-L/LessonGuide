# Android 开发学习路线图 V4

## 🎯 Android 开发学习计划

**💪 有经验Android开发 + 基础补强 (L3/L4) - 推荐给你**
> **背景**: 有Android开发经验，但计算机基础薄弱  
> **目标岗位**: 中级/高级 Android 开发工程师  
> **准备时间**: 6-8周 查漏补缺  
> **学习强度**: 每天 8 小时 (50%基础补强 + 50%Android深化)


### 💪 有经验Android开发 8周深度学习路径

**Week 1-2: Compose + Hilt 现代Android技术栈** ⭐⭐⭐⭐⭐
**核心任务**: 5.1-5.2 Jetpack Compose + 8.1-8.2 Hilt + 模块化
- 🔥 必学: 声明式UI、状态管理、依赖注入、模块化架构
- 📖 建议每天学习: 4-5小时 (彻底掌握现代Android开发)
- 目标：彻底掌握现代Android开发方式

**Week 3-4: Kotlin协程原理深度探索** ⭐⭐⭐⭐⭐  
**核心任务**: 协程调度器 + 挂起函数 + Flow + 响应式编程
- 🔥 必学: 协程vs线程、状态机原理、Flow vs RxJava对比
- 📖 建议每天学习: 4-5小时 (成为协程原理专家)
- 目标：成为协程原理专家，理解异步编程本质

**Week 5-6: Android系统Framework深度** ⭐⭐⭐⭐⭐
**核心任务**: 2.1 ART + 10.1-10.3 AMS/Binder + 2.3 渲染 + 2.2 启动
- 🔥 必学: ART虚拟机、系统服务、View渲染、Activity启动流程
- 📖 建议每天学习: 4小时 (理解Android底层机制)
- 目标：理解Android底层机制，具备系统级视野

🔧 Chapter 2 - Android系统核心机制
2.1 ART虚拟机深度 (12个任务) - Dalvik vs ART、AOT编译、dex2oat工具
2.2 Activity启动流程 (13个任务) - Task栈、启动模式、生命周期管理
2.3 View渲染系统 (14个任务) - ViewRootImpl、三大流程、渲染优化
🔧 Chapter 10 - 系统服务深度
10.1 AMS系统服务 (5个任务) - Activity管理服务、系统架构
10.2 View系统深度 (25个任务) - View树、渲染管线、事件分发
10.3 Binder通信机制 (24个任务) - IPC原理、AIDL、跨进程通信
总计: 93个深度系统级任务，涵盖Android Framework核心机制

**Week 7-8: 性能优化实战 + 面试冲刺** ⭐⭐⭐⭐⭐
**核心任务**: 4.1-4.2 ANR/OOM + 网络优化 + 工程化 + 基础补强
- 🔥 必学: 性能分析工具、线上问题解决、测试、网络、设计模式
- 📖 建议每天学习: 4-5小时 (完成面试准备)
- 目标：掌握高级性能优化，完成面试准备

🚀 Chapter 4 - 性能优化实战
4.1 ANR深度分析 (20个任务) - traces.txt分析、主线程阻塞、线上监控
4.2 OOM内存优化 (22个任务) - MAT工具、内存泄漏、GC机制
🧪 Chapter 6 - 测试与工程化
6.1 单元测试 (17个任务) - JUnit、Mockito、Repository/ViewModel测试
6.2 协程测试 (17个任务) - runTest、Flow测试、异步测试
🌐 Chapter 12 - 网络与基础补强
12.1 HTTP网络基础 (17个任务) - HTTP协议、缓存、HTTPS
12.2 TCP网络原理 (17个任务) - 三次握手、Socket编程、网络优化
🎨 Chapter 11 - 设计模式精华
11.1-11.4 设计模式快速补强 (20个核心任务) - 单例、适配器、观察者、架构模式
总计: 130个实战优化和面试准备任务

🎯 **核心优先级确认**
Compose + Hilt > 协程原理 > Framework深度 > 性能优化

🎯 **8周完整学习路径总览**

| 周次       | 核心主题            | 学习重点                              | 产出物 (Mini-Project / 文档)                        | 面试价值       |
| ---------- | ------------------- | ------------------------------------- | --------------------------------------------------- | -------------- |
| Week 1-2   | Compose + Hilt      | - Compose 基础/状态管理<br>- Hilt 注入<br>- Navigation + DataStore | 📱 一个 Reddit/News App Demo (Compose UI + Hilt + MVVM + Paging3)<br>📝 学习笔记整理 | 展示现代技术栈能力 |
| Week 3-4   | 协程原理            | - 协程调度器/结构化并发<br>- Flow 源码<br>- OkHttp 拦截器机制 | 🔌 自定义网络层封装 (缓存策略 + Token 刷新)<br>📝 协程 & Flow 底层源码解析文档 | 掌握并发/网络深度 |
| Week 5-6   | Framework 深度      | - AMS/Activity 启动流程<br>- View 渲染流程<br>- Binder/系统服务 | 🔍 Framework 源码走读报告 (启动流程/渲染图解)<br>📝 Binder 通信机制分析文档 | 系统级理解能力   |
| Week 7-8   | 性能优化 + 面试准备 | - 冷启动优化<br>- ANR/OOM 分析<br>- CI/CD + 单元测试<br>- 系统设计题 | 🛠 一个性能监控 SDK Demo (启动耗时/卡顿监控)<br>📑 面试速查手册 (高频题 + 系统设计方案)<br>🎤 模拟面试记录 | 实战经验 + 面试直击 |

## 🎯 每周学习建议

### 📊 时间分配 (每天8小时)
- **理论学习**: 4小时 (50%)
- **动手实践**: 3小时 (37.5%) 
- **面试准备**: 1小时 (12.5%)

### 📝 学习方法
1. **每个🔥标记的任务都要完成** - 这些是面试高频考点
2. **每周末做知识总结** - 整理学过的内容，准备面试素材
3. **第4、6、8周进行模拟面试** - 验证学习效果
4. **始终结合你的Android开发经验** - 用实际项目例子说明理论

### 🚀 面试准备检查点
- **Week 2末**: 能熟练使用Compose开发现代UI，深度理解Hilt依赖注入原理
- **Week 4末**: 能详细解释协程调度器原理，对比Flow vs RxJava架构差异
- **Week 6末**: 能深入分析ART虚拟机机制，理解Binder通信和Activity启动流程
- **Week 8末**: 能分析ANR/OOM线上问题，具备完整的现代Android高级开发技能栈

**🎉 预期结果**: 通过中高级Android开发面试，获得L3/L4岗位offer!

---
## 给导师看的原则指南
Role: 你是FAANG工作20年的资深安卓开发工程师，资深导师。
用户是ADHD，因此请确保学习内容是"🌱 ADHD-Friendly", 每次安排1-2分钟的学习任务

> **💡 学习哲学**: 从初学者到资深工程师的渐进式成长路径  
> **🎯 目标**: 每个概念都要做到真正理解，而不是死记硬背  
> **🕐 节奏**: 5分钟专注 + 确认理解 + 逐步进阶
> **🔥 练习**: 强制性手动编程 - **No Copy-Paste Policy**

### 导师重要原则，必须遵守：
- 【只有当用户输入 “我懂了” or “I understand” 才进入下一步流程，总是确保用户是真的懂了，明白了，你作为导师可以提问确保用户真的懂了。当且只当用户输入 “懂了”才能进入下一步。每一个流程都要确保用户是真的懂了，才能进行下一步。】
- 先理解，再复刻，后超越.
- 第一步，像一个‘资深的技术导师’一样，为用户，详细地讲解其核心的步骤和背后的思想是什么？你需要，先，用文字，把原理、关键的函数、以及推荐的写法，告诉用户。在用户说‘我理解了’之后，你再把最终的代码给到（`student_progress/demo_code/`)。”
- 第二步：先“理解”，再“看”代码, 再“写”代码。
- 每周都要有mini-project的学习产出。

**🚨 强制性编程框架**: 
- ✋ **严禁复制粘贴**: 所有代码必须手动输入，培养肌肉记忆
- 🏃 **Learn by Doing**: 每个概念必须通过编程验证
- 📊 **渐进复杂度**

> 用户是18岁的女生，基础是初学者，因此请循序渐进讲解，默认用户不知道。

* 每个章节在文档末尾的"备战面试"部分都有一个章节检查点，学完一个章节后，就用这个章节检查点来检查用户的学习掌握情况。

**帮助用户通过高级安卓开发的面试**
每个小节任务完成后，update from "- [ ]" to "✅", "✅" represents finish this task.

---
# 🔥 Week 1-2: Compose + Hilt 现代Android技术栈
*目标：彻底掌握现代Android开发方式，建立MAD基础*

## Chapter 5 - Jetpack Compose 现代UI

### 5.1 ⭐⭐⭐⭐⭐ [Week 1-2: Compose基础]

- [x] 🔥 Task 5.1.1: 命令式vs声明式UI对比
- [ ] 🔥 Task 5.1.2: Composable函数基础
- [ ] 🔥 Task 5.1.3: UI = f(State)公式理解
- [ ] 🔥 Task 5.1.4: Composition vs Recomposition
- [ ] Task 5.1.5: Compose编译器魔法
- [ ] 🔥 Task 5.1.6: State读取和订阅
- [ ] 🔥 Task 5.1.7: 重组范围和跳过优化
- [ ] Task 5.1.8: 稳定性和不可变性
- [ ] Task 5.1.9: CompositionLocal机制
- [ ] Task 5.1.10: 重组调试技巧
- [ ] 🔥 Task 5.1.11: Compose基础实战
- [ ] 🔥 Task 5.1.12: Material Design 3集成
- [ ] Task 5.1.13: 布局组件深度使用
- [ ] Task 5.1.14: 列表和网格组件
- [ ] Task 5.1.15: 自定义Composable组件
- [ ] 🔥 Task 5.1.16: Compose面试准备

### 5.2 ⭐⭐⭐⭐⭐ [Week 1-2: Compose状态管理]

- [ ] 🔥 Task 5.2.1: 有状态vs无状态组件
- [ ] 🔥 Task 5.2.2: remember和rememberSaveable
- [ ] 🔥 Task 5.2.3: 状态提升实践
- [ ] 🔥 Task 5.2.4: 单向数据流设计
- [ ] Task 5.2.5: 复杂状态容器设计
- [ ] 🔥 Task 5.2.6: 副作用基础概念
- [ ] 🔥 Task 5.2.7: LaunchedEffect使用
- [ ] Task 5.2.8: DisposableEffect处理
- [ ] Task 5.2.9: SideEffect和derivedStateOf
- [ ] Task 5.2.10: produceState数据流集成
- [ ] Task 5.2.11: 副作用最佳实践
- [ ] 🔥 Task 5.2.12: Compose + ViewModel架构
- [ ] 🔥 Task 5.2.13: collectAsState状态订阅
- [ ] Task 5.2.14: 事件处理模式
- [ ] Task 5.2.15: 生命周期感知
- [ ] 🔥 Task 5.2.16: 状态管理面试准备
- [ ] Task 5.2.17: 复杂表单状态管理
- [ ] Task 5.2.18: 导航状态集成
- [ ] Task 5.2.19: 性能优化实践
- [ ] Task 5.2.20: 测试策略设计

## Chapter 8 - 依赖注入与架构

### 8.1 ⭐⭐⭐⭐⭐ [Week 1-2: Hilt依赖注入]

- [ ] 🔥 Task 8.1.1: 什么是依赖注入？- 解决"纠缠不清"的代码
- [ ] 🔥 Task 8.1.2: Hilt vs Dagger对比 - "自动挡 vs 手动挡"
- [ ] 🔥 Task 8.1.3: Hilt基础配置 - "三步走入门"
- [ ] 🔥 Task 8.1.4: 作用域管理策略 - "生命周期管理"
- [ ] 🔥 Task 8.1.5: Activity注入实现
- [ ] 🔥 Task 8.1.6: ViewModel注入集成
- [ ] Task 8.1.7: [进阶]自定义Component
- [ ] 🔥 Task 8.1.8: Module模块设计
- [ ] Task 8.1.9: [进阶]条件依赖注入
- [ ] Task 8.1.10: 循环依赖解决
- [ ] Task 8.1.11: [进阶]编译时验证
- [ ] Task 8.1.12: 测试配置设计
- [ ] Task 8.1.13: [进阶]性能优化分析
- [ ] Task 8.1.14: 多模块DI架构
- [ ] Task 8.1.15: 企业级DI架构设计 - "技术领导力"
- [ ] 🔥 Task 8.1.16: DI架构面试准备
- [ ] Task 8.1.17: DI最佳实践总结

### 8.2 ⭐⭐⭐⭐⭐ [Week 1-2: 模块化架构]

- [ ] 🔥 Task 8.2.1: 模块化架构原理 - "积木搭建法"
- [ ] 🔥 Task 8.2.2: 模块分层策略 - "楼层规划"
- [ ] Task 8.2.3: Gradle模块配置
- [ ] Task 8.2.4: [进阶]依赖管理策略
- [ ] 🔥 Task 8.2.5: 核心模块设计
- [ ] 🔥 Task 8.2.6: Feature模块实现
- [ ] Task 8.2.7: [进阶]模块间通信机制
- [ ] Task 8.2.8: 导航架构设计
- [ ] Task 8.2.9: [进阶]Dynamic Feature实现
- [ ] Task 8.2.10: 构建优化配置
- [ ] Task 8.2.11: [进阶]构建缓存策略
- [ ] Task 8.2.12: 代码共享策略
- [ ] Task 8.2.13: [进阶]模块解耦技术
- [ ] Task 8.2.14: 版本管理策略
- [ ] Task 8.2.15: 企业级模块化治理 - "技术组织架构"
- [ ] Task 8.2.16: 模块化测试策略
- [ ] 🔥 Task 8.2.17: 模块化架构面试准备

---

# 🔥 Week 3-4: Kotlin协程原理深度探索
*目标：成为协程原理专家，理解异步编程本质*

## 协程底层机制与原理深度

### 协程调度器与线程模型 ⭐⭐⭐⭐⭐ [Week 3-4: 协程原理]

- [ ] 🔥 Task 协程.1: 协程vs线程本质区别 - "轻量级线程"真相
- [ ] 🔥 Task 协程.2: 协程调度器原理 - Dispatchers底层实现
- [ ] 🔥 Task 协程.3: 线程池复用机制 - 协程如何复用线程
- [ ] 🔥 Task 协程.4: 协程上下文切换 - withContext性能分析
- [ ] Task 协程.5: 协程调试与性能监控
- [ ] 🔥 Task 协程.6: 结构化并发原理 - Job树状结构
- [ ] Task 协程.7: 协程取消机制 - Cancellation深度分析
- [ ] Task 协程.8: 协程异常处理 - CoroutineExceptionHandler

### 挂起函数与状态机 ⭐⭐⭐⭐⭐ [Week 3-4: 协程原理]

- [ ] 🔥 Task 协程.9: 挂起函数编译原理 - Continuation状态机
- [ ] 🔥 Task 协程.10: suspend关键字魔法 - 编译器如何处理
- [ ] Task 协程.11: Continuation接口深度分析
- [ ] Task 协程.12: 协程恢复机制 - resumeWith原理
- [ ] 🔥 Task 协程.13: 自定义挂起函数实现
- [ ] Task 协程.14: 协程与回调转换 - suspendCoroutine使用

### Flow响应式编程深度 ⭐⭐⭐⭐⭐ [Week 3-4: 协程原理]

- [ ] 🔥 Task 协程.15: Flow vs RxJava架构对比
- [ ] 🔥 Task 协程.16: Flow冷流特性 - 懒加载机制
- [ ] Task 协程.17: Flow操作符原理 - map/filter/flatMap实现
- [ ] 🔥 Task 协程.18: StateFlow vs LiveData深度对比
- [ ] 🔥 Task 协程.19: SharedFlow广播机制
- [ ] Task 协程.20: 背压处理 - Flow vs RxJava背压策略
- [ ] 🔥 Task 协程.21: Flow性能优化 - conflate/collectLatest
- [ ] Task 协程.22: 自定义Flow操作符实现

## Chapter 3 - 网络编程协程应用

### 3.4 ⭐⭐⭐⭐⭐ [Week 3-4: 响应式编程]

- [ ] 🔥 Task 3.4.1: 响应式编程思想
- [ ] 🔥 Task 3.4.2: Observable vs Observer
- [ ] Task 3.4.3: Subscription订阅机制
- [ ] 🔥 Task 3.4.4: 热流vs冷流
- [ ] Task 3.4.5: 线程调度基础
- [ ] Task 3.4.6: 创建型操作符
- [ ] 🔥 Task 3.4.7: 变换型操作符
- [ ] Task 3.4.8: 过滤型操作符
- [ ] Task 3.4.9: 组合型操作符
- [ ] Task 3.4.10: 错误处理操作符
- [ ] Task 3.4.11: 背压处理
- [ ] 🔥 Task 3.4.12: 网络请求封装
- [ ] Task 3.4.13: UI事件处理
- [ ] Task 3.4.14: 数据库操作响应式
- [ ] Task 3.4.15: 生命周期管理
- [ ] Task 3.4.16: 复杂业务场景实现
- [ ] 🔥 Task 3.4.17: 核心概念问答
- [ ] Task 3.4.18: 实际应用场景
- [ ] 🔥 Task 3.4.19: 对比分析

### 3.2 ⭐⭐⭐⭐ [Week 3-4: OkHttp网络原理]

- [ ] 🔥 Task 3.2.1: 责任链模式理解
- [ ] 🔥 Task 3.2.2: 应用拦截器vs网络拦截器
- [ ] 🔥 Task 3.2.3: 内置拦截器分析
- [ ] 🔥 Task 3.2.4: Chain.proceed()机制
- [ ] Task 3.2.5: 拦截器最佳实践
- [ ] Task 3.2.6: 日志拦截器实现
- [ ] Task 3.2.7: 通用Header拦截器
- [ ] Task 3.2.8: 缓存控制拦截器
- [ ] Task 3.2.9: 重试拦截器实现
- [ ] Task 3.2.10: 请求加密拦截器
- [ ] Task 3.2.11: 拦截器测试验证
- [ ] Task 3.2.12: 动态拦截器管理
- [ ] Task 3.2.13: 网络质量监控拦截器
- [ ] Task 3.2.14: 多环境拦截器
- [ ] Task 3.2.15: 拦截器性能优化
- [ ] 🔥 Task 3.2.16: OkHttp面试准备

---

# 🔥 Week 5-6: Android系统Framework深度
*目标：理解Android底层机制，具备系统级视野*

## Chapter 2 - Android系统核心机制

### 2.1 ⭐⭐⭐⭐⭐ [Week 5-6: ART虚拟机深度]

- [ ] 🔥 Task 2.1.1: Dalvik虚拟机原理 + 编程验证
- [ ] 🔥 Task 2.1.2: ART的AOT编译 + dex2oat工具实现
- [ ] 🔥 Task 2.1.3: 混合编译策略演进
- [ ] Task 2.1.4: 云配置文件机制
- [ ] Task 2.1.5: 编译时机和触发条件
- [ ] Task 2.1.6: APK深度分析工具开发
- [ ] 🔥 Task 2.1.7: OAT文件和编译状态观察
- [ ] Task 2.1.8: 启动性能基准测试实验
- [ ] Task 2.1.9: Perfetto性能追踪实验
- [ ] 🔥 Task 2.1.10: 经典问题准备
- [ ] Task 2.1.11: 深度原理问答
- [ ] Task 2.1.12: 开发实践建议

### 2.2 ⭐⭐⭐⭐⭐ [Week 5-6: Activity启动流程]

- [ ] 🔥 Task 2.2.1: Task和Back Stack概念
- [ ] Task 2.2.2: taskAffinity属性
- [ ] Task 2.2.3: Intent标志位影响
- [ ] Task 2.2.4: 系统任务管理
- [ ] Task 2.2.5: Activity启动模式可视化工具开发
- [ ] 🔥 Task 2.2.6: singleTop模式行为验证
- [ ] 🔥 Task 2.2.7: singleTask清栈机制实验
- [ ] 🔥 Task 2.2.8: singleInstance独占任务栈验证
- [ ] Task 2.2.9: 复杂跳转场景设计
- [ ] 🔥 Task 2.2.10: onNewIntent()处理
- [ ] Task 2.2.11: 导航体验分析
- [ ] Task 2.2.12: 真实应用场景启动模式设计
- [ ] 🔥 Task 2.2.13: 启动模式面试准备

### 2.3 ⭐⭐⭐⭐⭐ [Week 5-6: View渲染系统]

- [ ] 🔥 Task 2.3.1: ViewRootImpl入口分析
- [ ] 🔥 Task 2.3.2: Measure阶段详解
- [ ] 🔥 Task 2.3.3: MeasureSpec机制
- [ ] 🔥 Task 2.3.4: Layout阶段原理
- [ ] 🔥 Task 2.3.5: Draw阶段流程
- [ ] Task 2.3.6: 渲染性能分析自定义View
- [ ] Task 2.3.7: MeasureSpec深度解析实战
- [ ] Task 2.3.8: Canvas绘制性能优化实战
- [ ] Task 2.3.9: 性能优化验证
- [ ] Task 2.3.10: ConstraintLayout对比
- [ ] Task 2.3.11: 渲染触发机制分析实验
- [ ] 🔥 Task 2.3.12: invalidate()绘制更新
- [ ] 🔥 Task 2.3.13: postInvalidate()线程安全
- [ ] 🔥 Task 2.3.14: 渲染面试准备

## Chapter 10 - 系统服务深度

### 10.1 ⭐⭐⭐⭐⭐ [Week 5-6: AMS系统服务]

- [ ] 🔥 Task 10.1.1: AMS职责概览 - 智能城市管理中心的作用
- [ ] 🔥 Task 10.1.2: 系统服务架构 - 城市管理层级结构
- [ ] 🔥 Task 10.1.3: Binder通信基础 - 城市热线电话系统
- [ ] 🔥 Task 10.1.4: Activity栈概念 - 办公楼层的房间管理
- [ ] Task 10.1.5: 进程管理机制 - 城市居民社区管理

### 10.2 ⭐⭐⭐⭐⭐ [Week 5-6: View系统深度]

- [ ] 🔥 Task 10.2.1: View树结构理解
- [ ] Task 10.2.2: 三大流程概览
- [ ] Task 10.2.3: MeasureSpec机制
- [ ] Task 10.2.4: onMeasure实现分析
- [ ] Task 10.2.5: Layout布局机制
- [ ] Task 10.2.6: Draw绘制优化
- [ ] Task 10.2.7: 硬件加速原理
- [ ] 🔥 Task 10.2.8: ViewRootImpl职责
- [ ] Task 10.2.9: 绘制请求处理
- [ ] Task 10.2.10: VSync同步机制
- [ ] Task 10.2.11: 事件分发起点
- [ ] Task 10.2.12: 窗口管理交互
- [ ] Task 10.2.13: 性能监控集成
- [ ] Task 10.2.14: Surface概念理解
- [ ] Task 10.2.15: 图层合成原理
- [ ] Task 10.2.16: GPU渲染管线
- [ ] Task 10.2.17: 显示刷新率优化
- [ ] Task 10.2.18: 卡顿分析与优化
- [ ] Task 10.2.19: 输入系统架构
- [ ] Task 10.2.20: 事件分发机制
- [ ] Task 10.2.21: 多点触控处理
- [ ] Task 10.2.22: 输入延迟优化
- [ ] 🔥 Task 10.2.23: View系统核心问题
- [ ] Task 10.2.24: 渲染性能优化
- [ ] Task 10.2.25: 显示系统设计思考

### 10.3 ⭐⭐⭐⭐⭐ [Week 5-6: Binder通信机制]

- [ ] 🔥 Task 10.3.1: IPC通信背景
- [ ] 🔥 Task 10.3.2: Binder基本概念
- [ ] 🔥 Task 10.3.3: 一次拷贝原理
- [ ] 🔥 Task 10.3.4: Binder驱动机制
- [ ] Task 10.3.5: 引用计数管理
- [ ] Task 10.3.6: 死亡通知机制
- [ ] Task 10.3.7: ServiceManager职责
- [ ] Task 10.3.8: 服务注册流程
- [ ] Task 10.3.9: 服务查找机制
- [ ] Task 10.3.10: 权限控制机制
- [ ] Task 10.3.11: 服务监控与管理
- [ ] Task 10.3.12: AIDL语法基础
- [ ] Task 10.3.13: 编译生成代码分析
- [ ] Task 10.3.14: Stub端实现机制
- [ ] Task 10.3.15: Proxy端调用机制
- [ ] Task 10.3.16: 异常处理与超时
- [ ] Task 10.3.17: 性能优化实践
- [ ] Task 10.3.18: IPC需求分析
- [ ] Task 10.3.19: 协议设计实现
- [ ] Task 10.3.20: 安全机制设计
- [ ] Task 10.3.21: 性能测试与优化
- [ ] 🔥 Task 10.3.22: Binder核心问题
- [ ] Task 10.3.23: 跨进程优化策略
- [ ] 🔥 Task 10.3.24: Binder设计哲学

---

# 🔥 Week 7-8: 性能优化实战 + 面试冲刺
*目标：掌握高级性能优化，完成面试准备*

## Chapter 4 - 性能优化实战

### 4.1 ⭐⭐⭐⭐⭐ [Week 7-8: ANR深度分析]

- [ ] 🔥 Task 4.1.1: ANR定义和触发条件
- [ ] 🔥 Task 4.1.2: ANR根本原因分类
- [ ] Task 4.1.3: Android Vitals监控
- [ ] 🔥 Task 4.1.4: 主线程阻塞机制
- [ ] Task 4.1.5: ANR与UI渲染关系
- [ ] 🔥 Task 4.1.6: traces.txt文件结构
- [ ] 🔥 Task 4.1.7: 主线程状态分析
- [ ] Task 4.1.8: 锁竞争分析方法
- [ ] Task 4.1.9: 系统负载分析
- [ ] Task 4.1.10: 第三方组件ANR
- [ ] Task 4.1.11: 创建ANR测试应用
- [ ] 🔥 Task 4.1.12: 主线程耗时操作ANR
- [ ] Task 4.1.13: 锁竞争ANR复现
- [ ] Task 4.1.14: 死锁ANR复现
- [ ] Task 4.1.15: BroadcastReceiver超时ANR
- [ ] Task 4.1.16: ANR分析工具使用
- [ ] Task 4.1.17: 线上ANR监控方案
- [ ] Task 4.1.18: 预防性编程实践
- [ ] Task 4.1.19: 性能基准测试
- [ ] 🔥 Task 4.1.20: ANR面试准备

### 4.2 ⭐⭐⭐⭐⭐ [Week 7-8: OOM内存优化]

- [ ] 🔥 Task 4.2.1: OOM本质理解
- [ ] 🔥 Task 4.2.2: Android内存模型
- [ ] Task 4.2.3: GC机制与内存回收
- [ ] 🔥 Task 4.2.4: 内存泄漏vs内存溢出
- [ ] Task 4.2.5: 线上OOM特征挖掘
- [ ] 🔥 Task 4.2.6: hprof文件获取
- [ ] 🔥 Task 4.2.7: MAT基本界面和功能
- [ ] Task 4.2.8: Histogram对象分析
- [ ] Task 4.2.9: Dominator Tree支配关系
- [ ] Task 4.2.10: GC Roots路径分析
- [ ] Task 4.2.11: MAT高级功能
- [ ] 🔥 Task 4.2.12: Handler内存泄漏复现
- [ ] Task 4.2.13: 静态变量内存泄漏
- [ ] Task 4.2.14: 线程内存泄漏
- [ ] Task 4.2.15: 监听器未注销泄漏
- [ ] Task 4.2.16: 资源未关闭泄漏
- [ ] Task 4.2.17: 内存泄漏解决方案
- [ ] Task 4.2.18: 图片内存优化
- [ ] Task 4.2.19: 集合类内存优化
- [ ] Task 4.2.20: 内存监控系统
- [ ] Task 4.2.21: 大对象检测
- [ ] 🔥 Task 4.2.22: OOM面试准备

## Chapter 6 - 测试与工程化

### 6.1 ⭐⭐⭐⭐ [Week 7-8: 单元测试]

- [ ] 🔥 Task 6.1.1: 测试金字塔理论
- [ ] 🔥 Task 6.1.2: JUnit 5核心注解
- [ ] Task 6.1.3: 断言方法详解
- [ ] 🔥 Task 6.1.4: Mockito基础概念
- [ ] Task 6.1.5: when-thenReturn基础
- [ ] Task 6.1.6: verify验证机制
- [ ] Task 6.1.7: ArgumentCaptor使用
- [ ] 🔥 Task 6.1.8: Repository单元测试
- [ ] 🔥 Task 6.1.9: ViewModel单元测试
- [ ] Task 6.1.10: MockK基础使用
- [ ] Task 6.1.11: object模拟
- [ ] Task 6.1.12: 扩展函数测试
- [ ] Task 6.1.13: 依赖注入测试设计
- [ ] Task 6.1.14: Test Double应用场景
- [ ] Task 6.1.15: 单元测试最佳实践
- [ ] 🔥 Task 6.1.16: 单元测试面试准备
- [ ] Task 6.1.17: 单元测试阶段总结

### 6.2 ⭐⭐⭐⭐ [Week 7-8: 协程测试]

- [ ] Task 6.2.1: 协程测试挑战分析
- [ ] 🔥 Task 6.2.2: runTest基础用法
- [ ] Task 6.2.3: TestDispatcher配置
- [ ] Task 6.2.4: 时间控制机制
- [ ] 🔥 Task 6.2.5: 挂起函数测试
- [ ] Task 6.2.6: Flow基础测试
- [ ] Task 6.2.7: StateFlow测试
- [ ] Task 6.2.8: SharedFlow测试
- [ ] Task 6.2.9: 复杂Flow操作测试
- [ ] Task 6.2.10: 协程取消测试
- [ ] Task 6.2.11: 异常处理测试
- [ ] Task 6.2.12: ViewModel协程测试
- [ ] Task 6.2.13: Repository协程测试
- [ ] Task 6.2.14: 并发协程测试
- [ ] Task 6.2.15: 协程测试库设计原理
- [ ] Task 6.2.16: 协程测试最佳实践
- [ ] 🔥 Task 6.2.17: 协程测试面试准备

## Chapter 12 - 网络与基础补强

### 12.1 ⭐⭐⭐⭐ [Week 7-8: HTTP网络基础]

- [ ] 🔥 Task 12.1.1: HTTP协议就像寄信
- [ ] 🔥 Task 12.1.2: HTTP状态码像快递状态
- [ ] 🔥 Task 12.1.3: 持久连接像专线电话
- [ ] 🔥 Task 12.1.4: HTTP缓存像家里的储藏室
- [ ] Task 12.1.5: 实现智能缓存系统
- [ ] 🔥 Task 12.1.6: HTTPS像银行的安全协议
- [ ] Task 12.1.7: 证书固定防伪造
- [ ] Task 12.1.8: HTTP/2像高速公路多车道
- [ ] Task 12.1.9: HTTP/2 Server Push与优先级
- [ ] Task 12.1.10: [测试]HTTP/2性能对比实验
- [ ] Task 12.1.11: HTTP/3与QUIC协议原理
- [ ] Task 12.1.12: [高级]移动网络适配策略
- [ ] Task 12.1.13: [实践]网络层架构设计
- [ ] 🔥 Task 12.1.14: [面试]HTTP协议综合应用
- [ ] Task 12.1.15: 全球CDN系统架构设计
- [ ] Task 12.1.16: [进阶]Web Performance API集成
- [ ] Task 12.1.17: HTTP协议知识体系集成

### 12.2 ⭐⭐⭐⭐ [Week 7-8: TCP网络原理]

- [ ] 🔥 Task 12.2.1: TCP像有保障的电话服务
- [ ] 🔥 Task 12.2.2: 三次握手像约会确认
- [ ] 🔥 Task 12.2.3: TCP四次挥手与连接关闭
- [ ] Task 12.2.4: TCP拥塞控制算法
- [ ] Task 12.2.5: TCP Socket编程实战
- [ ] Task 12.2.6: 移动网络特性分析
- [ ] Task 12.2.7: [实践]长连接保活机制
- [ ] Task 12.2.8: 网络切换处理策略
- [ ] Task 12.2.9: UDP协议特性与应用场景
- [ ] Task 12.2.10: [实践]UDP实时通信实现
- [ ] Task 12.2.11: 网络延迟优化策略
- [ ] Task 12.2.12: [高级]网络质量检测与适配
- [ ] Task 12.2.13: [设计]IM应用网络架构
- [ ] Task 12.2.14: 网络安全与防护
- [ ] Task 12.2.15: [测试]网络层压力测试
- [ ] 🔥 Task 12.2.16: [面试]网络编程综合应用
- [ ] Task 12.2.17: [总结]网络编程知识体系

## Chapter 11 - 设计模式精华

### 11.1-11.4 ⭐⭐⭐ [Week 7-8: 设计模式快速补强]

- [ ] 🔥 Task 11.1.1: Singleton基础概念 - 为什么只能有一个国家主席
- [ ] 🔥 Task 11.1.2: 饿汉式vs懒汉式 - 积极型与慢热型的主席
- [ ] 🔥 Task 11.1.3: 线程安全问题 - 防止"多个主席同时上任"的问题
- [ ] Task 11.1.4: 双重检查锁定实现 - 智能的"安全检查站"
- [ ] 🔥 Task 11.2.1: Adapter基础概念
- [ ] Task 11.2.2: 对象适配器实现
- [ ] 🔥 Task 11.2.4: RecyclerView.Adapter深度分析
- [ ] 🔥 Task 11.2.7: Decorator基础实现
- [ ] 🔥 Task 11.2.9: OkHttp拦截器分析
- [ ] Task 11.2.12: Facade基础设计
- [ ] 🔥 Task 11.3.1: Observer基础概念
- [ ] 🔥 Task 11.3.2: 经典Observer实现
- [ ] 🔥 Task 11.3.5: LiveData模式分析
- [ ] 🔥 Task 11.3.7: Strategy基础实现
- [ ] Task 11.3.12: Command基础实现
- [ ] 🔥 Task 11.4.1: MVC模式理解
- [ ] 🔥 Task 11.4.5: MVP基础架构
- [ ] 🔥 Task 11.4.10: MVVM核心理念
- [ ] 🔥 Task 11.4.20: 四种模式对比分析
- [ ] 🔥 Task 11.4.24: 架构面试问题

---


---

# 备战面试

## ✅ 面试前最后检查清单 (8周学习成果验收)

### 🔥 Week 1-2 成果检查：现代Android技术栈

**Jetpack Compose 掌握度检查**
- [ ] 能用白板画出Compose重组机制原理图
- [ ] 能解释声明式UI vs 命令式UI的本质区别
- [ ] 能现场编写一个包含状态管理的复杂Composable组件
- [ ] 能详细说明LaunchedEffect、DisposableEffect的使用场景
- [ ] 能对比Compose与传统View系统的性能差异

**Hilt依赖注入深度理解**
- [ ] 能画出Hilt的作用域层次结构图
- [ ] 能解释@Singleton、@ActivityScoped等注解的生命周期
- [ ] 能现场设计一个多模块项目的DI架构
- [ ] 能说明Hilt vs Dagger的核心差异和选择理由
- [ ] 能解决循环依赖和条件注入等复杂场景

### 🔥 Week 3-4 成果检查：协程原理专家

**协程底层机制理解**
- [ ] 能详细解释协程vs线程的本质区别（内存占用、切换开销）
- [ ] 能画出协程调度器的工作原理图
- [ ] 能解释suspend函数的状态机编译原理
- [ ] 能说明Continuation接口的作用和实现机制
- [ ] 能对比不同Dispatcher的使用场景和性能特点

**Flow响应式编程专精**
- [ ] 能对比Flow vs RxJava的架构差异和性能优势
- [ ] 能解释冷流vs热流的区别和适用场景
- [ ] 能现场实现自定义Flow操作符
- [ ] 能说明StateFlow vs LiveData的技术选择标准
- [ ] 能解决复杂的背压和异常处理场景

### 🔥 Week 5-6 成果检查：Android系统Framework深度

**ART虚拟机系统级理解**
- [ ] 能解释Dalvik vs ART的核心差异和演进原因
- [ ] 能说明AOT vs JIT编译的优缺点和混合策略
- [ ] 能分析dex2oat编译过程和OAT文件结构
- [ ] 能解释ART内存管理和GC机制的改进
- [ ] 能分析应用启动过程中的虚拟机加载流程

**Binder通信机制专精**
- [ ] 能画出Binder通信的完整架构图
- [ ] 能解释"一次拷贝"的技术原理和性能优势
- [ ] 能分析AIDL生成代码的Stub/Proxy实现机制
- [ ] 能说明ServiceManager的作用和服务注册流程
- [ ] 能设计跨进程通信的安全和性能优化方案

**Activity启动与View渲染深度**
- [ ] 能详细描述Activity启动的完整流程（从Intent到onCreate）
- [ ] 能解释四种启动模式的底层实现和任务栈管理
- [ ] 能画出View的三大流程（Measure/Layout/Draw）执行图
- [ ] 能分析ViewRootImpl的作用和渲染优化机制
- [ ] 能说明硬件加速和GPU渲染管线的工作原理

### 🔥 Week 7-8 成果检查：性能优化实战专家

**ANR问题解决专家**
- [ ] 能分析traces.txt文件，快速定位ANR根本原因
- [ ] 能区分不同类型ANR（主线程阻塞、锁竞争、死锁等）
- [ ] 能设计ANR监控和预警系统
- [ ] 准备2-3个真实的ANR线上问题解决案例
- [ ] 能提出针对性的ANR预防编程规范

**OOM内存优化专家**
- [ ] 能熟练使用MAT分析hprof文件，定位内存泄漏
- [ ] 能解释Android内存模型和GC机制的演进
- [ ] 能识别和解决各种内存泄漏模式（Handler、静态变量、监听器等）
- [ ] 准备2-3个内存优化的具体案例和效果数据
- [ ] 能设计内存监控和大对象检测方案

**测试与工程化技能**
- [ ] 能设计完整的测试金字塔策略
- [ ] 能编写Repository、ViewModel的单元测试
- [ ] 能测试协程和Flow的异步逻辑
- [ ] 能解释CI/CD流水线的设计原理
- [ ] 能说明代码质量管理和自动化测试的最佳实践

**计算机基础补强验收**
- [ ] 能解释HTTP协议的工作原理和缓存策略
- [ ] 能说明TCP三次握手和四次挥手的详细过程
- [ ] 能对比HTTP/1.1、HTTP/2、HTTP/3的技术演进
- [ ] 能解释常用设计模式在Android中的应用场景
- [ ] 能分析单例、观察者、适配器等模式的实现原理

---

## 🎯 面试实战准备检查

### 📋 技术深度问答准备

**准备回答这些高级问题：**
- [ ] "Compose的重组机制是如何工作的？如何优化重组性能？"
- [ ] "协程的suspend函数是如何实现的？编译器做了什么？"
- [ ] "Binder为什么只需要一次拷贝？与传统IPC有什么区别？"
- [ ] "ART的AOT编译有什么优势？为什么还需要JIT？"
- [ ] "如何分析和解决复杂的ANR问题？有哪些监控手段？"
- [ ] "Hilt的作用域是如何管理的？如何解决循环依赖？"
- [ ] "Flow和RxJava在架构上有什么本质区别？"
- [ ] "Android的内存管理机制是怎样的？如何优化内存使用？"

### 🚀 项目经验整理

**准备3-5个技术亮点项目：**
- [ ] **性能优化项目**: ANR/OOM问题解决，具体数据和效果
- [ ] **架构升级项目**: 从传统架构到现代MAD架构的迁移
- [ ] **技术难点攻克**: 复杂业务场景的技术方案设计
- [ ] **工程化改进**: CI/CD、测试覆盖率提升等
- [ ] **新技术应用**: Compose、Hilt等现代技术的落地实践

### 💡 软技能准备

**技术领导力展示：**
- [ ] 准备技术调研和选型的决策过程案例
- [ ] 准备跨团队协作和技术推广的经验
- [ ] 准备code review和团队技术提升的实践
- [ ] 准备技术债务治理和重构的策略思考
- [ ] 准备对新技术趋势的理解和学习能力展示

### 🎪 模拟面试验收

**最后冲刺练习：**
- [ ] 完成至少3轮完整的技术面试模拟
- [ ] 练习在白板上画架构图和流程图
- [ ] 练习现场coding（数据结构、算法、Android组件）
- [ ] 练习system design（设计一个千万用户的Android应用）
- [ ] 准备"为什么选择我们公司"和职业规划问题

---

## 🏆 最终目标验收

**达到这个水平，你就准备好了：**
- ✅ **现代Android专家**: 熟练掌握Compose、Hilt、协程等MAD技术栈
- ✅ **系统原理专家**: 深度理解ART、Binder、Framework等底层机制  
- ✅ **性能优化专家**: 具备解决复杂ANR/OOM问题的实战能力
- ✅ **架构设计能力**: 能设计大型项目的技术架构和演进方案
- ✅ **工程化思维**: 具备现代软件开发的完整技能栈

**🎉 预期结果**: 成功获得高级Android开发(L4/L5)岗位offer，年薪提升30-50%！


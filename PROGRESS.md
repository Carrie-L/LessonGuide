# Android Interview Mastery - Learning Progress

## 学习目标 (Learning Objectives)
通过理论学习 + 实践编码 + 面试模拟的方式，深度掌握Android面试核心知识点，最终通过技术面试。

## 第一章：基石篇 - Java & Kotlin 语言精要

### 1.1 并发原语：synchronized, volatile 与 JMM
- [ ] **理论学习**: 理解JMM、happens-before原则
- [ ] **编码实践**: 
  - [ ] 分析Java内存模型（JMM）和happens-before
  - [ ] 实现无锁数据结构（CAS、原子类）
  - [ ] 实现synchronized锁升级演示代码
  - [ ] 编写volatile可见性验证程序
  - [ ] 对比synchronized vs volatile在不同场景下的表现
  - [ ] 理解volatile和synchronized的底层实现
  - [ ] 分析协程与线程的调度差异
- [ ] **面试模拟**: 回答经典问题并接受追问
- [ ] **面试模拟**: 设计高并发的数据处理系统
- [ ] **深度理解**: 能够从JVM底层解释原理
- [ ] **深度理解**: 理解并发编程的本质挑战和解决方案

### 1.2 主力集合：HashMap & ConcurrentHashMap 源码剖析
- [ ] **理论学习**: HashMap 1.7 vs 1.8演进、ConcurrentHashMap分段锁到CAS+synchronized
- [ ] **编码实践**:
  - [ ] 手写简化版HashMap（数组+链表+红黑树转换）
  - [ ] 实现线程安全的Map操作对比测试
  - [ ] 分析hashCode分布对性能的影响
- [ ] **面试模拟**: 白板画出HashMap结构，解释put/get流程
- [ ] **深度理解**: 能够解释容量为2的幂次方的设计原理

### 1.3 现代范式：Kotlin 协程
- [ ] **理论学习**: 协程 vs 线程、挂起机制、结构化并发
- [ ] **编码实践**:
  - [ ] 实现协程版网络请求对比回调版本
  - [ ] 使用不同Dispatcher进行线程切换练习
  - [ ] 实践协程取消和异常处理
- [ ] **面试模拟**: 解释suspend关键字底层实现
- [ ] **深度理解**: 理解协程状态机编译原理

## 第二章：支柱篇 - 解构安卓框架内核

### 2.1 运行时引擎：ART 的混合编译模式
- [ ] **理论学习**: Dalvik vs ART、AOT vs JIT、混合编译策略
  - [ ] Phase 15: ART vs Dalvik基础
  - [ ] Phase 16: 性能分析实践
  - [ ] Phase 17: ART面试准备
- [ ] **面试模拟**: 解释Profile-guided AOT的工作原理
- [ ] **深度理解**: 理解云配置文件对性能优化的意义

### 2.2 四大组件深度：Activity 启动模式
- [ ] **编码实践**:
  - [ ] 创建Demo应用演示四种启动模式
  - [ ] 实现复杂的页面跳转场景
  - [ ] 验证onNewIntent()的调用时机
- [ ] **理论学习**: 任务栈、四种启动模式、taskAffinity
  - [ ] Phase 18: 任务栈基础理念
  - [ ] Phase 19: 四种启动模式实战
  - [ ] Phase 20: 用户体验考量
- [ ] **面试模拟**: 设计singleTask和singleTop的应用场景
- [ ] **深度理解**: 从用户体验角度思考启动模式选择

### 2.3 UI 渲染管线：Measure, Layout, Draw
- [ ] **理论学习**: 渲染三部曲、MeasureSpec、ViewRootImpl
  - [ ] Phase 21: 渲染流程基础
  - [ ] Phase 22: 自定义View实战
  - [ ] Phase 23: 渲染优化实践
- [ ] **编码实践**:
  - [ ] 自定义View实现onMeasure逻辑
  - [ ] 分析布局嵌套对性能的影响
  - [ ] 使用Layout Inspector观察渲染过程
- [ ] **面试模拟**: 解释wrap_content的测量原理
- [ ] **深度理解**: 理解ConstraintLayout优化原理

### 2.4 事件分发机制
- [ ] **理论学习**: 三大核心方法、责任链模式、事件流向
  - [ ] Phase 24: 事件分发基础
  - [ ] Phase 25: 事件流追踪实战
  - [ ] Phase 26: 高级事件处理
- [ ] **编码实践**:
  - [ ] 实现复杂的滑动冲突解决方案
  - [ ] 自定义ViewGroup处理事件拦截
  - [ ] 验证事件消费对后续事件的影响
- [ ] **面试模拟**: 追踪一个触摸事件的完整流程
- [ ] **深度理解**: 解决实际项目中的滑动冲突问题

### 2.5 异步心跳：Handler, Looper, MessageQueue
- [ ] **理论学习**: 消息循环机制、线程间通信、内存泄漏
  - [ ] Phase 27: 消息机制基础
  - [ ] Phase 28: 主线程Looper原理
  - [ ] Phase 29: 子线程Handler实践
  - [ ] Phase 30: Handler高级应用
- [ ] **编码实践**:
  - [ ] 在子线程中创建Handler和Looper
  - [ ] 实现线程安全的消息传递机制
  - [ ] 分析和解决Handler内存泄漏
- [ ] **面试模拟**: 解释Looper.loop()不卡死主线程的原理
- [ ] **深度理解**: 理解epoll机制和ANR产生原理

### 2.6 通信骨干：Binder IPC
- [ ] **理论学习**: Binder原理、一次拷贝、mmap机制
  - [ ] Phase 31: Binder基础原理
  - [ ] Phase 32: AIDL实战开发
  - [ ] Phase 33: Binder深度原理
- [ ] **编码实践**:
  - [ ] 使用AIDL实现跨进程通信
  - [ ] 分析Binder通信的性能特点
  - [ ] 实现进程间的大数据传输
- [ ] **面试模拟**: 对比Binder与传统IPC的优势
- [ ] **深度理解**: 理解Binder在Android安全模型中的作用

### 第二章学习检查点汇总
  - [ ] 2.1 ART运行时检查问题
  - [ ] 2.2 Activity启动模式检查问题
  - [ ] 2.3 UI渲染检查问题
  - [ ] 2.4 事件分发检查问题
  - [ ] 2.5 Handler机制检查问题
  - [ ] 2.6 Binder IPC检查问题

  - [ ] 面试重点突破 - 事件分发机制核心问答
  - [ ] 实战项目成果展示

## 第三章：蓝图篇 - 高级架构与三方库原理

### 3.1 架构演进之旅：从MVC到Clean Architecture
- [ ] **理论学习**: 各种架构模式对比、适用场景、优缺点
  - [ ] Phase 34: 架构基础理解 - 30分钟
  - [ ] Phase 35: 实战架构对比实现 (35分钟总计)
  - [ ] Phase 36: 架构面试准备 (15分钟总计)
- [ ] **编码实践**:
  - [ ] 用不同架构模式实现同一个功能
  - [ ] 对比MVVM和MVI在复杂场景下的表现
  - [ ] 实现Clean Architecture的分层结构
- [ ] **面试模拟**: 解释架构选型的决策依据
- [ ] **深度理解**: 理解单向数据流的核心价值

### 3.2 网络利器 OkHttp：拦截器责任链
- [ ] **理论学习**: 拦截器机制、责任链模式、两种拦截器区别
  - [ ] Phase 37: 拦截器机制基础 (25分钟总计)
  - [ ] Phase 38: 自定义拦截器实战 (30分钟总计)
  - [ ] Phase 39: 高级拦截器应用 (25分钟总计)
- [ ] **编码实践**:
  - [ ] 实现自定义拦截器（日志、缓存、重试）
  - [ ] 分析默认拦截器的执行顺序
  - [ ] 实现全局请求加密/解密功能
- [ ] **面试模拟**: 设计网络框架的扩展机制
- [ ] **深度理解**: 理解责任链模式在框架设计中的价值

### 3.3 图片加载 Glide：多级缓存策略
- [ ] **理论学习**: 多级缓存、LruCache、DiskLruCache、Bitmap复用
  - [ ] Phase 40: 缓存策略基础 - 25分钟
  - [ ] Phase 41: Bitmap内存管理 (25分钟总计)
  - [ ] Phase 42: 自定义图片加载框架 (30分钟总计)
  - [ ] Phase 43: 图片加载面试准备 (15分钟总计)
- [ ] **编码实践**:
  - [ ] 实现简化版的图片缓存框架
  - [ ] 分析不同缓存策略对内存的影响
  - [ ] 优化图片加载的内存使用
- [ ] **面试模拟**: 设计图片加载框架的缓存策略
- [ ] **深度理解**: 理解Bitmap内存管理和复用机制

### 3.4 响应式编程 RxJava：Observable操作符
- [ ] **理论学习**: 响应式编程思想、Observable vs Observer、操作符链
  - [ ] Phase 44: 响应式思维基础 - 25分钟
  - [ ] Phase 45: 核心操作符实战 (30分钟总计)
  - [ ] Phase 46: Android集成应用 (25分钟总计)
  - [ ] Phase 47: RxJava面试准备 (15分钟总计)
- [ ] **编码实践**:
  - [ ] 实现网络请求的响应式封装
  - [ ] 使用操作符处理复杂的数据流转换
  - [ ] 集成RxJava到Android项目中
- [ ] **面试模拟**: 解释响应式编程在Android中的优势
- [ ] **深度理解**: 理解函数式编程和响应式编程的核心思想

## 第四章：淬炼篇 - 线上性能与稳定性实战

### 4.1 ANR 诊断与修复
- [ ] **理论学习**: ANR原因、监控方法、traces.txt分析
  - [ ] Phase 48: ANR基础理论 (25分钟总计)
  - [ ] Phase 49: traces.txt分析技巧 (25分钟总计)
  - [ ] Phase 50: ANR实战演练 (30分钟总计)
  - [ ] Phase 51: ANR监控与预防 (20分钟总计)
- [ ] **实践演练**:
  - [ ] 制造和分析不同类型的ANR
  - [ ] 使用Android Vitals监控ANR
  - [ ] 实现ANR监控和预警机制
- [ ] **面试模拟**: 分析实际的ANR案例
- [ ] **深度理解**: 建立ANR问题的完整解决方案

### 4.2 OOM 追猎与内存优化
- [ ] **理论学习**: 内存模型、OOM原因、MAT工具使用
  - [ ] Phase 52: OOM基础原理 (25分钟总计)
  - [ ] Phase 53: MAT工具精通 (30分钟总计)
  - [ ] Phase 54: 常见内存泄漏实战 (30分钟总计)
  - [ ] Phase 55: 内存优化实践 (25分钟总计)
- [ ] **实践演练**:
  - [ ] 制造和分析内存泄漏
  - [ ] 使用MAT分析hprof文件
  - [ ] 实现内存监控和优化方案
- [ ] **面试模拟**: 分析复杂的OOM场景
- [ ] **深度理解**: 建立内存问题的系统性解决方法

### 4.3 APK 打包与安装流程
- [ ] **理论学习**: 构建流程、签名机制、APK优化
  - [ ] Phase 56: 构建流程深度解析 (25分钟总计)
  - [ ] Phase 57: 签名机制演进 (25分钟总计)
  - [ ] Phase 58: 体积优化策略 (25分钟总计)
  - [ ] Phase 59: 构建优化实战 (15分钟总计)
- [ ] **实践演练**:
  - [ ] 分析APK构建的各个阶段
  - [ ] 实现APK体积优化方案
  - [ ] 配置不同的签名策略
- [ ] **面试模拟**: 解释R8优化原理
- [ ] **深度理解**: 理解构建优化对开发效率的影响

## 第五章：地平线 - 掌握现代安卓UI

### 5.1 Jetpack Compose 核心思想
- [ ] **理论学习**: 声明式UI、组合与重组、状态管理
  - [ ] Phase 60: 声明式UI基础理念 (25分钟总计)
  - [ ] Phase 61: 组合与重组深入 (30分钟总计)
  - [ ] Phase 62: 现代UI组件实战 (25分钟总计)
- [ ] **编码实践**:
  - [ ] 实现复杂的Compose UI组件
  - [ ] 优化重组性能
  - [ ] 对比Compose vs 传统View的开发体验
- [ ] **面试模拟**: 解释Compose的重组机制
- [ ] **深度理解**: 理解声明式UI范式的核心价值

### 5.2 Compose 中的状态管理：状态提升
- [ ] **理论学习**: 状态提升、单向数据流、副作用处理
  - [ ] Phase 63: 状态提升模式 (25分钟总计)
  - [ ] Phase 64: 副作用处理 (30分钟总计)
  - [ ] Phase 65: ViewModel集成 (25分钟总计)
  - [ ] Phase 66: 高级状态管理实战 (20分钟总计)
- [ ] **编码实践**:
  - [ ] 实现复杂的状态管理场景
  - [ ] 处理各种副作用（LaunchedEffect, DisposableEffect）
  - [ ] 集成ViewModel和Compose
- [ ] **面试模拟**: 设计Compose应用的状态架构
- [ ] **深度理解**: 理解状态管理在现代UI开发中的重要性

## 第六章：测试利刃 - Android 测试体系精通

### 6.1 单元测试基石：JUnit & Mockito
- [ ] **理论学习**: 测试金字塔、单元测试原则、Mock vs Spy vs Stub
- [ ] **编码实践**:
  - [ ] 使用JUnit 5编写各种类型的单元测试
  - [ ] 掌握Mockito核心API（when-thenReturn, verify, ArgumentCaptor）
  - [ ] 实现Repository/ViewModel的单元测试
  - [ ] 使用MockK测试Kotlin代码（object mock, extension functions）
- [ ] **面试模拟**: 解释Test Double的不同类型和应用场景
- [ ] **深度理解**: 理解可测试代码设计原则和依赖注入

### 6.2 协程测试：TestCoroutineDispatcher & runTest
- [ ] **理论学习**: 协程测试挑战、测试时间控制、异步代码测试策略
- [ ] **编码实践**:
  - [ ] 使用runTest和TestDispatcher测试挂起函数
  - [ ] 测试Flow和StateFlow的数据流
  - [ ] 验证协程的取消和异常处理
  - [ ] 实现ViewModel中协程逻辑的测试
- [ ] **面试模拟**: 解释如何测试复杂的异步操作
- [ ] **深度理解**: 理解协程测试库的设计原理

### 6.3 UI测试：Espresso & Compose Testing
- [ ] **理论学习**: UI测试策略、页面对象模式、测试稳定性
- [ ] **编码实践**:
  - [ ] 使用Espresso编写Activity/Fragment测试
  - [ ] 实现Compose UI的测试（ComposeTestRule）
  - [ ] 处理异步UI更新和网络请求
  - [ ] 编写端到端的用户流程测试
- [ ] **面试模拟**: 设计复杂场景的UI测试策略
- [ ] **深度理解**: 理解UI测试的成本收益权衡

### 6.4 集成测试：Robolectric & Hilt Testing
- [ ] **理论学习**: 测试环境隔离、依赖注入测试、Android组件测试
- [ ] **编码实践**:
  - [ ] 使用Robolectric进行JVM上的Android测试
  - [ ] 配置Hilt进行依赖注入测试
  - [ ] 测试数据库操作（Room + 内存数据库）
  - [ ] 实现网络层的集成测试
- [ ] **面试模拟**: 解释不同测试类型的选择策略
- [ ] **深度理解**: 理解测试金字塔在Android中的实际应用

## 第七章：安全防护 - Android 安全与加固

### 7.1 数据安全：加密存储与传输
- [ ] **理论学习**: 对称/非对称加密、Android KeyStore、证书校验
- [ ] **编码实践**:
  - [ ] 使用EncryptedSharedPreferences加密本地数据
  - [ ] 实现数据库加密（SQLCipher + Room）
  - [ ] 配置Certificate Pinning防中间人攻击
  - [ ] 使用Android KeyStore管理密钥
- [ ] **面试模拟**: 设计金融级应用的数据安全方案
- [ ] **深度理解**: 理解Android安全模型和沙箱机制

### 7.2 代码保护：混淆与反调试
- [ ] **理论学习**: ProGuard/R8混淆、反编译防护、动态分析对抗
- [ ] **编码实践**:
  - [ ] 配置多层级代码混淆策略
  - [ ] 实现Root检测和调试器检测
  - [ ] 使用Native层加固关键逻辑
  - [ ] 实现反Hook和反注入机制
- [ ] **面试模拟**: 分析APK逆向工程和防护手段
- [ ] **深度理解**: 理解攻防对抗的技术演进

### 7.3 权限与认证：OAuth2 & 生物识别
- [ ] **理论学习**: Android权限模型、OAuth2流程、生物识别API
- [ ] **编码实践**:
  - [ ] 实现动态权限申请和降级策略
  - [ ] 集成OAuth2认证流程
  - [ ] 使用BiometricPrompt实现指纹/人脸识别
  - [ ] 设计多因子认证方案
- [ ] **面试模拟**: 设计企业级身份认证系统
- [ ] **深度理解**: 理解零信任安全架构

## 第八章：工程效能 - 现代化开发流程

### 8.1 依赖注入：Hilt 深度实践
- [ ] **理论学习**: DI容器原理、作用域管理、编译时验证
- [ ] **编码实践**:
  - [ ] 设计模块化的Hilt架构
  - [ ] 实现不同作用域的依赖管理
  - [ ] 处理复杂的依赖关系和循环依赖
  - [ ] 集成Hilt与测试框架
- [ ] **面试模拟**: 对比Dagger vs Hilt的优劣势
- [ ] **深度理解**: 理解编译时DI vs 运行时DI的权衡

### 8.2 模块化架构：多模块工程
- [ ] **理论学习**: 模块化策略、依赖管理、构建优化
- [ ] **编码实践**:
  - [ ] 设计功能模块和基础模块分层
  - [ ] 实现模块间通信机制
  - [ ] 配置Gradle模块化构建
  - [ ] 实现动态特性模块（Dynamic Feature）
- [ ] **面试模拟**: 设计大型项目的模块化方案
- [ ] **深度理解**: 理解模块化对团队协作的影响

### 8.3 CI/CD 流水线：自动化交付
- [ ] **理论学习**: CI/CD原理、流水线设计、质量门禁
- [ ] **编码实践**:
  - [ ] 配置GitHub Actions/Jenkins构建流水线
  - [ ] 实现自动化测试和代码质量检查
  - [ ] 设置多环境部署策略
  - [ ] 集成Fastlane自动化发布
- [ ] **面试模拟**: 设计企业级Android交付流水线
- [ ] **深度理解**: 理解DevOps在移动开发中的应用

### 8.4 性能监控：APM 与可观测性
- [ ] **理论学习**: APM原理、指标体系、告警策略
- [ ] **编码实践**:
  - [ ] 集成Firebase Performance Monitoring
  - [ ] 实现自定义性能埋点
  - [ ] 配置Crash上报和分析
  - [ ] 建立性能基线和SLA
- [ ] **面试模拟**: 设计线上问题的监控诊断体系
- [ ] **深度理解**: 理解可观测性在移动端的挑战

## 第九章：系统设计 - 移动端架构设计能力

### 9.1 数据层设计：Room + 网络协议选型
- [ ] **理论学习**: 本地数据库设计、REST vs GraphQL vs gRPC选型
- [ ] **设计实践**:
  - [ ] 设计聊天应用的数据库schema（SQLite/Room）
  - [ ] 对比REST和GraphQL在移动端的优劣势
  - [ ] 设计离线优先的数据同步策略
  - [ ] 实现分页加载和缓存策略
- [ ] **面试模拟**: 设计微信级别IM应用的数据架构
- [ ] **深度理解**: 理解移动端数据访问的性能权衡

### 9.2 实时通信：WebSocket + 推送机制
- [ ] **理论学习**: 实时通信协议、长连接管理、消息可靠性
- [ ] **设计实践**:
  - [ ] 设计IM应用的实时消息传输
  - [ ] 实现断线重连和消息重发机制
  - [ ] 设计推送通知的多通道策略
  - [ ] 处理网络切换和弱网环境
- [ ] **面试模拟**: 设计直播间聊天系统
- [ ] **深度理解**: 理解移动网络环境的复杂性

### 9.3 缓存策略：多级缓存 + 数据一致性
- [ ] **理论学习**: 缓存更新策略、一致性保证、缓存穿透防护
- [ ] **设计实践**:
  - [ ] 设计图片应用的多级缓存架构
  - [ ] 实现LRU + LFU混合淘汰策略
  - [ ] 设计缓存预加载和预测机制
  - [ ] 处理缓存与数据库的一致性
- [ ] **面试模拟**: 设计抖音级别短视频APP缓存系统
- [ ] **深度理解**: 理解CAP定理在移动端的应用

### 9.4 大型应用架构：微服务 + 模块化
- [ ] **理论学习**: 移动端微服务、模块间通信、依赖管理
- [ ] **设计实践**:
  - [ ] 设计电商APP的模块化架构
  - [ ] 实现跨模块的事件总线
  - [ ] 设计插件化和热更新机制
  - [ ] 处理模块间的版本兼容性
- [ ] **面试模拟**: 设计支付宝级别超级APP架构
- [ ] **深度理解**: 理解复杂度管理与团队协作的平衡

### 9.5 性能与扩展性：负载均衡 + CDN优化
- [ ] **理论学习**: 移动端性能瓶颈、CDN加速、智能调度
- [ ] **设计实践**:
  - [ ] 设计全球化APP的CDN部署策略
  - [ ] 实现智能网络调度和降级
  - [ ] 设计APP启动时间优化方案
  - [ ] 处理不同地区的网络环境差异
- [ ] **面试模拟**: 设计TikTok全球化架构
- [ ] **深度理解**: 理解用户体验与技术成本的权衡

## 第十章：底层内核 - Android 系统服务深度解析

### 10.1 ActivityManagerService (AMS) 核心机制
- [ ] **理论学习**: AMS架构、Activity栈管理、进程生命周期
- [ ] **源码分析**:
  - [ ] 分析Activity启动流程（Launcher → AMS → App）
  - [ ] 理解Task和ActivityStack的管理机制
  - [ ] 分析OOM_ADJ机制和进程回收策略
  - [ ] 深入理解ANR监控和处理流程
- [ ] **面试模拟**: 从点击图标到Activity显示的完整流程
- [ ] **深度理解**: 理解Android进程管理和内存回收策略

### 10.2 View 系统底层机制
- [ ] **理论学习**: View绘制流程、Touch事件分发、动画原理
- [ ] **源码分析**:
  - [ ] 深入ViewRootImpl的职责和工作机制
  - [ ] 分析Choreographer的VSync同步机制
  - [ ] 理解SurfaceFlinger的合成原理
  - [ ] 分析硬件加速和GPU渲染管线
- [ ] **面试模拟**: 解释16.6ms绘制原理和卡顿产生机制
- [ ] **深度理解**: 理解Android显示系统的完整架构

### 10.3 Binder 深度原理与实现
- [ ] **理论学习**: Binder驱动、Client-Server架构、死亡通知
- [ ] **源码分析**:
  - [ ] 分析Binder驱动在内核层的实现
  - [ ] 理解mmap共享内存机制
  - [ ] 分析ServiceManager的作用和实现
  - [ ] 深入AIDL编译生成的代码结构
- [ ] **面试模拟**: 设计自己的IPC通信机制
- [ ] **深度理解**: 理解Binder相比传统IPC的革命性优势

### 10.4 PackageManagerService (PMS) 与应用管理
- [ ] **理论学习**: APK安装流程、权限管理、签名校验
- [ ] **源码分析**:
  - [ ] 分析PMS的启动和初始化流程
  - [ ] 理解APK解析和安装验证机制
  - [ ] 分析权限申请和授权流程
  - [ ] 深入理解APK签名和校验原理
- [ ] **面试模拟**: 设计应用商店的安装机制
- [ ] **深度理解**: 理解Android安全模型的核心实现

## 第十一章：设计模式 - 代码设计的艺术

### 11.1 创建型模式：Singleton, Factory, Builder
- [ ] **理论学习**: 对象创建的最佳实践、线程安全、内存优化
- [ ] **编码实践**:
  - [ ] 实现线程安全的Singleton（双重检查锁定）
  - [ ] 设计Abstract Factory处理多平台适配
  - [ ] 使用Builder模式构建复杂配置对象
  - [ ] 在Android中应用这些模式（Application, AlertDialog.Builder）
- [ ] **面试模拟**: 分析Android源码中的设计模式应用
- [ ] **深度理解**: 理解设计模式的本质是职责分离

### 11.2 结构型模式：Adapter, Decorator, Facade
- [ ] **理论学习**: 接口适配、功能增强、复杂度隐藏
- [ ] **编码实践**:
  - [ ] 实现RecyclerView.Adapter的多类型适配
  - [ ] 使用Decorator模式增强OkHttp功能
  - [ ] 设计Facade简化复杂的SDK调用
  - [ ] 应用Proxy模式实现懒加载和缓存
- [ ] **面试模拟**: 重构遗留代码使用合适的结构型模式
- [ ] **深度理解**: 理解如何平衡灵活性和复杂度

### 11.3 行为型模式：Observer, Strategy, Command
- [ ] **理论学习**: 对象间通信、算法封装、操作抽象
- [ ] **编码实践**:
  - [ ] 实现自定义观察者模式（类似LiveData）
  - [ ] 使用Strategy模式处理不同支付方式
  - [ ] 实现Command模式支持撤销/重做功能
  - [ ] 应用State模式管理复杂状态机
- [ ] **面试模拟**: 设计可扩展的业务规则引擎
- [ ] **深度理解**: 理解行为模式如何提高代码的可维护性

### 11.4 Android特有模式：MVC, MVP, MVVM, MVI
- [ ] **理论学习**: 架构模式演进、数据绑定、状态管理
- [ ] **编码实践**:
  - [ ] 用同一功能演示四种架构模式的差异
  - [ ] 分析各种模式的测试便利性
  - [ ] 实现MVI的单向数据流
  - [ ] 对比DataBinding和ViewBinding的应用场景
- [ ] **面试模拟**: 为新项目选择合适的架构模式
- [ ] **深度理解**: 理解架构模式背后的设计哲学

## 第十二章：网络与系统 - 基础设施知识

### 12.1 HTTP协议深度：从1.0到3.0演进
- [ ] **理论学习**: HTTP协议族、HTTPS加密、HTTP/2多路复用、HTTP/3 QUIC
- [ ] **实践分析**:
  - [ ] 分析HTTP请求的完整生命周期
  - [ ] 实现HTTP缓存策略（ETag, Last-Modified, Cache-Control）
  - [ ] 配置HTTPS和证书固定（Certificate Pinning）
  - [ ] 测试HTTP/2 Server Push在移动端的效果
- [ ] **面试模拟**: 设计高性能的移动端网络层
- [ ] **深度理解**: 理解网络协议对移动应用性能的影响

### 12.2 TCP/IP与网络编程
- [ ] **理论学习**: 三次握手、四次挥手、滑动窗口、拥塞控制
- [ ] **实践分析**:
  - [ ] 分析移动网络的特殊性（NAT、防火墙、弱网）
  - [ ] 实现可靠的长连接保活机制
  - [ ] 处理网络切换（WiFi ↔ 移动网络）
  - [ ] 分析和优化网络请求的时延
- [ ] **面试模拟**: 设计IM应用的网络层架构
- [ ] **深度理解**: 理解移动网络环境的复杂性和应对策略

### 12.3 操作系统概念：进程、线程、内存管理
- [ ] **理论学习**: 进程调度、线程同步、虚拟内存、文件系统
- [ ] **实践分析**:
  - [ ] 分析Android的进程管理机制（zygote、app_process）
  - [ ] 理解Linux内存管理（OOM Killer、LMK）
  - [ ] 分析文件权限和SELinux在Android中的应用
  - [ ] 深入理解Context Switch的开销
- [ ] **面试模拟**: 解释Android相比传统Linux的改进
- [ ] **深度理解**: 理解移动操作系统的设计权衡



## 学习方法 (Learning Methodology)
1. **理论先行**: 每个知识点先理解核心概念和原理
2. **实践强化**: 通过编码练习加深理解
3. **面试模拟**: 模拟真实面试场景，练习表达和思路
4. **深度思考**: 理解设计背后的原因和权衡
5. **定期回顾**: 巩固已学知识，形成知识体系

## 当前进度
- [ ] 开始学习旅程
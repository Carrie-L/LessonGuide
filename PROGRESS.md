# Android Interview Mastery - Learning Progress

## 学习目标 (Learning Objectives)
通过理论学习 + 实践编码 + 面试模拟的方式，深度掌握Android面试核心知识点，最终通过技术面试。

## 第一章：基石篇 - Java & Kotlin 语言精要

### 1.1 并发原语：synchronized, volatile 与 JMM
- [ ] **理论学习**: 理解JMM、happens-before原则
- [ ] **编码实践**: 
  - [ ] 实现synchronized锁升级演示代码
  - [ ] 编写volatile可见性验证程序
  - [ ] 对比synchronized vs volatile在不同场景下的表现
- [ ] **面试模拟**: 回答经典问题并接受追问
- [ ] **深度理解**: 能够从JVM底层解释原理

### 1.2 主力集合：HashMap & ConcurrentHashMap 源码剖析
- [ ] **理论学习**: HashMap 1.7 vs 1.8演进、ConcurrentHashMap分段锁到CAS+synchronized
- [ ] **编码实践**:
  - [ ] 手写简化版HashMap（数组+链表+红黑树转换）
  - [ ] 实现线程安全的Map操作对比测试
  - [ ] 分析hashCode分布对性能的影响
- [ ] **面试模拟**: 白板画出HashMap结构，解释put/get流程
- [ ] **深度理解**: 能够解释容量为2的幂次方的设计原理

### 1.3 现代范式：Kotlin 协程
- [ ] **理论学习**: 协程 vs 线程、挂起机制、结构化并发
- [ ] **编码实践**:
  - [ ] 实现协程版网络请求对比回调版本
  - [ ] 使用不同Dispatcher进行线程切换练习
  - [ ] 实践协程取消和异常处理
- [ ] **面试模拟**: 解释suspend关键字底层实现
- [ ] **深度理解**: 理解协程状态机编译原理

## 第二章：支柱篇 - 解构安卓框架内核

### 2.1 运行时引擎：ART 的混合编译模式
- [ ] **理论学习**: Dalvik vs ART、AOT vs JIT、混合编译策略
- [ ] **实践分析**:
  - [ ] 分析APK的DEX和OAT文件
  - [ ] 使用性能分析工具观察编译优化效果
  - [ ] 对比不同编译模式对启动速度的影响
- [ ] **面试模拟**: 解释Profile-guided AOT的工作原理
- [ ] **深度理解**: 理解云配置文件对性能优化的意义

### 2.2 四大组件深度：Activity 启动模式
- [ ] **理论学习**: 任务栈、四种启动模式、taskAffinity
- [ ] **编码实践**:
  - [ ] 创建Demo应用演示四种启动模式
  - [ ] 实现复杂的页面跳转场景
  - [ ] 验证onNewIntent()的调用时机
- [ ] **面试模拟**: 设计singleTask和singleTop的应用场景
- [ ] **深度理解**: 从用户体验角度思考启动模式选择

### 2.3 UI 渲染管线：Measure, Layout, Draw
- [ ] **理论学习**: 渲染三部曲、MeasureSpec、ViewRootImpl
- [ ] **编码实践**:
  - [ ] 自定义View实现onMeasure逻辑
  - [ ] 分析布局嵌套对性能的影响
  - [ ] 使用Layout Inspector观察渲染过程
- [ ] **面试模拟**: 解释wrap_content的测量原理
- [ ] **深度理解**: 理解ConstraintLayout优化原理

### 2.4 事件分发机制
- [ ] **理论学习**: 三大核心方法、责任链模式、事件流向
- [ ] **编码实践**:
  - [ ] 实现复杂的滑动冲突解决方案
  - [ ] 自定义ViewGroup处理事件拦截
  - [ ] 验证事件消费对后续事件的影响
- [ ] **面试模拟**: 追踪一个触摸事件的完整流程
- [ ] **深度理解**: 解决实际项目中的滑动冲突问题

### 2.5 异步心跳：Handler, Looper, MessageQueue
- [ ] **理论学习**: 消息循环机制、线程间通信、内存泄漏
- [ ] **编码实践**:
  - [ ] 在子线程中创建Handler和Looper
  - [ ] 实现线程安全的消息传递机制
  - [ ] 分析和解决Handler内存泄漏
- [ ] **面试模拟**: 解释Looper.loop()不卡死主线程的原理
- [ ] **深度理解**: 理解epoll机制和ANR产生原理

### 2.6 通信骨干：Binder IPC
- [ ] **理论学习**: Binder原理、一次拷贝、mmap机制
- [ ] **编码实践**:
  - [ ] 使用AIDL实现跨进程通信
  - [ ] 分析Binder通信的性能特点
  - [ ] 实现进程间的大数据传输
- [ ] **面试模拟**: 对比Binder与传统IPC的优势
- [ ] **深度理解**: 理解Binder在Android安全模型中的作用

## 第三章：蓝图篇 - 高级架构与三方库原理

### 3.1 架构演进之旅：从MVC到Clean Architecture
- [ ] **理论学习**: 各种架构模式对比、适用场景、优缺点
- [ ] **编码实践**:
  - [ ] 用不同架构模式实现同一个功能
  - [ ] 对比MVVM和MVI在复杂场景下的表现
  - [ ] 实现Clean Architecture的分层结构
- [ ] **面试模拟**: 解释架构选型的决策依据
- [ ] **深度理解**: 理解单向数据流的核心价值

### 3.2 网络利器 OkHttp：拦截器责任链
- [ ] **理论学习**: 拦截器机制、责任链模式、两种拦截器区别
- [ ] **编码实践**:
  - [ ] 实现自定义拦截器（日志、缓存、重试）
  - [ ] 分析默认拦截器的执行顺序
  - [ ] 实现全局请求加密/解密功能
- [ ] **面试模拟**: 设计网络框架的扩展机制
- [ ] **深度理解**: 理解责任链模式在框架设计中的价值

### 3.3 图片加载 Glide：多级缓存策略
- [ ] **理论学习**: 多级缓存、LruCache、DiskLruCache、Bitmap复用
- [ ] **编码实践**:
  - [ ] 实现简化版的图片缓存框架
  - [ ] 分析不同缓存策略对内存的影响
  - [ ] 优化图片加载的内存使用
- [ ] **面试模拟**: 设计图片加载框架的缓存策略
- [ ] **深度理解**: 理解Bitmap内存管理和复用机制

### 3.4 组件化路由 ARouter：APT 与动态加载
- [ ] **理论学习**: 组件化架构、APT技术、编译期代码生成
- [ ] **编码实践**:
  - [ ] 实现简化版的路由框架
  - [ ] 使用APT生成路由表
  - [ ] 实现跨模块的服务调用
- [ ] **面试模拟**: 解释APT在Android开发中的应用
- [ ] **深度理解**: 理解编译期优化 vs 运行时灵活性的权衡

## 第四章：淬炼篇 - 线上性能与稳定性实战

### 4.1 ANR 诊断与修复
- [ ] **理论学习**: ANR原因、监控方法、traces.txt分析
- [ ] **实践演练**:
  - [ ] 制造和分析不同类型的ANR
  - [ ] 使用Android Vitals监控ANR
  - [ ] 实现ANR监控和预警机制
- [ ] **面试模拟**: 分析实际的ANR案例
- [ ] **深度理解**: 建立ANR问题的完整解决方案

### 4.2 OOM 追猎与内存优化
- [ ] **理论学习**: 内存模型、OOM原因、MAT工具使用
- [ ] **实践演练**:
  - [ ] 制造和分析内存泄漏
  - [ ] 使用MAT分析hprof文件
  - [ ] 实现内存监控和优化方案
- [ ] **面试模拟**: 分析复杂的OOM场景
- [ ] **深度理解**: 建立内存问题的系统性解决方法

### 4.3 APK 打包与安装流程
- [ ] **理论学习**: 构建流程、签名机制、APK优化
- [ ] **实践演练**:
  - [ ] 分析APK构建的各个阶段
  - [ ] 实现APK体积优化方案
  - [ ] 配置不同的签名策略
- [ ] **面试模拟**: 解释R8优化原理
- [ ] **深度理解**: 理解构建优化对开发效率的影响

## 第五章：地平线 - 掌握现代安卓UI

### 5.1 Jetpack Compose 核心思想
- [ ] **理论学习**: 声明式UI、组合与重组、状态管理
- [ ] **编码实践**:
  - [ ] 实现复杂的Compose UI组件
  - [ ] 优化重组性能
  - [ ] 对比Compose vs 传统View的开发体验
- [ ] **面试模拟**: 解释Compose的重组机制
- [ ] **深度理解**: 理解声明式UI范式的核心价值

### 5.2 Compose 中的状态管理：状态提升
- [ ] **理论学习**: 状态提升、单向数据流、副作用处理
- [ ] **编码实践**:
  - [ ] 实现复杂的状态管理场景
  - [ ] 处理各种副作用（LaunchedEffect, DisposableEffect）
  - [ ] 集成ViewModel和Compose
- [ ] **面试模拟**: 设计Compose应用的状态架构
- [ ] **深度理解**: 理解状态管理在现代UI开发中的重要性

## 学习方法 (Learning Methodology)
1. **理论先行**: 每个知识点先理解核心概念和原理
2. **实践强化**: 通过编码练习加深理解
3. **面试模拟**: 模拟真实面试场景，练习表达和思路
4. **深度思考**: 理解设计背后的原因和权衡
5. **定期回顾**: 巩固已学知识，形成知识体系

## 当前进度
- [ ] 开始学习旅程
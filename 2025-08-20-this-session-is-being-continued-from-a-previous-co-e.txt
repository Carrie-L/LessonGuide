â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ âœ» Welcome to Claude Code!                         â”‚
â”‚                                                   â”‚
â”‚   /help for help, /status for your current setup  â”‚
â”‚                                                   â”‚
â”‚   cwd: /mnt/i/10_çŸ¥è¯†ä½“ç³»/é¢è¯•ç»ƒä¹                 â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â— Compact summary (ctrl+r to expand)
  â¿ Â Read micro_tasks/LEARNING_PATH_RECOMMENDATIONS.md (758 lines)
  â¿ Â Read micro_tasks/INSTRUCTOR_MENTOR_GUIDE.md (808 lines)
  â¿ Â Read micro_tasks/FRAMEWORK_DEPLOYMENT_GUIDE.md (661 lines)
  â¿ Â Todo list read (4 items)

â— Looking at the current state of the comprehensive learning framework, I can see we've made excellent progress on
  creating a complete hands-on programming education system. Let me continue with the final task - developing
  learning analytics and progress tracking.

â— Update Todos
  â¿ Â â˜’ Create framework deployment and usage guide     
     â˜’ Design learning path recommendations
     â˜’ Build assessment and certification system
     â˜’ Create instructor/mentor guidance materials
     â˜ Develop learning analytics and progress tracking

â— Write(micro_tasks/LEARNING_ANALYTICS_SYSTEM.md)
  â¿ Â Error writing file

â— ---
  ğŸ¯ ç³»ç»Ÿè®¾è®¡ç›®æ ‡

  æ ¸å¿ƒä»·å€¼ä¸»å¼ 

  - ğŸ“ˆ å®æ—¶è¿›åº¦ç›‘æ§: æ—¶æ—¶è·Ÿè¸ªå­¦ä¹ è€…çš„ç¼–ç¨‹è¿›åº¦å’Œä»£ç è´¨é‡
  - ğŸ§  æ™ºèƒ½å­¦ä¹ åˆ†æ: é€šè¿‡æ•°æ®åˆ†æè¯†åˆ«å­¦ä¹ æ¨¡å¼å’Œæ½œåœ¨é—®é¢˜
  - ğŸ¯ ä¸ªæ€§åŒ–ä¼˜åŒ–: åŸºäºå­¦ä¹ æ•°æ®æä¾›ä¸ªæ€§åŒ–å­¦ä¹ å»ºè®®
  - ğŸ† æˆå°±æ¿€åŠ±ç³»ç»Ÿ: é€šè¿‡æ•°æ®é©±åŠ¨çš„æˆå°±ç³»ç»Ÿæ¿€å‘å­¦ä¹ åŠ¨åŠ›

  ---
  ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

  æ•°æ®æµæ¶æ„

  // å­¦ä¹ åˆ†æç³»ç»Ÿæ ¸å¿ƒæ¶æ„
  class LearningAnalyticsSystem {

      // æ•°æ®æ”¶é›†å±‚
      interface DataCollector {
          fun collectCodeMetrics(studentId: String, code: String)
          fun collectTimeMetrics(studentId: String, startTime: Long, endTime: Long)
          fun collectCompilationMetrics(studentId: String, success: Boolean, errors: List<String>)
          fun collectPerformanceMetrics(studentId: String, benchmarks: Map<String, Double>)
      }

      // æ•°æ®å­˜å‚¨å±‚
      interface DataStorage {
          fun storeStudentProgress(progress: StudentProgress)
          fun retrieveStudentHistory(studentId: String): List<StudentProgress>
          fun storeBenchmarkData(benchmarks: BenchmarkData)
          fun retrieveClassAnalytics(): ClassAnalytics
      }

      // åˆ†æå¼•æ“å±‚
      interface AnalysisEngine {
          fun analyzeStudentProgress(studentId: String): StudentAnalysis
          fun detectLearningPatterns(studentId: String): LearningPatterns
          fun generateRecommendations(analysis: StudentAnalysis): List<Recommendation>
          fun predictOutcomes(studentId: String): OutcomePrediction
      }

      // å¯è§†åŒ–å±‚
      interface VisualizationEngine {
          fun generateProgressReport(studentId: String): ProgressReport
          fun createLearningDashboard(studentId: String): Dashboard
          fun generateClassSummary(classId: String): ClassSummary
      }
  }

  ---
  ğŸ“Š æ ¸å¿ƒæ•°æ®æ¨¡å‹

  å­¦ä¹ è€…æ•°æ®ç»“æ„

  // å®Œæ•´å­¦ä¹ è€…æ•°æ®æ¨¡å‹
  data class StudentProgress(
      val studentId: String,
      val timestamp: Long,
      val sessionInfo: SessionInfo,
      val codeMetrics: CodeMetrics,
      val qualityMetrics: QualityMetrics,
      val performanceMetrics: PerformanceMetrics,
      val learningBehavior: LearningBehavior,
      val achievements: List<Achievement>
  )

  data class SessionInfo(
      val sessionId: String,
      val startTime: Long,
      val endTime: Long,
      val tasksAttempted: List<String>,
      val tasksCompleted: List<String>,
      val helpRequestsCount: Int,
      val compilationAttempts: Int,
      val activeMinutes: Int
  )

  data class CodeMetrics(
      val totalLines: Int,
      val functionalLines: Int,  // æ’é™¤æ³¨é‡Šå’Œç©ºè¡Œ
      val commentLines: Int,
      val classCount: Int,
      val functionCount: Int,
      val complexityScore: Double,  // åœˆå¤æ‚åº¦
      val duplicateCodePercentage: Double,
      val namingQualityScore: Double
  )

  data class QualityMetrics(
      val overallScore: Double,  // 0-100
      val structureScore: Double,
      val readabilityScore: Double,
      val maintainabilityScore: Double,
      val testCoverageScore: Double,
      val errorHandlingScore: Double,
      val performanceConsiderationScore: Double
  )

  data class PerformanceMetrics(
      val compilationTime: Long,
      val executionTime: Long,
      val memoryUsage: Long,
      val algorithmComplexity: String,
      val benchmarkResults: Map<String, Double>,
      val optimizationLevel: String
  )

  data class LearningBehavior(
      val strugglingTasks: List<String>,
      val quickMasteryTasks: List<String>,
      val preferredLearningTime: List<Int>,  // hours of day
      val averageSessionDuration: Int,
      val helpSeekingPattern: String,  // "proactive", "reactive", "independent"
      val codeReviewEngagement: Double,
      val debuggingEfficiency: Double
  )

  data class Achievement(
      val id: String,
      val name: String,
      val description: String,
      val level: AchievementLevel,
      val earnedAt: Long,
      val criteria: String,
      val points: Int
  )

  enum class AchievementLevel { BRONZE, SILVER, GOLD, PLATINUM, DIAMOND }

  åˆ†æç»“æœæ•°æ®ç»“æ„

  // å­¦ä¹ åˆ†æç»“æœ
  data class StudentAnalysis(
      val studentId: String,
      val analysisTimestamp: Long,
      val overallProgress: ProgressAnalysis,
      val skillAssessment: SkillAssessment,
      val learningVelocity: LearningVelocity,
      val strengthsWeaknesses: StrengthsWeaknesses,
      val riskFactors: List<RiskFactor>,
      val recommendations: List<Recommendation>
  )

  data class ProgressAnalysis(
      val completionRate: Double,
      val qualityTrend: TrendAnalysis,
      val velocityTrend: TrendAnalysis,
      val consistencyScore: Double,
      val milestoneProgress: Map<String, Double>
  )

  data class SkillAssessment(
      val concurrencyProgramming: Double,  // 0-100
      val dataStructures: Double,
      val algorithmDesign: Double,
      val systemDesign: Double,
      val codeQuality: Double,
      val problemSolving: Double,
      val technicalCommunication: Double
  )

  data class LearningVelocity(
      val tasksPerHour: Double,
      val linesPerHour: Double,
      val qualityEfficiency: Double,  // è´¨é‡æå‡é€Ÿç‡
      val conceptMasterySpeed: Double,
      val velocityTrend: String  // "accelerating", "stable", "declining"
  )

  data class StrengthsWeaknesses(
      val topStrengths: List<SkillArea>,
      val improvementAreas: List<SkillArea>,
      val hiddenTalents: List<SkillArea>,  // AIå‘ç°çš„æ½œåœ¨ä¼˜åŠ¿
      val riskAreas: List<SkillArea>
  )

  data class SkillArea(
      val name: String,
      val score: Double,
      val evidence: String,
      val recommendation: String
  )

  ---
  ğŸ¤– æ™ºèƒ½åˆ†æå¼•æ“

  å­¦ä¹ æ¨¡å¼è¯†åˆ«ç®—æ³•

  // å­¦ä¹ æ¨¡å¼è¯†åˆ«å’Œåˆ†æå¼•æ“
  class IntelligentLearningAnalyzer {

      fun analyzeStudentProgress(studentId: String): StudentAnalysis {
          val history = dataStorage.retrieveStudentHistory(studentId)
          val recentSessions = history.takeLast(10)

          return StudentAnalysis(
              studentId = studentId,
              analysisTimestamp = System.currentTimeMillis(),
              overallProgress = analyzeOverallProgress(history),
              skillAssessment = assessSkills(history),
              learningVelocity = analyzeLearningVelocity(recentSessions),
              strengthsWeaknesses = identifyStrengthsWeaknesses(history),
              riskFactors = detectRiskFactors(history),
              recommendations = generateSmartRecommendations(history)
          )
      }

      private fun analyzeOverallProgress(history: List<StudentProgress>): ProgressAnalysis {
          val completionRate = calculateCompletionRate(history)
          val qualityTrend = analyzeQualityTrend(history)
          val velocityTrend = analyzeVelocityTrend(history)
          val consistencyScore = calculateConsistencyScore(history)

          return ProgressAnalysis(
              completionRate = completionRate,
              qualityTrend = qualityTrend,
              velocityTrend = velocityTrend,
              consistencyScore = consistencyScore,
              milestoneProgress = calculateMilestoneProgress(history)
          )
      }

      private fun analyzeQualityTrend(history: List<StudentProgress>): TrendAnalysis {
          val qualityScores = history.map { it.qualityMetrics.overallScore }
          val recentAvg = qualityScores.takeLast(5).average()
          val earlierAvg = qualityScores.take(5).average()

          val improvement = recentAvg - earlierAvg
          val volatility = calculateVolatility(qualityScores)

          return TrendAnalysis(
              direction = when {
                  improvement > 10 -> "improving"
                  improvement < -10 -> "declining"
                  else -> "stable"
              },
              strength = when {
                  improvement > 20 -> "strong"
                  improvement > 10 -> "moderate"
                  improvement > -10 -> "weak"
                  else -> "concerning"
              },
              volatility = volatility,
              confidence = calculateTrendConfidence(qualityScores)
          )
      }

      private fun assessSkills(history: List<StudentProgress>): SkillAssessment {
          // åŸºäºä»»åŠ¡å®Œæˆæƒ…å†µå’Œä»£ç è´¨é‡è¯„ä¼°å„é¡¹æŠ€èƒ½
          val tasksByCategory = categorizeTasksBySkill(history)

          return SkillAssessment(
              concurrencyProgramming = assessSkillLevel(tasksByCategory["concurrency"] ?: emptyList()),
              dataStructures = assessSkillLevel(tasksByCategory["dataStructures"] ?: emptyList()),
              algorithmDesign = assessSkillLevel(tasksByCategory["algorithms"] ?: emptyList()),
              systemDesign = assessSkillLevel(tasksByCategory["systemDesign"] ?: emptyList()),
              codeQuality = history.map { it.qualityMetrics.overallScore }.average(),
              problemSolving = assessProblemSolvingSkill(history),
              technicalCommunication = assessTechnicalCommunication(history)
          )
      }

      private fun assessSkillLevel(taskResults: List<TaskResult>): Double {
          if (taskResults.isEmpty()) return 0.0

          val successRate = taskResults.count { it.completed } / taskResults.size.toDouble()
          val avgQuality = taskResults.map { it.qualityScore }.average()
          val avgTime = taskResults.map { it.completionTime }.average()
          val expectedTime = taskResults.map { it.expectedTime }.average()

          val timeEfficiency = (expectedTime / avgTime).coerceIn(0.0, 2.0)

          return (successRate * 0.4 + avgQuality * 0.4 + timeEfficiency * 0.2) * 100
      }

      private fun detectRiskFactors(history: List<StudentProgress>): List<RiskFactor> {
          val riskFactors = mutableListOf<RiskFactor>()

          // å­¦ä¹ åœæ»é£é™©
          if (isLearningStagnant(history)) {
              riskFactors.add(RiskFactor(
                  type = "learning_stagnation",
                  severity = "high",
                  description = "å­¦ä¹ è¿›åº¦åœæ»ï¼Œè´¨é‡åˆ†æ•°è¿ç»­ä¸‹é™",
                  recommendation = "å»ºè®®è°ƒæ•´å­¦ä¹ ç­–ç•¥ï¼Œå¯»æ±‚å¯¼å¸ˆæŒ‡å¯¼"
              ))
          }

          // è¿‡åº¦ä¾èµ–é£é™©
          if (isOverlyDependent(history)) {
              riskFactors.add(RiskFactor(
                  type = "over_dependency",
                  severity = "medium",
                  description = "é¢‘ç¹æ±‚åŠ©ï¼Œç¼ºä¹ç‹¬ç«‹è§£å†³é—®é¢˜çš„èƒ½åŠ›",
                  recommendation = "é¼“åŠ±ç‹¬ç«‹æ€è€ƒï¼Œå‡å°‘å³æ—¶å¸®åŠ©"
              ))
          }

          // è´¨é‡å¿½è§†é£é™©
          if (isIgnoringQuality(history)) {
              riskFactors.add(RiskFactor(
                  type = "quality_neglect",
                  severity = "medium",
                  description = "è¿½æ±‚å®Œæˆé€Ÿåº¦ï¼Œå¿½è§†ä»£ç è´¨é‡",
                  recommendation = "å¼ºè°ƒä»£ç è´¨é‡çš„é‡è¦æ€§ï¼Œå¢åŠ ä»£ç å®¡æŸ¥"
              ))
          }

          // æ¦‚å¿µç†è§£æµ…å±‚åŒ–é£é™©
          if (hasShallowUnderstanding(history)) {
              riskFactors.add(RiskFactor(
                  type = "shallow_understanding",
                  severity = "high",
                  description = "å¿«é€Ÿå®Œæˆä»»åŠ¡ä½†ç¼ºä¹æ·±åº¦ç†è§£",
                  recommendation = "å¢åŠ æ¦‚å¿µæ·±åº¦æŒ–æ˜ï¼Œè‹æ ¼æ‹‰åº•å¼å¯¹è¯"
              ))
          }

          return riskFactors
      }

      private fun generateSmartRecommendations(history: List<StudentProgress>): List<Recommendation> {
          val recommendations = mutableListOf<Recommendation>()
          val analysis = analyzeOverallProgress(history)
          val skills = assessSkills(history)

          // åŸºäºæŠ€èƒ½è¯„ä¼°çš„æ¨è
          val weakestSkill = listOf(
              "concurrency" to skills.concurrencyProgramming,
              "dataStructures" to skills.dataStructures,
              "algorithms" to skills.algorithmDesign,
              "systemDesign" to skills.systemDesign
          ).minByOrNull { it.second }

          weakestSkill?.let { (skill, score) ->
              if (score < 70) {
                  recommendations.add(Recommendation(
                      type = "skill_focus",
                      priority = "high",
                      title = "é‡ç‚¹æå‡${skill}æŠ€èƒ½",
                      description = "å½“å‰${skill}æŠ€èƒ½å¾—åˆ†ä»…${score.toInt()}åˆ†ï¼Œå»ºè®®é‡ç‚¹ç»ƒä¹ ç›¸å…³ä»»åŠ¡",
                      actionItems = listOf(
                          "å›é¡¾${skill}åŸºç¡€æ¦‚å¿µ",
                          "å®Œæˆé¢å¤–çš„${skill}ç»ƒä¹ é¢˜",
                          "å¯»æ±‚å¯¼å¸ˆé’ˆå¯¹æ€§æŒ‡å¯¼"
                      ),
                      estimatedImpact = "high"
                  ))
              }
          }

          // åŸºäºå­¦ä¹ æ¨¡å¼çš„æ¨è
          if (analysis.velocityTrend.direction == "declining") {
              recommendations.add(Recommendation(
                  type = "velocity_improvement",
                  priority = "medium",
                  title = "æå‡å­¦ä¹ æ•ˆç‡",
                  description = "å­¦ä¹ é€Ÿåº¦å‘ˆä¸‹é™è¶‹åŠ¿ï¼Œå»ºè®®è°ƒæ•´å­¦ä¹ ç­–ç•¥",
                  actionItems = listOf(
                      "åˆ†ææ—¶é—´ä½¿ç”¨æƒ…å†µ",
                      "ä¼˜åŒ–å­¦ä¹ ç¯å¢ƒ",
                      "è°ƒæ•´å­¦ä¹ æ—¶é—´æ®µ",
                      "è€ƒè™‘ç•ªèŒ„å·¥ä½œæ³•"
                  ),
                  estimatedImpact = "medium"
              ))
          }

          // åŸºäºä»£ç è´¨é‡çš„æ¨è
          val recentQuality = history.takeLast(5).map { it.qualityMetrics.overallScore }.average()
          if (recentQuality < 75) {
              recommendations.add(Recommendation(
                  type = "quality_improvement",
                  priority = "high",
                  title = "æå‡ä»£ç è´¨é‡",
                  description = "è¿‘æœŸä»£ç è´¨é‡å¹³å‡åˆ†ä¸º${recentQuality.toInt()}ï¼Œéœ€è¦é‡ç‚¹æ”¹è¿›",
                  actionItems = listOf(
                      "å­¦ä¹ ä»£ç è§„èŒƒå’Œæœ€ä½³å®è·µ",
                      "å¢åŠ ä»£ç æ³¨é‡Šå’Œæ–‡æ¡£",
                      "é‡æ„ç°æœ‰ä»£ç ",
                      "å‚ä¸ä»£ç å®¡æŸ¥æ´»åŠ¨"
                  ),
                  estimatedImpact = "high"
              ))
          }

          return recommendations
      }

      // è¾…åŠ©åˆ†ææ–¹æ³•
      private fun isLearningStagnant(history: List<StudentProgress>): Boolean {
          val recentProgress = history.takeLast(5)
          val qualityTrend = recentProgress.map { it.qualityMetrics.overallScore }
          return qualityTrend.zipWithNext().all { (prev, curr) -> curr <= prev }
      }

      private fun isOverlyDependent(history: List<StudentProgress>): Boolean {
          val recentSessions = history.takeLast(10)
          val avgHelpRequests = recentSessions.map { it.sessionInfo.helpRequestsCount }.average()
          return avgHelpRequests > 3.0  // æ¯ä¸ªsessionè¶…è¿‡3æ¬¡æ±‚åŠ©
      }

      private fun isIgnoringQuality(history: List<StudentProgress>): Boolean {
          return history.takeLast(5).all { progress ->
              // å®Œæˆé€Ÿåº¦å¿«ä½†è´¨é‡ä½
              progress.sessionInfo.tasksCompleted.size > 2 &&
              progress.qualityMetrics.overallScore < 70
          }
      }

      private fun hasShallowUnderstanding(history: List<StudentProgress>): Boolean {
          // é€šè¿‡ç¼–è¯‘é”™è¯¯æ¬¡æ•°å’Œå¸®åŠ©è¯·æ±‚æ¨¡å¼åˆ¤æ–­ç†è§£æ·±åº¦
          return history.takeLast(5).any { progress ->
              progress.sessionInfo.compilationAttempts > 5 &&
              progress.sessionInfo.helpRequestsCount > 2
          }
      }
  }

  data class TrendAnalysis(
      val direction: String,  // "improving", "stable", "declining"
      val strength: String,   // "strong", "moderate", "weak", "concerning"
      val volatility: Double, // 0-1, æ³¢åŠ¨æ€§
      val confidence: Double  // 0-1, è¶‹åŠ¿å¯ä¿¡åº¦
  )

  data class RiskFactor(
      val type: String,
      val severity: String,
      val description: String,
      val recommendation: String
  )

  data class Recommendation(
      val type: String,
      val priority: String,
      val title: String,
      val description: String,
      val actionItems: List<String>,
      val estimatedImpact: String
  )

  ---
  ğŸ“ˆ å®æ—¶ç›‘æ§ä¸ä»ªè¡¨ç›˜

  å­¦ä¹ ä»ªè¡¨ç›˜ç³»ç»Ÿ

  // å®æ—¶å­¦ä¹ ä»ªè¡¨ç›˜
  class LearningDashboard {

      fun generateStudentDashboard(studentId: String): Dashboard {
          val analysis = analyticsEngine.analyzeStudentProgress(studentId)
          val recentActivity = getRecentActivity(studentId, 7) // è¿‘7å¤©

          return Dashboard(
              studentId = studentId,
              overview = createOverviewWidget(analysis),
              progressCharts = createProgressCharts(studentId),
              skillRadar = createSkillRadarChart(analysis.skillAssessment),
              achievementProgress = createAchievementWidget(studentId),
              todaysFocus = createTodaysFocusWidget(analysis.recommendations),
              peerComparison = createPeerComparisonWidget(studentId),
              learningStreak = createLearningStreakWidget(studentId)
          )
      }

      private fun createOverviewWidget(analysis: StudentAnalysis): OverviewWidget {
          return OverviewWidget(
              overallProgress = "${(analysis.overallProgress.completionRate * 100).toInt()}%",
              qualityScore = "${analysis.skillAssessment.codeQuality.toInt()}/100",
              learningVelocity = "${analysis.learningVelocity.tasksPerHour.format(1)} tasks/hour",
              currentStreak = calculateCurrentStreak(analysis.studentId),
              nextMilestone = findNextMilestone(analysis.studentId),
              riskLevel = determineRiskLevel(analysis.riskFactors)
          )
      }

      private fun createProgressCharts(studentId: String): ProgressCharts {
          val history = dataStorage.retrieveStudentHistory(studentId)

          return ProgressCharts(
              qualityTrendChart = createQualityTrendChart(history),
              velocityChart = createVelocityChart(history),
              taskCompletionChart = createTaskCompletionChart(history),
              timeDistributionChart = createTimeDistributionChart(history),
              strugglingTopicsChart = createStrugglingTopicsChart(history)
          )
      }

      private fun createSkillRadarChart(skills: SkillAssessment): SkillRadarChart {
          return SkillRadarChart(
              axes = listOf(
                  RadarAxis("å¹¶å‘ç¼–ç¨‹", skills.concurrencyProgramming),
                  RadarAxis("æ•°æ®ç»“æ„", skills.dataStructures),
                  RadarAxis("ç®—æ³•è®¾è®¡", skills.algorithmDesign),
                  RadarAxis("ç³»ç»Ÿè®¾è®¡", skills.systemDesign),
                  RadarAxis("ä»£ç è´¨é‡", skills.codeQuality),
                  RadarAxis("é—®é¢˜è§£å†³", skills.problemSolving),
                  RadarAxis("æŠ€æœ¯è¡¨è¾¾", skills.technicalCommunication)
              ),
              averageScore = listOf(skills.concurrencyProgramming, skills.dataStructures,
                                  skills.algorithmDesign, skills.systemDesign,
                                  skills.codeQuality, skills.problemSolving,
                                  skills.technicalCommunication).average()
          )
      }

      fun generateInstructorDashboard(classId: String): InstructorDashboard {
          val classAnalytics = dataStorage.retrieveClassAnalytics()
          val students = getClassStudents(classId)

          return InstructorDashboard(
              classOverview = createClassOverview(students),
              studentsAtRisk = identifyStudentsAtRisk(students),
              topPerformers = identifyTopPerformers(students),
              commonStruggles = identifyCommonStruggles(students),
              engagementMetrics = calculateEngagementMetrics(students),
              recommendedActions = generateInstructorActions(students)
          )
      }

      private fun identifyStudentsAtRisk(students: List<String>): List<StudentRiskProfile> {
          return students.map { studentId ->
              val analysis = analyticsEngine.analyzeStudentProgress(studentId)
              StudentRiskProfile(
                  studentId = studentId,
                  riskLevel = determineRiskLevel(analysis.riskFactors),
                  primaryConcerns = analysis.riskFactors.take(3),
                  suggestedIntervention = generateInterventionPlan(analysis.riskFactors),
                  urgency = calculateInterventionUrgency(analysis)
              )
          }.filter { it.riskLevel != "low" }.sortedByDescending { it.urgency }
      }

      private fun identifyCommonStruggles(students: List<String>): List<CommonStruggle> {
          val allStruggles = students.flatMap { studentId ->
              val analysis = analyticsEngine.analyzeStudentProgress(studentId)
              analysis.strengthsWeaknesses.improvementAreas
          }

          return allStruggles.groupBy { it.name }
              .map { (struggle, instances) ->
                  CommonStruggle(
                      topicName = struggle,
                      affectedStudentCount = instances.size,
                      affectedStudentPercentage = instances.size / students.size.toDouble() * 100,
                      averageScore = instances.map { it.score }.average(),
                      recommendedClassAction = generateClassIntervention(struggle, instances.size)
                  )
              }.sortedByDescending { it.affectedStudentCount }
      }
  }

  // ä»ªè¡¨ç›˜æ•°æ®ç»“æ„
  data class Dashboard(
      val studentId: String,
      val overview: OverviewWidget,
      val progressCharts: ProgressCharts,
      val skillRadar: SkillRadarChart,
      val achievementProgress: AchievementWidget,
      val todaysFocus: TodaysFocusWidget,
      val peerComparison: PeerComparisonWidget,
      val learningStreak: LearningStreakWidget
  )

  data class OverviewWidget(
      val overallProgress: String,
      val qualityScore: String,
      val learningVelocity: String,
      val currentStreak: Int,
      val nextMilestone: String,
      val riskLevel: String
  )

  data class StudentRiskProfile(
      val studentId: String,
      val riskLevel: String,
      val primaryConcerns: List<RiskFactor>,
      val suggestedIntervention: String,
      val urgency: Double
  )

  data class CommonStruggle(
      val topicName: String,
      val affectedStudentCount: Int,
      val affectedStudentPercentage: Double,
      val averageScore: Double,
      val recommendedClassAction: String
  )

  ---
  ğŸ† æ¿€åŠ±ä¸æˆå°±ç³»ç»Ÿ

  æ™ºèƒ½æˆå°±ç³»ç»Ÿ

  // æ™ºèƒ½æˆå°±ç³»ç»Ÿ
  class IntelligentAchievementSystem {

      private val achievements = listOf(
          // åŸºç¡€æˆå°±
          Achievement("first_sync", "åˆå‡ºèŒ…åº", "å®Œæˆç¬¬ä¸€ä¸ªsynchronizedå®ç°", AchievementLevel.BRONZE, 10),
          Achievement("thread_safe", "çº¿ç¨‹å®‰å…¨ä¸“å®¶", "è¿ç»­5ä¸ªä»»åŠ¡éƒ½åŒ…å«æ­£ç¡®çš„çº¿ç¨‹å®‰å…¨å®ç°",
  AchievementLevel.SILVER, 25),
          Achievement("performance_guru", "æ€§èƒ½å¤§å¸ˆ", "å®ç°çš„ç®—æ³•æ€§èƒ½è¶…è¶ŠåŸºå‡†50%", AchievementLevel.GOLD, 50),
          Achievement("code_artist", "ä»£ç è‰ºæœ¯å®¶", "ä»£ç è´¨é‡è¿ç»­10æ¬¡è¯„åˆ†90+", AchievementLevel.GOLD, 50),

          // è¿›é˜¶æˆå°±
          Achievement("system_architect", "ç³»ç»Ÿæ¶æ„å¸ˆ", "è®¾è®¡å®Œæ•´çš„ä¼ä¸šçº§ç³»ç»Ÿæ¶æ„", AchievementLevel.PLATINUM,
  100),
          Achievement("concurrency_master", "å¹¶å‘ç¼–ç¨‹å¤§å¸ˆ", "æ·±åº¦æŒæ¡æ‰€æœ‰å¹¶å‘ç¼–ç¨‹æ¦‚å¿µ", AchievementLevel.PLATINUM,
  75),
          Achievement("optimization_wizard", "ä¼˜åŒ–å‘å¯¼", "å®ç°å¤šä¸ªç®—æ³•çš„æ˜¾è‘—æ€§èƒ½ä¼˜åŒ–", AchievementLevel.DIAMOND,
  150),

          // ç‰¹æ®Šæˆå°±
          Achievement("bug_hunter", "BugçŒäºº", "å¿«é€Ÿå®šä½å’Œä¿®å¤å¤æ‚å¹¶å‘é—®é¢˜", AchievementLevel.GOLD, 40),
          Achievement("mentor_helper", "åŠ©äººä¸ºä¹", "ç§¯æå¸®åŠ©å…¶ä»–å­¦å‘˜è§£å†³é—®é¢˜", AchievementLevel.SILVER, 30),
          Achievement("perfectionist", "å®Œç¾ä¸»ä¹‰è€…", "æ‰€æœ‰ä»»åŠ¡éƒ½è¾¾åˆ°100%å®Œæˆåº¦", AchievementLevel.DIAMOND, 200),

          // å­¦ä¹ è¡Œä¸ºæˆå°±
          Achievement("early_bird", "æ—©èµ·é¸Ÿ", "è¿ç»­7å¤©åœ¨æ—©æ™¨å­¦ä¹ ", AchievementLevel.BRONZE, 15),
          Achievement("night_owl", "å¤œçŒ«å­", "è¿ç»­5å¤©åœ¨æ·±å¤œé«˜æ•ˆå­¦ä¹ ", AchievementLevel.BRONZE, 15),
          Achievement("consistency_king", "æŒç»­ä¹‹ç‹", "è¿ç»­30å¤©ä¿æŒå­¦ä¹ ", AchievementLevel.PLATINUM, 100),
          Achievement("speed_demon", "é—ªç”µä¾ ", "å­¦ä¹ é€Ÿåº¦è¿›å…¥ç­çº§å‰10%", AchievementLevel.SILVER, 35),

          // åˆ›æ–°æˆå°±
          Achievement("innovator", "åˆ›æ–°è€…", "æå‡ºç‹¬ç‰¹ä¸”æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆ", AchievementLevel.GOLD, 60),
          Achievement("algorithm_creator", "ç®—æ³•åˆ›é€ è€…", "è®¾è®¡åŸåˆ›ç®—æ³•è§£å†³é—®é¢˜", AchievementLevel.DIAMOND, 150),
          Achievement("framework_builder", "æ¡†æ¶æ„å»ºè€…", "æ„å»ºå¯å¤ç”¨çš„æŠ€æœ¯æ¡†æ¶", AchievementLevel.PLATINUM, 120)
      )

      fun checkAndAwardAchievements(studentId: String): List<Achievement> {
          val progress = dataStorage.retrieveStudentHistory(studentId)
          val analysis = analyticsEngine.analyzeStudentProgress(studentId)
          val earnedAchievements = mutableListOf<Achievement>()

          achievements.forEach { achievement ->
              if (!hasAchievement(studentId, achievement.id) &&
                  meetsAchievementCriteria(achievement, progress, analysis)) {
                  awardAchievement(studentId, achievement)
                  earnedAchievements.add(achievement)
              }
          }

          return earnedAchievements
      }

      private fun meetsAchievementCriteria(
          achievement: Achievement, 
          progress: List<StudentProgress>,
          analysis: StudentAnalysis
      ): Boolean {
          return when (achievement.id) {
              "first_sync" -> hasFirstSynchronizedImplementation(progress)
              "thread_safe" -> hasConsistentThreadSafety(progress)
              "performance_guru" -> hasPerformanceExcellence(progress)
              "code_artist" -> hasHighCodeQuality(progress)
              "system_architect" -> hasSystemArchitectureSkills(analysis)
              "concurrency_master" -> hasConcurrencyMastery(analysis)
              "bug_hunter" -> hasBugHuntingSkills(progress)
              "early_bird" -> hasEarlyLearningPattern(progress)
              "night_owl" -> hasNightLearningPattern(progress)
              "consistency_king" -> hasLearningConsistency(progress)
              "speed_demon" -> hasHighLearningSpeed(analysis)
              "innovator" -> hasInnovativeSolutions(progress)
              "perfectionist" -> hasPerfectCompletion(progress)
              else -> false
          }
      }

      private fun hasFirstSynchronizedImplementation(progress: List<StudentProgress>): Boolean {
          return progress.any { session ->
              session.sessionInfo.tasksCompleted.any { task ->
                  task.contains("synchronized") || task.contains("1.1.1")
              }
          }
      }

      private fun hasConsistentThreadSafety(progress: List<StudentProgress>): Boolean {
          val recentThreadingTasks = progress.takeLast(5)
              .flatMap { it.sessionInfo.tasksCompleted }
              .filter { task -> task.contains("thread") || task.contains("concurrent") }

          return recentThreadingTasks.size >= 5 &&
                 progress.takeLast(5).all { it.qualityMetrics.overallScore >= 80 }
      }

      private fun hasPerformanceExcellence(progress: List<StudentProgress>): Boolean {
          return progress.any { session ->
              session.performanceMetrics.benchmarkResults.values.any { result ->
                  result > 1.5 // æ€§èƒ½æå‡50%ä»¥ä¸Š
              }
          }
      }

      private fun hasHighCodeQuality(progress: List<StudentProgress>): Boolean {
          val recentSessions = progress.takeLast(10)
          return recentSessions.size >= 10 &&
                 recentSessions.all { it.qualityMetrics.overallScore >= 90 }
      }

      private fun hasSystemArchitectureSkills(analysis: StudentAnalysis): Boolean {
          return analysis.skillAssessment.systemDesign >= 85 &&
                 analysis.overallProgress.completionRate >= 0.8
      }

      private fun hasConcurrencyMastery(analysis: StudentAnalysis): Boolean {
          return analysis.skillAssessment.concurrencyProgramming >= 90 &&
                 analysis.skillAssessment.problemSolving >= 85
      }

      private fun hasEarlyLearningPattern(progress: List<StudentProgress>): Boolean {
          val recentWeek = progress.filter {
              it.timestamp > System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000
          }

          return recentWeek.count { session ->
              val hour = java.time.LocalDateTime
                  .ofInstant(java.time.Instant.ofEpochMilli(session.timestamp),
                            java.time.ZoneId.systemDefault()).hour
              hour in 6..9  // æ—©æ™¨6-9ç‚¹
          } >= 7
      }

      private fun hasLearningConsistency(progress: List<StudentProgress>): Boolean {
          val thirtyDaysAgo = System.currentTimeMillis() - 30 * 24 * 60 * 60 * 1000
          val recentProgress = progress.filter { it.timestamp > thirtyDaysAgo }

          // æ£€æŸ¥æ˜¯å¦è¿ç»­30å¤©éƒ½æœ‰å­¦ä¹ æ´»åŠ¨
          val learningDays = recentProgress.map {
              java.time.LocalDate.ofInstant(
                  java.time.Instant.ofEpochMilli(it.timestamp),
                  java.time.ZoneId.systemDefault()
              )
          }.distinct()

          return learningDays.size >= 30
      }

      private fun hasInnovativeSolutions(progress: List<StudentProgress>): Boolean {
          // æ£€æŸ¥ä»£ç ä¸­æ˜¯å¦åŒ…å«åˆ›æ–°æ ‡è®°æˆ–ç‹¬ç‰¹è§£å†³æ–¹æ¡ˆ
          return progress.any { session ->
              session.qualityMetrics.overallScore >= 95 &&
              session.codeMetrics.complexityScore > 0 &&
              session.sessionInfo.helpRequestsCount == 0  // ç‹¬ç«‹å®Œæˆ
          }
      }

      fun generateAchievementRecommendations(studentId: String): List<AchievementRecommendation> {
          val analysis = analyticsEngine.analyzeStudentProgress(studentId)
          val earnedAchievements = getEarnedAchievements(studentId)

          return achievements.filter { !earnedAchievements.contains(it.id) }
              .map { achievement ->
                  val progress = calculateAchievementProgress(studentId, achievement)
                  AchievementRecommendation(
                      achievement = achievement,
                      currentProgress = progress,
                      estimatedTimeToEarn = estimateTimeToAchievement(studentId, achievement),
                      actionSteps = generateActionSteps(studentId, achievement),
                      difficulty = calculateAchievementDifficulty(studentId, achievement)
                  )
              }
              .sortedBy { it.estimatedTimeToEarn }
      }
  }

  data class AchievementRecommendation(
      val achievement: Achievement,
      val currentProgress: Double,  // 0-1
      val estimatedTimeToEarn: Int, // hours
      val actionSteps: List<String>,
      val difficulty: String
  )

  ---
  ğŸ“Š å­¦ä¹ æ•ˆæœé¢„æµ‹æ¨¡å‹

  æœºå™¨å­¦ä¹ é¢„æµ‹å¼•æ“

  // å­¦ä¹ æ•ˆæœé¢„æµ‹ç³»ç»Ÿ
  class LearningOutcomePredictionEngine {

      fun predictLearningOutcome(studentId: String): OutcomePrediction {
          val features = extractLearningFeatures(studentId)
          val historicalData = getHistoricalSuccessData()

          return OutcomePrediction(
              studentId = studentId,
              completionProbability = predictCompletionProbability(features),
              estimatedCompletionTime = predictCompletionTime(features),
              qualityForecast = predictQualityProgression(features),
              riskAssessment = assessDropoutRisk(features),
              careerReadiness = predictCareerReadiness(features),
              recommendations = generatePredictiveRecommendations(features)
          )
      }

      private fun extractLearningFeatures(studentId: String): LearningFeatures {
          val history = dataStorage.retrieveStudentHistory(studentId)
          val analysis = analyticsEngine.analyzeStudentProgress(studentId)

          return LearningFeatures(
              // è¿›åº¦ç‰¹å¾
              completionRate = analysis.overallProgress.completionRate,
              averageTaskTime = history.map { it.sessionInfo.endTime - it.sessionInfo.startTime }.average(),
              sessionConsistency = calculateSessionConsistency(history),

              // è´¨é‡ç‰¹å¾
              qualityTrend = analysis.overallProgress.qualityTrend.direction,
              averageQuality = history.map { it.qualityMetrics.overallScore }.average(),
              qualityVolatility = calculateQualityVolatility(history),

              // è¡Œä¸ºç‰¹å¾
              helpSeekingFrequency = history.map { it.sessionInfo.helpRequestsCount }.average(),
              compilationErrorRate = calculateCompilationErrorRate(history),
              debuggingEfficiency = analysis.learningBehavior.debuggingEfficiency,

              // æŠ€èƒ½ç‰¹å¾
              technicalSkillLevel = analysis.skillAssessment.let {
                  (it.concurrencyProgramming + it.dataStructures + it.algorithmDesign) / 3
              },
              problemSolvingSkill = analysis.skillAssessment.problemSolving,

              // æ—¶é—´ç‰¹å¾
              totalLearningHours = history.sumOf { it.sessionInfo.activeMinutes } / 60.0,
              learningFrequency = calculateLearningFrequency(history),
              preferredLearningTimes = analysis.learningBehavior.preferredLearningTime
          )
      }

      private fun predictCompletionProbability(features: LearningFeatures): Double {
          // ç®€åŒ–çš„é¢„æµ‹æ¨¡å‹ï¼ˆå®é™…åº”ç”¨ä¸­ä¼šä½¿ç”¨MLæ¨¡å‹ï¼‰
          var probability = 0.5

          // è¿›åº¦å› ç´ å½±å“
          probability += (features.completionRate - 0.5) * 0.4

          // è´¨é‡è¶‹åŠ¿å½±å“
          probability += when (features.qualityTrend) {
              "improving" -> 0.2
              "stable" -> 0.1
              "declining" -> -0.2
              else -> 0.0
          }

          // å­¦ä¹ è¡Œä¸ºå½±å“
          if (features.sessionConsistency > 0.7) probability += 0.15
          if (features.helpSeekingFrequency < 2.0) probability += 0.1

          // æŠ€èƒ½æ°´å¹³å½±å“
          if (features.technicalSkillLevel > 75) probability += 0.15

          return probability.coerceIn(0.0, 1.0)
      }

      private fun predictCompletionTime(features: LearningFeatures): Int {
          val remainingTasks = calculateRemainingTasks(features.completionRate)
          val averageTaskHours = features.averageTaskTime / (60 * 60 * 1000) // è½¬æ¢ä¸ºå°æ—¶

          var estimatedHours = remainingTasks * averageTaskHours

          // æ ¹æ®å­¦ä¹ æ•ˆç‡è°ƒæ•´
          val efficiencyMultiplier = when {
              features.technicalSkillLevel > 80 -> 0.8  // é«˜æŠ€èƒ½å­¦å‘˜æ›´å¿«
              features.qualityTrend == "improving" -> 0.9
              features.helpSeekingFrequency > 3.0 -> 1.3  // éœ€è¦æ›´å¤šå¸®åŠ©
              else -> 1.0
          }

          estimatedHours *= efficiencyMultiplier

          // è€ƒè™‘å­¦ä¹ é¢‘ç‡
          val weeksToComplete = estimatedHours / (features.learningFrequency * 7)

          return (weeksToComplete * 7 * 24).toInt() // è½¬æ¢ä¸ºå°æ—¶
      }

      private fun predictQualityProgression(features: LearningFeatures): QualityForecast {
          val currentQuality = features.averageQuality
          val trendDirection = features.qualityTrend

          val projectedImprovement = when (trendDirection) {
              "improving" -> 15.0 + (features.technicalSkillLevel - currentQuality) * 0.3
              "stable" -> 5.0
              "declining" -> -10.0 + features.sessionConsistency * 10
              else -> 0.0
          }

          return QualityForecast(
              currentScore = currentQuality,
              projectedFinalScore = (currentQuality + projectedImprovement).coerceIn(0.0, 100.0),
              improvement = projectedImprovement,
              confidence = calculatePredictionConfidence(features)
          )
      }

      private fun assessDropoutRisk(features: LearningFeatures): RiskAssessment {
          var riskScore = 0.0

          // è¿›åº¦é£é™©
          if (features.completionRate < 0.3) riskScore += 0.3

          // è´¨é‡é£é™©
          if (features.qualityTrend == "declining") riskScore += 0.2
          if (features.averageQuality < 60) riskScore += 0.2

          // è¡Œä¸ºé£é™©
          if (features.sessionConsistency < 0.5) riskScore += 0.25
          if (features.helpSeekingFrequency > 4.0) riskScore += 0.15

          val riskLevel = when {
              riskScore > 0.7 -> "high"
              riskScore > 0.4 -> "medium"
              else -> "low"
          }

          return RiskAssessment(
              riskScore = riskScore,
              riskLevel = riskLevel,
              primaryFactors = identifyRiskFactors(features),
              interventionRecommendations = generateInterventionPlan(riskScore, features)
          )
      }

      private fun predictCareerReadiness(features: LearningFeatures): CareerReadinessScore {
          // è¯„ä¼°å­¦å‘˜çš„å°±ä¸šå‡†å¤‡ç¨‹åº¦
          val technicalReadiness = features.technicalSkillLevel * 0.4
          val qualityReadiness = features.averageQuality * 0.3
          val problemSolvingReadiness = features.problemSolvingSkill * 0.2
          val consistencyReadiness = features.sessionConsistency * 100 * 0.1

          val overallReadiness = technicalReadiness + qualityReadiness +
                                problemSolvingReadiness + consistencyReadiness

          return CareerReadinessScore(
              overallScore = overallReadiness,
              technicalScore = features.technicalSkillLevel,
              qualityScore = features.averageQuality,
              problemSolvingScore = features.problemSolvingSkill,
              professionalSkillsScore = features.sessionConsistency * 100,
              readinessLevel = when {
                  overallReadiness > 85 -> "ready"
                  overallReadiness > 70 -> "nearly_ready"
                  overallReadiness > 50 -> "developing"
                  else -> "needs_improvement"
              },
              estimatedReadinessDate = calculateReadinessDate(features, overallReadiness)
          )
      }
  }

  // é¢„æµ‹ç›¸å…³æ•°æ®ç»“æ„
  data class LearningFeatures(
      val completionRate: Double,
      val averageTaskTime: Double,
      val sessionConsistency: Double,
      val qualityTrend: String,
      val averageQuality: Double,
      val qualityVolatility: Double,
      val helpSeekingFrequency: Double,
      val compilationErrorRate: Double,
      val debuggingEfficiency: Double,
      val technicalSkillLevel: Double,
      val problemSolvingSkill: Double,
      val totalLearningHours: Double,
      val learningFrequency: Double,
      val preferredLearningTimes: List<Int>
  )

  data class OutcomePrediction(
      val studentId: String,
      val completionProbability: Double,
      val estimatedCompletionTime: Int,
      val qualityForecast: QualityForecast,
      val riskAssessment: RiskAssessment,
      val careerReadiness: CareerReadinessScore,
      val recommendations: List<String>
  )

  data class QualityForecast(
      val currentScore: Double,
      val projectedFinalScore: Double,
      val improvement: Double,
      val confidence: Double
  )

  data class RiskAssessment(
      val riskScore: Double,
      val riskLevel: String,
      val primaryFactors: List<String>,
      val interventionRecommendations: List<String>
  )

  data class CareerReadinessScore(
      val overallScore: Double,
      val technicalScore: Double,
      val qualityScore: Double,
      val problemSolvingScore: Double,
      val professionalSkillsScore: Double,
      val readinessLevel: String,
      val estimatedReadinessDate: String
  )

  ---
  ğŸ”§ éƒ¨ç½²ä¸é›†æˆæŒ‡å—

  ç³»ç»Ÿéƒ¨ç½²é…ç½®

  // å­¦ä¹ åˆ†æç³»ç»Ÿé…ç½®
  data class AnalyticsSystemConfig(
      val dataCollectionInterval: Long = 60_000,  // 1åˆ†é’Ÿé‡‡é›†ä¸€æ¬¡
      val analysisUpdateInterval: Long = 300_000, // 5åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡åˆ†æ
      val dashboardRefreshInterval: Long = 30_000, // 30ç§’åˆ·æ–°ä»ªè¡¨ç›˜
      val achievementCheckInterval: Long = 600_000, // 10åˆ†é’Ÿæ£€æŸ¥æˆå°±
      val predictionUpdateInterval: Long = 86400_000, // 24å°æ—¶æ›´æ–°é¢„æµ‹
      val dataRetentionDays: Int = 365,
      val enableRealTimeNotifications: Boolean = true,
      val enablePredictiveAnalytics: Boolean = true,
      val enableAchievementSystem: Boolean = true
  )

  // ç³»ç»Ÿåˆå§‹åŒ–å’Œå¯åŠ¨
  class LearningAnalyticsSystemInitializer {

      fun initializeSystem(): LearningAnalyticsSystem {
          val config = loadConfig()
          val dataStorage = createDataStorage(config)
          val analyticsEngine = IntelligentLearningAnalyzer()
          val dashboard = LearningDashboard()
          val achievementSystem = IntelligentAchievementSystem()
          val predictionEngine = LearningOutcomePredictionEngine()

          return LearningAnalyticsSystem(
              config = config,
              dataStorage = dataStorage,
              analyticsEngine = analyticsEngine,
              dashboard = dashboard,
              achievementSystem = achievementSystem,
              predictionEngine = predictionEngine
          ).apply {
              startBackgroundTasks()
          }
      }

      private fun createDataStorage(config: AnalyticsSystemConfig): DataStorage {
          // åˆ›å»ºæ•°æ®å­˜å‚¨å±‚ï¼ˆå¯ä»¥æ˜¯æ–‡ä»¶ç³»ç»Ÿã€æ•°æ®åº“ç­‰ï¼‰
          return FileBasedDataStorage(
              basePath = "analytics_data",
              retentionDays = config.dataRetentionDays
          )
      }
  }

  // ä¸å­¦ä¹ æ¡†æ¶é›†æˆ
  class FrameworkIntegration {

      fun integrateWithLearningFramework(framework: HandsOnLearningFramework) {
          val analyticsSystem = LearningAnalyticsSystemInitializer().initializeSystem()

          // é›†æˆæ•°æ®æ”¶é›†
          framework.onTaskStart { studentId, taskId ->
              analyticsSystem.recordTaskStart(studentId, taskId, System.currentTimeMillis())
          }

          framework.onTaskComplete { studentId, taskId, code, metrics ->
              analyticsSystem.recordTaskCompletion(
                  studentId, taskId, code, metrics, System.currentTimeMillis()
              )

              // æ£€æŸ¥æˆå°±
              val newAchievements = analyticsSystem.checkAchievements(studentId)
              if (newAchievements.isNotEmpty()) {
                  framework.notifyAchievements(studentId, newAchievements)
              }
          }

          framework.onCodeSubmission { studentId, code ->
              analyticsSystem.recordCodeSubmission(studentId, code, System.currentTimeMillis())
          }

          framework.onHelpRequest { studentId, question ->
              analyticsSystem.recordHelpRequest(studentId, question, System.currentTimeMillis())
          }
      }
  }

  ---
  â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  å­¦ä¹ åˆ†æç³»ç»Ÿçš„æ ¸å¿ƒä»·å€¼ï¼š
  1. æ•°æ®é©±åŠ¨å†³ç­–: åŸºäºå®¢è§‚æ•°æ®è€Œéä¸»è§‚æ„Ÿå—æ¥æŒ‡å¯¼å­¦ä¹ 
  2. ä¸ªæ€§åŒ–ä¼˜åŒ–: ä¸ºæ¯ä¸ªå­¦ä¹ è€…æä¾›é‡èº«å®šåˆ¶çš„å­¦ä¹ å»ºè®®
  3. é¢„æµ‹æ€§å¹²é¢„: æå‰è¯†åˆ«é—®é¢˜å¹¶é‡‡å–é¢„é˜²æªæ–½
  4. æŒç»­æ¿€åŠ±: é€šè¿‡æˆå°±ç³»ç»Ÿç»´æŒå­¦ä¹ åŠ¨æœºå’Œå‚ä¸åº¦
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  å®Œæ•´çš„å­¦ä¹ åˆ†æç³»ç»Ÿå°†æ•°æ®è½¬åŒ–ä¸ºæ´å¯Ÿï¼Œæ´å¯Ÿè½¬åŒ–ä¸ºè¡ŒåŠ¨ï¼Œç¡®ä¿æ¯ä¸ªå­¦ä¹ è€…éƒ½èƒ½è·å¾—æœ€ä½³çš„å­¦ä¹ æ•ˆæœï¼


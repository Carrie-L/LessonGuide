# ADHD-Friendly Micro Tasks (5分钟每个任务)

## 🎯 当前学习: 第一章 1.1 并发原语：synchronized, volatile 与 JMM

### Phase 1: 基础概念理解 (20分钟总计)

#### Task 1.1.1: JMM概念入门 (5分钟) ⏰
- [ ] **学习目标**: 理解什么是Java内存模型
- [ ] **具体任务**: 阅读并理解"工作内存vs主内存"的概念
- [ ] **检查点**: 能用自己的话解释JMM的基本结构
- [ ] **文件**: 在`student_progress/`创建`jmm_notes.md`记录理解

#### Task 1.1.2: happens-before原则 (5分钟) ⏰  
- [ ] **学习目标**: 理解happens-before的核心思想
- [ ] **具体任务**: 学习"如果A happens-before B，那么A的结果对B可见"
- [ ] **检查点**: 能举例说明happens-before关系
- [ ] **文件**: 在`jmm_notes.md`中添加happens-before例子

#### Task 1.1.3: synchronized基本原理 (5分钟) ⏰
- [ ] **学习目标**: 理解synchronized的monitor机制
- [ ] **具体任务**: 学习"每个对象都有monitor锁"的概念
- [ ] **检查点**: 能解释线程如何获取和释放monitor
- [ ] **文件**: 在`student_progress/`创建`synchronized_notes.md`

#### Task 1.1.4: volatile基本原理 (5分钟) ⏰
- [ ] **学习目标**: 理解volatile的两个作用
- [ ] **具体任务**: 学习"可见性+禁止重排序"
- [ ] **检查点**: 能解释为什么volatile不能保证原子性
- [ ] **文件**: 在`student_progress/`创建`volatile_notes.md`

### Phase 2: 锁升级机制深入 (15分钟总计)

#### Task 1.1.5: 偏向锁概念 (5分钟) ⏰
- [ ] **学习目标**: 理解偏向锁的优化思想
- [ ] **具体任务**: 学习"锁偏向第一个获取它的线程"
- [ ] **检查点**: 能解释偏向锁什么时候有效
- [ ] **文件**: 在`synchronized_notes.md`中添加偏向锁部分

#### Task 1.1.6: 轻量级锁机制 (5分钟) ⏰
- [ ] **学习目标**: 理解CAS自旋的原理
- [ ] **具体任务**: 学习轻量级锁的CAS操作
- [ ] **检查点**: 能解释为什么叫"轻量级"
- [ ] **文件**: 继续在`synchronized_notes.md`中添加

#### Task 1.1.7: 重量级锁升级 (5分钟) ⏰
- [ ] **学习目标**: 理解什么时候升级为重量级锁
- [ ] **具体任务**: 学习"用户态vs内核态切换"的开销
- [ ] **检查点**: 能说出锁升级的完整流程
- [ ] **文件**: 完善`synchronized_notes.md`

### Phase 3: 动手编码验证 (30分钟总计)

#### Task 1.1.8: 创建基础测试类 (5分钟) ⏰
- [ ] **学习目标**: 搭建测试环境
- [ ] **具体任务**: 创建`SynchronizedDemo.java`类框架
- [ ] **检查点**: 类能编译运行
- [ ] **文件**: `student_progress/SynchronizedDemo.java`

#### Task 1.1.9: synchronized方法测试 (5分钟) ⏰
- [ ] **学习目标**: 验证synchronized方法的互斥性
- [ ] **具体任务**: 写一个synchronized方法，多线程调用
- [ ] **检查点**: 观察到线程串行执行
- [ ] **文件**: 完善`SynchronizedDemo.java`

#### Task 1.1.10: synchronized代码块测试 (5分钟) ⏰
- [ ] **学习目标**: 对比方法锁vs对象锁
- [ ] **具体任务**: 实现synchronized(this)和synchronized(object)
- [ ] **检查点**: 理解不同锁对象的影响
- [ ] **文件**: 继续完善`SynchronizedDemo.java`

#### Task 1.1.11: 创建volatile测试 (5分钟) ⏰
- [ ] **学习目标**: 验证volatile的可见性
- [ ] **具体任务**: 创建`VolatileDemo.java`，测试可见性问题
- [ ] **检查点**: 观察有无volatile的区别
- [ ] **文件**: `student_progress/VolatileDemo.java`

#### Task 1.1.12: volatile不保证原子性测试 (5分钟) ⏰
- [ ] **学习目标**: 验证volatile在i++时的问题
- [ ] **具体任务**: 多线程对volatile变量进行i++操作
- [ ] **检查点**: 观察到数据丢失问题
- [ ] **文件**: 完善`VolatileDemo.java`

#### Task 1.1.13: 对比测试程序 (5分钟) ⏰
- [ ] **学习目标**: 直观对比两者差异
- [ ] **具体任务**: 创建对比测试，展示适用场景
- [ ] **检查点**: 能清楚说明何时用哪个
- [ ] **文件**: `student_progress/ComparisonDemo.java`

### Phase 4: 面试题实战 (15分钟总计)

#### Task 1.1.14: 经典问题准备 (5分钟) ⏰
- [ ] **学习目标**: 准备标准面试回答
- [ ] **具体任务**: 整理"synchronized vs volatile"的标准答案
- [ ] **检查点**: 回答包含原子性、可见性、使用场景
- [ ] **文件**: `student_progress/interview_qa.md`

#### Task 1.1.15: 追问题练习 (5分钟) ⏰
- [ ] **学习目标**: 准备深度问题
- [ ] **具体任务**: 准备CAS、偏向锁废弃等追问的回答
- [ ] **检查点**: 能从设计角度思考问题
- [ ] **文件**: 完善`interview_qa.md`

#### Task 1.1.16: 知识点总结 (5分钟) ⏰
- [ ] **学习目标**: 形成完整知识图谱
- [ ] **具体任务**: 画出synchronized和volatile的知识导图
- [ ] **检查点**: 能快速回顾所有要点
- [ ] **文件**: `student_progress/summary.md`

## 🎯 学习检查点 (Checkpoint Questions)

在完成每个Phase后，我会问你这些问题来确认理解：

### Phase 1 检查问题:
1. "请用你自己的话解释什么是JMM？"
2. "给我举个happens-before的例子"
3. "synchronized和volatile的核心区别是什么？"

### Phase 2 检查问题:
1. "为什么JVM要设计锁升级机制？"
2. "什么情况下偏向锁会失效？"
3. "轻量级锁的自旋有什么风险？"

### Phase 3 检查问题:
1. "你的代码中，为什么synchronized能保证线程安全？"
2. "为什么volatile的i++会丢失数据？"
3. "什么场景下你会选择volatile而不是synchronized？"

### Phase 4 检查问题:
1. "如果面试官问'既然有了synchronized，为什么还需要volatile？'你怎么回答？"
2. "CAS和synchronized的锁升级有什么关系？"

---

# 🎯 1.2 主力集合：HashMap & ConcurrentHashMap 源码剖析

## Phase 5: HashMap基础原理 (25分钟总计)

#### Task 1.2.1: HashMap基本结构理解 (5分钟) ⏰
- [ ] **学习目标**: 理解"数组+链表+红黑树"结构
- [ ] **具体任务**: 学习HashMap内部的Node数组概念
- [ ] **检查点**: 能画出HashMap的基本结构图
- [ ] **文件**: 创建`student_progress/hashmap_notes.md`

#### Task 1.2.2: hash函数和索引计算 (5分钟) ⏰
- [ ] **学习目标**: 理解hashCode()到数组索引的转换
- [ ] **具体任务**: 学习`(n-1) & hash`的位运算技巧
- [ ] **检查点**: 能解释为什么容量必须是2的幂次方
- [ ] **文件**: 在`hashmap_notes.md`中添加hash计算部分

#### Task 1.2.3: JDK1.7 vs 1.8差异 (5分钟) ⏰
- [ ] **学习目标**: 理解链表到红黑树的优化
- [ ] **具体任务**: 学习TREEIFY_THRESHOLD=8的设计原理
- [ ] **检查点**: 能解释为什么选择8作为阈值
- [ ] **文件**: 继续完善`hashmap_notes.md`

#### Task 1.2.4: put方法流程分析 (5分钟) ⏰
- [ ] **学习目标**: 理解HashMap插入元素的完整流程
- [ ] **具体任务**: 梳理hash计算→定位→插入→扩容的流程
- [ ] **检查点**: 能完整描述put方法的执行步骤
- [ ] **文件**: 添加put流程图到notes中

#### Task 1.2.5: 扩容机制深入 (5分钟) ⏰
- [ ] **学习目标**: 理解resize()方法和rehash过程
- [ ] **具体任务**: 学习负载因子0.75的设计考虑
- [ ] **检查点**: 能解释扩容时元素重新分布的规律
- [ ] **文件**: 完善扩容机制说明

## Phase 6: ConcurrentHashMap并发控制 (25分钟总计)

#### Task 1.2.6: JDK1.7分段锁机制 (5分钟) ⏰
- [ ] **学习目标**: 理解Segment数组的设计思想
- [ ] **具体任务**: 学习分段锁如何降低锁竞争
- [ ] **检查点**: 能解释为什么并发度等于Segment数量
- [ ] **文件**: 创建`student_progress/concurrenthashmap_notes.md`

#### Task 1.2.7: JDK1.8优化策略 (5分钟) ⏰
- [ ] **学习目标**: 理解CAS+synchronized的新方案
- [ ] **具体任务**: 学习锁粒度从Segment缩小到Node头节点
- [ ] **检查点**: 能对比1.7和1.8的并发性能差异
- [ ] **文件**: 在notes中添加1.8优化部分

#### Task 1.2.8: get操作的无锁设计 (5分钟) ⏰
- [ ] **学习目标**: 理解读操作如何实现近似无锁
- [ ] **具体任务**: 学习volatile保证可见性的机制
- [ ] **检查点**: 能解释为什么get方法几乎不需要加锁
- [ ] **文件**: 添加get操作分析

#### Task 1.2.9: CAS操作原理 (5分钟) ⏰
- [ ] **学习目标**: 理解Compare-And-Swap的无锁算法
- [ ] **具体任务**: 学习CAS的ABA问题和解决方案
- [ ] **检查点**: 能解释CAS在ConcurrentHashMap中的应用
- [ ] **文件**: 添加CAS原理说明

#### Task 1.2.10: 计数器CounterCell设计 (5分钟) ⏰
- [ ] **学习目标**: 理解size()方法在并发环境下的挑战
- [ ] **具体任务**: 学习分段计数的设计思想
- [ ] **检查点**: 能解释为什么不直接用AtomicLong
- [ ] **文件**: 完善并发控制机制说明

## Phase 7: 手写HashMap实现 (30分钟总计)

#### Task 1.2.11: 创建基础框架 (5分钟) ⏰
- [ ] **学习目标**: 搭建自定义HashMap的基本结构
- [ ] **具体任务**: 创建MyHashMap类和Node内部类
- [ ] **检查点**: 基础类结构能编译通过
- [ ] **文件**: `student_progress/MyHashMap.java`

#### Task 1.2.12: 实现hash函数 (5分钟) ⏰
- [ ] **学习目标**: 实现高效的hash计算方法
- [ ] **具体任务**: 实现hash()和indexFor()方法
- [ ] **检查点**: hash分布均匀，索引计算正确
- [ ] **文件**: 完善`MyHashMap.java`

#### Task 1.2.13: 实现put方法 (5分钟) ⏰
- [ ] **学习目标**: 实现元素插入逻辑
- [ ] **具体任务**: 处理hash冲突和链表插入
- [ ] **检查点**: 能正确插入键值对
- [ ] **文件**: 继续完善`MyHashMap.java`

#### Task 1.2.14: 实现get方法 (5分钟) ⏰
- [ ] **学习目标**: 实现元素查找逻辑
- [ ] **具体任务**: 遍历链表查找目标key
- [ ] **检查点**: 能正确获取对应的value
- [ ] **文件**: 继续完善`MyHashMap.java`

#### Task 1.2.15: 实现扩容机制 (5分钟) ⏰
- [ ] **学习目标**: 实现动态扩容和rehash
- [ ] **具体任务**: 当负载因子超过阈值时自动扩容
- [ ] **检查点**: 扩容后数据完整性保持
- [ ] **文件**: 完善`MyHashMap.java`

#### Task 1.2.16: 测试和优化 (5分钟) ⏰
- [ ] **学习目标**: 验证实现的正确性
- [ ] **具体任务**: 编写测试用例，对比性能
- [ ] **检查点**: 与JDK HashMap行为一致
- [ ] **文件**: 创建`student_progress/HashMapTest.java`

## Phase 8: 并发安全对比测试 (20分钟总计)

#### Task 1.2.17: 创建并发测试框架 (5分钟) ⏰
- [ ] **学习目标**: 搭建多线程测试环境
- [ ] **具体任务**: 创建多线程同时操作Map的测试
- [ ] **检查点**: 能模拟高并发场景
- [ ] **文件**: `student_progress/ConcurrencyTest.java`

#### Task 1.2.18: HashMap并发问题演示 (5分钟) ⏰
- [ ] **学习目标**: 观察HashMap在并发环境下的问题
- [ ] **具体任务**: 演示数据丢失、无限循环等问题
- [ ] **检查点**: 能重现JDK1.7的死循环bug
- [ ] **文件**: 完善`ConcurrencyTest.java`

#### Task 1.2.19: ConcurrentHashMap安全性验证 (5分钟) ⏰
- [ ] **学习目标**: 验证ConcurrentHashMap的线程安全性
- [ ] **具体任务**: 相同条件下测试ConcurrentHashMap
- [ ] **检查点**: 观察到数据一致性和性能优势
- [ ] **文件**: 继续完善测试代码

#### Task 1.2.20: 性能基准测试 (5分钟) ⏰
- [ ] **学习目标**: 对比不同Map在并发场景下的性能
- [ ] **具体任务**: 测试读写操作的吞吐量
- [ ] **检查点**: 理解不同实现的性能特点
- [ ] **文件**: 添加性能测试结果

## Phase 9: 面试题实战训练 (15分钟总计)

#### Task 1.2.21: 经典问题准备 (5分钟) ⏰
- [ ] **学习目标**: 准备HashMap核心面试问题
- [ ] **具体任务**: 整理容量2的幂次方、扩容机制等问题
- [ ] **检查点**: 能从底层原理解释设计决策
- [ ] **文件**: 更新`student_progress/interview_qa.md`

#### Task 1.2.22: 白板编程练习 (5分钟) ⏰
- [ ] **学习目标**: 练习手写HashMap关键方法
- [ ] **具体任务**: 在纸上写出put方法的伪代码
- [ ] **检查点**: 逻辑清晰，考虑边界情况
- [ ] **文件**: 拍照上传手写代码到progress文件夹

#### Task 1.2.23: 追问题深度回答 (5分钟) ⏰
- [ ] **学习目标**: 准备深度技术问题
- [ ] **具体任务**: 准备红黑树、一致性hash等进阶问题
- [ ] **检查点**: 能扩展到分布式系统设计
- [ ] **文件**: 完善面试问答集

---

# 🎯 1.3 现代范式：Kotlin 协程

## Phase 10: 协程基础理念 (25分钟总计)

#### Task 1.3.1: 协程vs线程对比 (5分钟) ⏰
- [ ] **学习目标**: 理解协程的轻量级特性
- [ ] **具体任务**: 学习用户态vs内核态的区别
- [ ] **检查点**: 能解释为什么协程比线程轻量
- [ ] **文件**: 创建`student_progress/coroutine_notes.md`

#### Task 1.3.2: 挂起vs阻塞概念 (5分钟) ⏰
- [ ] **学习目标**: 理解suspend的核心思想
- [ ] **具体任务**: 学习协程如何让出线程执行权
- [ ] **检查点**: 能区分suspend和block的本质差异
- [ ] **文件**: 在notes中添加挂起机制说明

#### Task 1.3.3: 结构化并发原理 (5分钟) ⏰
- [ ] **学习目标**: 理解CoroutineScope的生命周期管理
- [ ] **具体任务**: 学习父子协程的取消传播机制
- [ ] **检查点**: 能解释如何避免协程泄漏
- [ ] **文件**: 添加结构化并发部分

#### Task 1.3.4: CoroutineContext组成 (5分钟) ⏰
- [ ] **学习目标**: 理解协程上下文的构成要素
- [ ] **具体任务**: 学习Job、Dispatcher、CoroutineName等组件
- [ ] **检查点**: 能解释上下文继承和覆盖规则
- [ ] **文件**: 添加Context说明

#### Task 1.3.5: Dispatchers调度器详解 (5分钟) ⏰
- [ ] **学习目标**: 理解不同调度器的适用场景
- [ ] **具体任务**: 学习Main、IO、Default、Unconfined的区别
- [ ] **检查点**: 能为不同任务选择合适的调度器
- [ ] **文件**: 完善调度器说明

## Phase 11: 协程核心API实践 (30分钟总计)

#### Task 1.3.6: launch和async对比 (5分钟) ⏰
- [ ] **学习目标**: 理解两种启动方式的区别
- [ ] **具体任务**: 实现"发射后不管"vs"需要返回值"的场景
- [ ] **检查点**: 知道何时用Job何时用Deferred
- [ ] **文件**: `student_progress/CoroutineBasics.kt`

#### Task 1.3.7: runBlocking使用场景 (5分钟) ⏰
- [ ] **学习目标**: 理解阻塞式协程的适用性
- [ ] **具体任务**: 在main函数和测试中使用runBlocking
- [ ] **检查点**: 理解为什么生产代码要避免runBlocking
- [ ] **文件**: 完善`CoroutineBasics.kt`

#### Task 1.3.8: withContext线程切换 (5分钟) ⏰
- [ ] **学习目标**: 实现协程间的线程切换
- [ ] **具体任务**: 模拟网络请求+UI更新的场景
- [ ] **检查点**: 能安全地在不同线程间切换
- [ ] **文件**: 创建`student_progress/ThreadSwitching.kt`

#### Task 1.3.9: 协程取消机制 (5分钟) ⏰
- [ ] **学习目标**: 理解协程的取消和异常处理
- [ ] **具体任务**: 实现可取消的长时间运行任务
- [ ] **检查点**: 能正确响应取消信号
- [ ] **文件**: 创建`student_progress/CancellationDemo.kt`

#### Task 1.3.10: suspend函数编写 (5分钟) ⏰
- [ ] **学习目标**: 创建自定义的挂起函数
- [ ] **具体任务**: 包装回调式API为suspend函数
- [ ] **检查点**: 理解suspend的传染性
- [ ] **文件**: 创建`student_progress/SuspendFunctions.kt`

#### Task 1.3.11: 异常处理策略 (5分钟) ⏰
- [ ] **学习目标**: 理解协程中的异常传播
- [ ] **具体任务**: 使用try-catch和CoroutineExceptionHandler
- [ ] **检查点**: 能处理结构化并发中的异常
- [ ] **文件**: 创建`student_progress/ExceptionHandling.kt`

## Phase 12: 实际应用场景练习 (25分钟总计)

#### Task 1.3.12: 网络请求对比实现 (5分钟) ⏰
- [ ] **学习目标**: 对比回调vs协程的代码可读性
- [ ] **具体任务**: 同一个网络请求用两种方式实现
- [ ] **检查点**: 体验协程消除回调地狱的优势
- [ ] **文件**: `student_progress/NetworkComparison.kt`

#### Task 1.3.13: 并发网络请求 (5分钟) ⏰
- [ ] **学习目标**: 实现多个请求的并发执行
- [ ] **具体任务**: 使用async+awaitAll并发获取数据
- [ ] **检查点**: 理解并发vs并行的区别
- [ ] **文件**: 完善`NetworkComparison.kt`

#### Task 1.3.14: Flow基础使用 (5分钟) ⏰
- [ ] **学习目标**: 理解Flow的响应式数据流
- [ ] **具体任务**: 创建简单的数据流和变换操作
- [ ] **检查点**: 能区分Flow和传统的观察者模式
- [ ] **文件**: `student_progress/FlowBasics.kt`

#### Task 1.3.15: StateFlow和SharedFlow (5分钟) ⏰
- [ ] **学习目标**: 理解状态流和事件流的区别
- [ ] **具体任务**: 实现MVVM模式中的状态管理
- [ ] **检查点**: 理解热流vs冷流的概念
- [ ] **文件**: 创建`student_progress/StateManagement.kt`

#### Task 1.3.16: 协程测试编写 (5分钟) ⏰
- [ ] **学习目标**: 学会测试协程代码
- [ ] **具体任务**: 使用TestCoroutineDispatcher编写单元测试
- [ ] **检查点**: 能控制测试中的时间流逝
- [ ] **文件**: `student_progress/CoroutineTest.kt`

## Phase 13: 底层原理探索 (20分钟总计)

#### Task 1.3.17: suspend关键字原理 (5分钟) ⏰
- [ ] **学习目标**: 理解编译器如何处理suspend
- [ ] **具体任务**: 查看反编译后的状态机代码
- [ ] **检查点**: 理解CPS(Continuation Passing Style)变换
- [ ] **文件**: 在notes中添加编译原理说明

#### Task 1.3.18: Continuation接口分析 (5分钟) ⏰
- [ ] **学习目标**: 理解协程的底层实现机制
- [ ] **具体任务**: 分析Continuation的resumeWith方法
- [ ] **检查点**: 理解协程如何实现挂起和恢复
- [ ] **文件**: 添加Continuation原理说明

#### Task 1.3.19: 协程调度原理 (5分钟) ⏰
- [ ] **学习目标**: 理解协程如何被调度执行
- [ ] **具体任务**: 分析EventLoop和线程池的配合
- [ ] **检查点**: 理解协程并不绑定线程的原理
- [ ] **文件**: 添加调度机制说明

#### Task 1.3.20: 性能特点分析 (5分钟) ⏰
- [ ] **学习目标**: 理解协程的性能优势和局限性
- [ ] **具体任务**: 对比协程vs线程的创建销毁开销
- [ ] **检查点**: 理解协程适用的场景边界
- [ ] **文件**: 完善性能分析

## Phase 14: 协程面试准备 (15分钟总计)

#### Task 1.3.21: 核心概念问答 (5分钟) ⏰
- [ ] **学习目标**: 准备协程基础概念问题
- [ ] **具体任务**: 整理协程vs线程、挂起机制等答案
- [ ] **检查点**: 能清晰解释协程的核心优势
- [ ] **文件**: 更新`interview_qa.md`

#### Task 1.3.22: 实际应用问题 (5分钟) ⏰
- [ ] **学习目标**: 准备协程在Android中的应用
- [ ] **具体任务**: 整理viewModelScope、lifecycleScope等问题
- [ ] **检查点**: 能结合Android生命周期解释协程使用
- [ ] **文件**: 添加Android相关问答

#### Task 1.3.23: 深度技术问题 (5分钟) ⏰
- [ ] **学习目标**: 准备协程底层原理问题
- [ ] **具体任务**: 整理状态机、CPS变换等深度问题
- [ ] **检查点**: 能从编译器角度解释协程实现
- [ ] **文件**: 完善深度问答

## 🎯 第一章学习检查点汇总

### 1.1 并发原语检查问题:
1. "JMM的核心作用是什么？工作内存和主内存如何交互？"
2. "synchronized的锁升级过程体现了什么设计思想？"
3. "volatile不能保证原子性，那什么时候用它最合适？"
4. "能手写一个线程安全的单例模式吗？用synchronized和volatile两种方式。"

### 1.2 集合框架检查问题:
1. "为什么HashMap的容量必须是2的幂次方？能从位运算角度解释吗？"
2. "ConcurrentHashMap 1.8的get操作几乎无锁，它如何保证读到最新数据？"
3. "让你设计一个线程安全的缓存，你会怎么设计？"
4. "能在白板上画出HashMap的put流程吗？包括扩容场景。"

### 1.3 协程机制检查问题:
1. "协程的suspend关键字底层是如何实现的？"
2. "launch和async的使用场景有什么区别？"
3. "结构化并发如何解决传统异步编程的问题？"
4. "能用协程重写一个回调地狱的网络请求吗？"

## 🏆 第一章总进度跟踪
- **1.1 并发原语**: 0/16 tasks (预计完成时间: 1.5小时)
- **1.2 集合框架**: 0/13 tasks (预计完成时间: 1.2小时)  
- **1.3 协程机制**: 0/14 tasks (预计完成时间: 1.3小时)
- **第一章总计**: 0/43 tasks (预计完成时间: 4小时)

## 📝 学习节奏建议
- 每个Phase完成后休息10分钟
- 每完成一个大主题(1.1/1.2/1.3)进行全面checkpoint
- 发现不理解的概念立即深入讨论
- 代码必须亲手实现，不能只看不写
- 保持ADHD友好的学习节奏！
# JMM可见性问题深度解析

## 🧠 内存模型示意图

```
          CPU1 (Reader线程)                CPU2 (Writer线程)
     ┌─────────────────────────┐      ┌─────────────────────────┐
     │    工作内存 (L1缓存)     │      │    工作内存 (L1缓存)     │
     │  flag = false ❌        │      │  flag = true ✅         │
     │  counter = 0            │      │  counter = 42           │
     └─────────────────────────┘      └─────────────────────────┘
                 ↑                                ↓
                 │ 读取缓存                        │ 写入但未同步
                 │ (可能过期)                      │
         ┌───────────────────────────────────────────────────────┐
         │                主内存 (RAM)                           │
         │  flag = true ✅                                      │
         │  counter = 42                                        │
         └───────────────────────────────────────────────────────┘
```

## 🔄 问题发生过程

1. **Writer线程修改**: 写入主内存，flag=true
2. **Reader线程读取**: 从自己的缓存读取，flag仍然是false
3. **缓存不一致**: 两个CPU看到了不同的数据状态
4. **无限循环**: Reader被困在while(!flag)中

## ❓ 为什么reader.isAlive() = true是问题？

正常情况：
- Reader看到flag=true → 退出while循环 → 线程结束 → isAlive()=false

可见性问题：
- Reader看不到flag=true → 永远在while循环 → 线程不结束 → isAlive()=true

**isAlive()=true 意味着reader线程被困在无限循环中！**
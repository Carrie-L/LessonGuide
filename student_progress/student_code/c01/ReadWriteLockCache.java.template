/**
 * Task 1.1.11: 读写锁优化方案 - 缓存系统实现
 * 
 * 任务要求：
 * 1. 使用ReadWriteLock实现高性能缓存系统
 * 2. 理解读写锁的性能特点
 * 3. 实现生产级的线程安全缓存
 * 4. 学习锁升级和锁降级的概念
 * 
 * ⚠️ 这是企业级缓存系统的实现，注重实用性
 */
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.HashMap;
import java.util.Map;

public class ReadWriteLockCache<K, V> {
    
    // TODO 1: 声明缓存和读写锁
    // private final Map<K, V> cache = ?;
    // private final ReadWriteLock rwLock = ?;
    // private final Lock readLock = ?;
    // private final Lock writeLock = ?;
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== 读写锁缓存系统实现与性能分析 ===");
        
        // TODO 2: 基本功能测试
        demonstrateBasicOperations();
        
        // TODO 3: 性能对比测试
        performanceComparison();
        
        // TODO 4: 并发读写测试
        concurrentReadWriteTest();
        
        // TODO 5: 真实场景模拟
        simulateRealWorldScenario();
    }
    
    /**
     * TODO: 实现基本功能演示
     */
    private static void demonstrateBasicOperations() {
        System.out.println("\n--- 基本功能测试 ---");
        
        // ReadWriteLockCache<String, String> cache = new ReadWriteLockCache<>();
        
        // TODO: 测试写入操作
        // TODO: 测试读取操作
        // TODO: 测试条件操作
    }
    
    /**
     * TODO: 实现线程安全的put操作
     */
    public void put(K key, V value) {
        // TODO: 使用写锁保护
        // writeLock.lock();
        // try {
        //     cache.put(key, value);
        // } finally {
        //     writeLock.unlock();
        // }
    }
    
    /**
     * TODO: 实现线程安全的get操作
     */
    public V get(K key) {
        // TODO: 使用读锁保护
        // readLock.lock();
        // try {
        //     return cache.get(key);
        // } finally {
        //     readLock.unlock();
        // }
    }
    
    /**
     * TODO: 实现其他基本操作
     */
    public V remove(K key) {
        // TODO: 使用写锁实现remove
    }
    
    public boolean containsKey(K key) {
        // TODO: 使用读锁实现containsKey
    }
    
    public int size() {
        // TODO: 使用读锁实现size
    }
    
    /**
     * TODO: 实现性能对比测试
     */
    private static void performanceComparison() throws InterruptedException {
        System.out.println("\n--- 性能对比测试 ---");
        
        // TODO: 测试读写锁缓存
        
        // TODO: 测试synchronized缓存
        
        // TODO: 测试ConcurrentHashMap
        
        // TODO: 对比性能结果
    }
    
    /**
     * TODO: 实现并发读写测试
     */
    private static void concurrentReadWriteTest() throws InterruptedException {
        System.out.println("\n--- 并发读写压力测试 ---");
        
        // TODO: 创建多个读者线程（6个）
        // TODO: 创建少量写者线程（2个）
        // TODO: 观察读写锁的并发特性
    }
    
    /**
     * TODO: 实现真实场景模拟
     */
    private static void simulateRealWorldScenario() throws InterruptedException {
        System.out.println("\n--- 真实场景模拟：配置缓存系统 ---");
        
        // TODO: 创建配置缓存系统
        // ConfigCache configCache = new ConfigCache();
        
        // TODO: 模拟大量并发读取配置
        
        // TODO: 模拟偶尔的配置更新
    }
    
    /**
     * TODO: 实现配置缓存类
     */
    static class ConfigCache {
        // private final ReadWriteLockCache<String, String> cache = new ReadWriteLockCache<>();
        
        // public void initializeConfig() {
        //     TODO: 初始化配置项
        // }
        
        // public String getConfig(String key) {
        //     TODO: 获取配置
        // }
        
        // public void updateConfig(String key, String value) {
        //     TODO: 更新配置
        // }
    }
    
    /**
     * TODO: 实现缓存接口用于性能对比
     */
    interface CacheInterface<K, V> {
        void put(K key, V value);
        V get(K key);
        int size();
    }
    
    /**
     * TODO: 实现同步缓存用于对比
     */
    static class SynchronizedCache<K, V> implements CacheInterface<K, V> {
        // private final Map<K, V> cache = new HashMap<>();
        
        // @Override
        // public synchronized void put(K key, V value) {
        //     TODO: 实现synchronized版本
        // }
    }
}
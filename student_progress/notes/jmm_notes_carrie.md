
    1 # JMM、Happens-Befo时间线：re、Volatile与Synchronized核心笔记
    2
    3 ## 1. 为什么需要Java内存模型 (JMM)？
    4
    5 *   **核心问题**:
      CPU为了速度引入了高速缓存，导致了多线程环境下的三个问题。
    6     *   **可见性**:
      [请用您自己的话描述，例如：一个线程改了东西，另一个线程看不见]
    7     *   **原子性**:
      [请用您自己的话描述，例如：一个转账操作，只做了一半]
    8     *   **有序性**:
      [请用您自己的话描述，例如：代码的顺序和执行的顺序可能不一样]
    9 *   **JMM的作用**:
      [请总结JMM的价值，例如：它是一套规则，用来屏蔽底层硬件差异，保证...]
   10
   11 ## 2. Happens-Before原则是什么？
   12
   13 *   **一句话理解**: [请用“接力赛”的比喻来描述]
   14 *   **核心保证**: 如果 A happens-before B，那么 JMM 保证...
   15 *   **我理解的关键规则**:
   16     *   **volatile规则**:
      对volatile变量的写，happens-before于后续对它的读。
   17     *   **锁规则**:
      对一个锁的解锁，happens-before于后续对同一个锁的加锁。
   18
   19 ## 3. Volatile vs Synchronized
   20
   21 ### `volatile` (公开的公告栏)
   22
   23 *   **解决什么问题**: [请填写：主要解决的是三大问题中的哪一个？]
   24 *   **如何解决**: [请结合“强制写回主存”和“强制从主存读”来描述]
   25 *   **不解决什么问题**: [请填写：它不能保证什么？比如 i++ 操作]
   26 *   **优点**: 轻量级，开销比synchronized小。
   27 *   **缺点**: 功能单一。
   28
   29 ### `synchronized` (带锁的会议室)
   30
   31 *   **解决什么问题**: [请填写：它解决了三大问题中的哪几个？]
   32 *   **如何解决**:
   33     *   **原子性**: [请结合“一次只进一个人”的比喻来描述]
   34     *   **可见性**: [请结合“进门前清空、出门前同步”的比喻来描述]
   35 *   **优点**: 功能强大，一步到位。
   36 *   **缺点**: [请填写：相比volatile，它的代价是什么？]

   ---

### JMM可见性问题

正常情况（使用volatile）下应该发生什么：

时间线：
0ms:    reader线程启动，进入while(!flag)循环 - - 每次都从主内存读取flag
1000ms: writer线程醒来，设置counter=42，flag=true - volatile写，立即同步到主内存
1001ms: reader线程应该看到flag=true，退出while循环
1003ms: reader线程的run()方法结束，线程自然死亡
3000ms: 主线程检查，reader.isAlive()应该返回false （线程已经结束）

可见性问题发生时：

时间线：
0ms:    reader线程启动，进入while(!flag)循环 - flag在reader缓存中是false
1000ms: writer线程设置counter=42，flag=true - 写入主内存，但reader缓存未更新
1001ms: ❌ reader线程的工作内存中flag仍然是false！ → 无限循环
3000ms: ❌ reader.isAlive()返回true （线程被困在while循环中）- 问题确认！

🎯 线程结束 = run()方法执行完毕
